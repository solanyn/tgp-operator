// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for ContainerRegistriesListParamsOrderBy.
const (
	ContainerRegistriesListParamsOrderByDtCreated ContainerRegistriesListParamsOrderBy = "dtCreated"
)

// Defines values for ContainerRegistriesListParamsOrder.
const (
	ContainerRegistriesListParamsOrderAsc  ContainerRegistriesListParamsOrder = "asc"
	ContainerRegistriesListParamsOrderDesc ContainerRegistriesListParamsOrder = "desc"
)

// Defines values for ContainerRegistriesCreateJSONBodyKind.
const (
	ContainerRegistriesCreateJSONBodyKindAzure        ContainerRegistriesCreateJSONBodyKind = "azure"
	ContainerRegistriesCreateJSONBodyKindDigitalocean ContainerRegistriesCreateJSONBodyKind = "digitalocean"
	ContainerRegistriesCreateJSONBodyKindDockerhub    ContainerRegistriesCreateJSONBodyKind = "dockerhub"
	ContainerRegistriesCreateJSONBodyKindGcr          ContainerRegistriesCreateJSONBodyKind = "gcr"
	ContainerRegistriesCreateJSONBodyKindGhcr         ContainerRegistriesCreateJSONBodyKind = "ghcr"
	ContainerRegistriesCreateJSONBodyKindOther        ContainerRegistriesCreateJSONBodyKind = "other"
)

// Defines values for ContainerRegistriesUpdateJSONBodyKind.
const (
	ContainerRegistriesUpdateJSONBodyKindAzure        ContainerRegistriesUpdateJSONBodyKind = "azure"
	ContainerRegistriesUpdateJSONBodyKindDigitalocean ContainerRegistriesUpdateJSONBodyKind = "digitalocean"
	ContainerRegistriesUpdateJSONBodyKindDockerhub    ContainerRegistriesUpdateJSONBodyKind = "dockerhub"
	ContainerRegistriesUpdateJSONBodyKindGcr          ContainerRegistriesUpdateJSONBodyKind = "gcr"
	ContainerRegistriesUpdateJSONBodyKindGhcr         ContainerRegistriesUpdateJSONBodyKind = "ghcr"
	ContainerRegistriesUpdateJSONBodyKindOther        ContainerRegistriesUpdateJSONBodyKind = "other"
)

// Defines values for CustomTemplatesListParamsOrderBy.
const (
	CustomTemplatesListParamsOrderByDtCreated CustomTemplatesListParamsOrderBy = "dtCreated"
	CustomTemplatesListParamsOrderByName      CustomTemplatesListParamsOrderBy = "name"
)

// Defines values for CustomTemplatesListParamsOrder.
const (
	CustomTemplatesListParamsOrderAsc  CustomTemplatesListParamsOrder = "asc"
	CustomTemplatesListParamsOrderDesc CustomTemplatesListParamsOrder = "desc"
)

// Defines values for DatasetsListParamsOrderBy.
const (
	DatasetsListParamsOrderByDtCreated DatasetsListParamsOrderBy = "dtCreated"
)

// Defines values for DatasetsListParamsOrder.
const (
	DatasetsListParamsOrderAsc  DatasetsListParamsOrder = "asc"
	DatasetsListParamsOrderDesc DatasetsListParamsOrder = "desc"
)

// Defines values for DatasetsListParamsPrivacy1.
const (
	PRIVATE DatasetsListParamsPrivacy1 = "PRIVATE"
	PUBLIC  DatasetsListParamsPrivacy1 = "PUBLIC"
)

// Defines values for DatasetVersionsListParamsOrderBy.
const (
	DatasetVersionsListParamsOrderByDtCreated DatasetVersionsListParamsOrderBy = "dtCreated"
)

// Defines values for DatasetVersionsListParamsOrder.
const (
	DatasetVersionsListParamsOrderAsc  DatasetVersionsListParamsOrder = "asc"
	DatasetVersionsListParamsOrderDesc DatasetVersionsListParamsOrder = "desc"
)

// Defines values for DeploymentsListParamsOrderBy.
const (
	DeploymentsListParamsOrderByDtCreated DeploymentsListParamsOrderBy = "dtCreated"
)

// Defines values for DeploymentsListParamsOrder.
const (
	DeploymentsListParamsOrderAsc  DeploymentsListParamsOrder = "asc"
	DeploymentsListParamsOrderDesc DeploymentsListParamsOrder = "desc"
)

// Defines values for DeploymentsUpsertJSONBodyConfig00ApiVersion.
const (
	V0alpha0 DeploymentsUpsertJSONBodyConfig00ApiVersion = "v0alpha0"
)

// Defines values for DeploymentsUpsertJSONBodyConfig00Region0.
const (
	DeploymentsUpsertJSONBodyConfig00Region0Ny2 DeploymentsUpsertJSONBodyConfig00Region0 = "ny2"
)

// Defines values for DeploymentsUpsertJSONBodyConfig00Region1.
const (
	DeploymentsUpsertJSONBodyConfig00Region1Ca1 DeploymentsUpsertJSONBodyConfig00Region1 = "ca1"
)

// Defines values for DeploymentsUpsertJSONBodyConfig00Region2.
const (
	DeploymentsUpsertJSONBodyConfig00Region2Ams1 DeploymentsUpsertJSONBodyConfig00Region2 = "ams1"
)

// Defines values for DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics0Metric.
const (
	DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics0MetricRequestDuration DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics0Metric = "requestDuration"
)

// Defines values for DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics0Summary.
const (
	DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics0SummaryAverage DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics0Summary = "average"
)

// Defines values for DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics1Metric.
const (
	DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics1MetricCpu    DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics1Metric = "cpu"
	DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics1MetricMemory DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics1Metric = "memory"
)

// Defines values for DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics1Summary.
const (
	DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics1SummaryAverage DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics1Summary = "average"
)

// Defines values for DeploymentsUpsertJSONBodyConfig01ApiVersion.
const (
	V0alpha1 DeploymentsUpsertJSONBodyConfig01ApiVersion = "v0alpha1"
)

// Defines values for DeploymentsUpsertJSONBodyConfig01Integrations0Type.
const (
	DeploymentsUpsertJSONBodyConfig01Integrations0TypeModel DeploymentsUpsertJSONBodyConfig01Integrations0Type = "model"
)

// Defines values for DeploymentsUpsertJSONBodyConfig01Integrations1Region0.
const (
	DeploymentsUpsertJSONBodyConfig01Integrations1Region0Ny2 DeploymentsUpsertJSONBodyConfig01Integrations1Region0 = "ny2"
)

// Defines values for DeploymentsUpsertJSONBodyConfig01Integrations1Region1.
const (
	DeploymentsUpsertJSONBodyConfig01Integrations1Region1Ca1 DeploymentsUpsertJSONBodyConfig01Integrations1Region1 = "ca1"
)

// Defines values for DeploymentsUpsertJSONBodyConfig01Integrations1Region2.
const (
	DeploymentsUpsertJSONBodyConfig01Integrations1Region2Ams1 DeploymentsUpsertJSONBodyConfig01Integrations1Region2 = "ams1"
)

// Defines values for DeploymentsUpsertJSONBodyConfig01Integrations1Type.
const (
	DeploymentsUpsertJSONBodyConfig01Integrations1TypeS3 DeploymentsUpsertJSONBodyConfig01Integrations1Type = "s3"
)

// Defines values for DeploymentsUpsertJSONBodyConfig01Integrations2Type.
const (
	DeploymentsUpsertJSONBodyConfig01Integrations2TypeSpaces DeploymentsUpsertJSONBodyConfig01Integrations2Type = "spaces"
)

// Defines values for DeploymentsUpsertJSONBodyConfig01Integrations3Type.
const (
	DeploymentsUpsertJSONBodyConfig01Integrations3TypeVolume DeploymentsUpsertJSONBodyConfig01Integrations3Type = "volume"
)

// Defines values for DeploymentsUpsertJSONBodyConfig01Integrations4Type.
const (
	DeploymentsUpsertJSONBodyConfig01Integrations4TypeGitLfs DeploymentsUpsertJSONBodyConfig01Integrations4Type = "git-lfs"
)

// Defines values for DeploymentsUpsertJSONBodyConfig01Region0.
const (
	DeploymentsUpsertJSONBodyConfig01Region0Ny2 DeploymentsUpsertJSONBodyConfig01Region0 = "ny2"
)

// Defines values for DeploymentsUpsertJSONBodyConfig01Region1.
const (
	DeploymentsUpsertJSONBodyConfig01Region1Ca1 DeploymentsUpsertJSONBodyConfig01Region1 = "ca1"
)

// Defines values for DeploymentsUpsertJSONBodyConfig01Region2.
const (
	DeploymentsUpsertJSONBodyConfig01Region2Ams1 DeploymentsUpsertJSONBodyConfig01Region2 = "ams1"
)

// Defines values for DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics0Metric.
const (
	DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics0MetricRequestDuration DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics0Metric = "requestDuration"
)

// Defines values for DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics0Summary.
const (
	DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics0SummaryAverage DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics0Summary = "average"
)

// Defines values for DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics1Metric.
const (
	DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics1MetricCpu    DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics1Metric = "cpu"
	DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics1MetricMemory DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics1Metric = "memory"
)

// Defines values for DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics1Summary.
const (
	DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics1SummaryAverage DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics1Summary = "average"
)

// Defines values for DeploymentsUpsertJSONBodyConfig1ApiVersion0.
const (
	V1 DeploymentsUpsertJSONBodyConfig1ApiVersion0 = "v1"
)

// Defines values for DeploymentsUpsertJSONBodyConfig1ApiVersion1.
const (
	Latest DeploymentsUpsertJSONBodyConfig1ApiVersion1 = "latest"
)

// Defines values for DeploymentsUpsertJSONBodyConfig1Integrations0Type.
const (
	DeploymentsUpsertJSONBodyConfig1Integrations0TypeModel DeploymentsUpsertJSONBodyConfig1Integrations0Type = "model"
)

// Defines values for DeploymentsUpsertJSONBodyConfig1Integrations1Region0.
const (
	DeploymentsUpsertJSONBodyConfig1Integrations1Region0Ny2 DeploymentsUpsertJSONBodyConfig1Integrations1Region0 = "ny2"
)

// Defines values for DeploymentsUpsertJSONBodyConfig1Integrations1Region1.
const (
	DeploymentsUpsertJSONBodyConfig1Integrations1Region1Ca1 DeploymentsUpsertJSONBodyConfig1Integrations1Region1 = "ca1"
)

// Defines values for DeploymentsUpsertJSONBodyConfig1Integrations1Region2.
const (
	DeploymentsUpsertJSONBodyConfig1Integrations1Region2Ams1 DeploymentsUpsertJSONBodyConfig1Integrations1Region2 = "ams1"
)

// Defines values for DeploymentsUpsertJSONBodyConfig1Integrations1Type.
const (
	DeploymentsUpsertJSONBodyConfig1Integrations1TypeS3 DeploymentsUpsertJSONBodyConfig1Integrations1Type = "s3"
)

// Defines values for DeploymentsUpsertJSONBodyConfig1Integrations2Type.
const (
	DeploymentsUpsertJSONBodyConfig1Integrations2TypeSpaces DeploymentsUpsertJSONBodyConfig1Integrations2Type = "spaces"
)

// Defines values for DeploymentsUpsertJSONBodyConfig1Integrations3Type.
const (
	DeploymentsUpsertJSONBodyConfig1Integrations3TypeVolume DeploymentsUpsertJSONBodyConfig1Integrations3Type = "volume"
)

// Defines values for DeploymentsUpsertJSONBodyConfig1Integrations4Type.
const (
	DeploymentsUpsertJSONBodyConfig1Integrations4TypeGitLfs DeploymentsUpsertJSONBodyConfig1Integrations4Type = "git-lfs"
)

// Defines values for DeploymentsUpsertJSONBodyConfig1Region0.
const (
	DeploymentsUpsertJSONBodyConfig1Region0Ny2 DeploymentsUpsertJSONBodyConfig1Region0 = "ny2"
)

// Defines values for DeploymentsUpsertJSONBodyConfig1Region1.
const (
	DeploymentsUpsertJSONBodyConfig1Region1Ca1 DeploymentsUpsertJSONBodyConfig1Region1 = "ca1"
)

// Defines values for DeploymentsUpsertJSONBodyConfig1Region2.
const (
	DeploymentsUpsertJSONBodyConfig1Region2Ams1 DeploymentsUpsertJSONBodyConfig1Region2 = "ams1"
)

// Defines values for DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics0Metric.
const (
	RequestDuration DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics0Metric = "requestDuration"
)

// Defines values for DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics0Summary.
const (
	DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics0SummaryAverage DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics0Summary = "average"
)

// Defines values for DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics1Metric.
const (
	DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics1MetricCpu    DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics1Metric = "cpu"
	DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics1MetricMemory DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics1Metric = "memory"
)

// Defines values for DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics1Summary.
const (
	DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics1SummaryAverage DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics1Summary = "average"
)

// Defines values for DeploymentHistoryListParamsOrderBy.
const (
	DeploymentHistoryListParamsOrderByDtCreated DeploymentHistoryListParamsOrderBy = "dtCreated"
)

// Defines values for DeploymentHistoryListParamsOrder.
const (
	DeploymentHistoryListParamsOrderAsc  DeploymentHistoryListParamsOrder = "asc"
	DeploymentHistoryListParamsOrderDesc DeploymentHistoryListParamsOrder = "desc"
)

// Defines values for DeploymentLogsListParamsOrderBy.
const (
	DeploymentLogsListParamsOrderByDtCreated DeploymentLogsListParamsOrderBy = "dtCreated"
)

// Defines values for DeploymentLogsListParamsOrder.
const (
	DeploymentLogsListParamsOrderAsc  DeploymentLogsListParamsOrder = "asc"
	DeploymentLogsListParamsOrderDesc DeploymentLogsListParamsOrder = "desc"
)

// Defines values for DeploymentMetricsGetParamsMetric0.
const (
	RequestsTotal DeploymentMetricsGetParamsMetric0 = "requests_total"
)

// Defines values for DeploymentMetricsGetParamsMetric1.
const (
	DeploymentMetricsGetParamsMetric1Cpu DeploymentMetricsGetParamsMetric1 = "cpu"
)

// Defines values for DeploymentMetricsGetParamsMetric2.
const (
	Memory DeploymentMetricsGetParamsMetric2 = "memory"
)

// Defines values for DeploymentMetricsGetParamsMetric3.
const (
	Gpu DeploymentMetricsGetParamsMetric3 = "gpu"
)

// Defines values for DeploymentMetricsGetParamsMetric4.
const (
	RequestsPerSecond DeploymentMetricsGetParamsMetric4 = "requests_per_second"
)

// Defines values for DeploymentMetricsGetParamsMetric5.
const (
	RequestsDurationSeconds1m DeploymentMetricsGetParamsMetric5 = "requests_duration_seconds_1m"
)

// Defines values for DeploymentMetricsGetParamsMetric6.
const (
	RequestsDurationSeconds5m DeploymentMetricsGetParamsMetric6 = "requests_duration_seconds_5m"
)

// Defines values for DeploymentMetricsGetParamsTimeframe.
const (
	Day      DeploymentMetricsGetParamsTimeframe = "day"
	Hour     DeploymentMetricsGetParamsTimeframe = "hour"
	N12Hours DeploymentMetricsGetParamsTimeframe = "12_hours"
	N1Week   DeploymentMetricsGetParamsTimeframe = "1_week"
	N2Weeks  DeploymentMetricsGetParamsTimeframe = "2_weeks"
)

// Defines values for MachineAvailabilityListParamsRegion0.
const (
	MachineAvailabilityListParamsRegion0Ny2 MachineAvailabilityListParamsRegion0 = "ny2"
)

// Defines values for MachineAvailabilityListParamsRegion1.
const (
	MachineAvailabilityListParamsRegion1Ca1 MachineAvailabilityListParamsRegion1 = "ca1"
)

// Defines values for MachineAvailabilityListParamsRegion2.
const (
	MachineAvailabilityListParamsRegion2Ams1 MachineAvailabilityListParamsRegion2 = "ams1"
)

// Defines values for MachineEventsListParamsOrderBy.
const (
	MachineEventsListParamsOrderByDtCreated MachineEventsListParamsOrderBy = "dtCreated"
)

// Defines values for MachineEventsListParamsOrder.
const (
	MachineEventsListParamsOrderAsc  MachineEventsListParamsOrder = "asc"
	MachineEventsListParamsOrderDesc MachineEventsListParamsOrder = "desc"
)

// Defines values for MachinesListParamsOrderBy.
const (
	MachinesListParamsOrderByDtCreated MachinesListParamsOrderBy = "dtCreated"
	MachinesListParamsOrderByName      MachinesListParamsOrderBy = "name"
	MachinesListParamsOrderByState     MachinesListParamsOrderBy = "state"
)

// Defines values for MachinesListParamsOrder.
const (
	MachinesListParamsOrderAsc  MachinesListParamsOrder = "asc"
	MachinesListParamsOrderDesc MachinesListParamsOrder = "desc"
)

// Defines values for MachinesListParamsRegion0.
const (
	MachinesListParamsRegion0Ny2 MachinesListParamsRegion0 = "ny2"
)

// Defines values for MachinesListParamsRegion1.
const (
	MachinesListParamsRegion1Ca1 MachinesListParamsRegion1 = "ca1"
)

// Defines values for MachinesListParamsRegion2.
const (
	MachinesListParamsRegion2Ams1 MachinesListParamsRegion2 = "ams1"
)

// Defines values for MachinesCreateJSONBodyAutoSnapshotFrequency.
const (
	MachinesCreateJSONBodyAutoSnapshotFrequencyDaily   MachinesCreateJSONBodyAutoSnapshotFrequency = "daily"
	MachinesCreateJSONBodyAutoSnapshotFrequencyHourly  MachinesCreateJSONBodyAutoSnapshotFrequency = "hourly"
	MachinesCreateJSONBodyAutoSnapshotFrequencyMonthly MachinesCreateJSONBodyAutoSnapshotFrequency = "monthly"
	MachinesCreateJSONBodyAutoSnapshotFrequencyWeekly  MachinesCreateJSONBodyAutoSnapshotFrequency = "weekly"
)

// Defines values for MachinesCreateJSONBodyDiskSize0.
const (
	MachinesCreateJSONBodyDiskSize0N50 MachinesCreateJSONBodyDiskSize0 = 50
)

// Defines values for MachinesCreateJSONBodyDiskSize1.
const (
	MachinesCreateJSONBodyDiskSize1N100 MachinesCreateJSONBodyDiskSize1 = 100
)

// Defines values for MachinesCreateJSONBodyDiskSize2.
const (
	MachinesCreateJSONBodyDiskSize2N250 MachinesCreateJSONBodyDiskSize2 = 250
)

// Defines values for MachinesCreateJSONBodyDiskSize3.
const (
	MachinesCreateJSONBodyDiskSize3N500 MachinesCreateJSONBodyDiskSize3 = 500
)

// Defines values for MachinesCreateJSONBodyDiskSize4.
const (
	MachinesCreateJSONBodyDiskSize4N1000 MachinesCreateJSONBodyDiskSize4 = 1000
)

// Defines values for MachinesCreateJSONBodyDiskSize5.
const (
	MachinesCreateJSONBodyDiskSize5N2000 MachinesCreateJSONBodyDiskSize5 = 2000
)

// Defines values for MachinesCreateJSONBodyDiskSize6.
const (
	MachinesCreateJSONBodyDiskSize6N4000 MachinesCreateJSONBodyDiskSize6 = 4000
)

// Defines values for MachinesCreateJSONBodyDiskSize7.
const (
	MachinesCreateJSONBodyDiskSize7N8000 MachinesCreateJSONBodyDiskSize7 = 8000
)

// Defines values for MachinesCreateJSONBodyDiskSize8.
const (
	MachinesCreateJSONBodyDiskSize8N12000 MachinesCreateJSONBodyDiskSize8 = 12000
)

// Defines values for MachinesCreateJSONBodyDiskSize9.
const (
	MachinesCreateJSONBodyDiskSize9N16000 MachinesCreateJSONBodyDiskSize9 = 16000
)

// Defines values for MachinesCreateJSONBodyPublicIpType.
const (
	MachinesCreateJSONBodyPublicIpTypeDynamic MachinesCreateJSONBodyPublicIpType = "dynamic"
	MachinesCreateJSONBodyPublicIpTypeNone    MachinesCreateJSONBodyPublicIpType = "none"
	MachinesCreateJSONBodyPublicIpTypeStatic  MachinesCreateJSONBodyPublicIpType = "static"
)

// Defines values for MachinesCreateJSONBodyRegion0.
const (
	MachinesCreateJSONBodyRegion0Ny2 MachinesCreateJSONBodyRegion0 = "ny2"
)

// Defines values for MachinesCreateJSONBodyRegion1.
const (
	MachinesCreateJSONBodyRegion1Ca1 MachinesCreateJSONBodyRegion1 = "ca1"
)

// Defines values for MachinesCreateJSONBodyRegion2.
const (
	MachinesCreateJSONBodyRegion2Ams1 MachinesCreateJSONBodyRegion2 = "ams1"
)

// Defines values for MachinesCreateJSONBodyRestorePointFrequency.
const (
	MachinesCreateJSONBodyRestorePointFrequencyShutdown MachinesCreateJSONBodyRestorePointFrequency = "shutdown"
)

// Defines values for MachinesUpdateJSONBodyAutoSnapshotFrequency.
const (
	MachinesUpdateJSONBodyAutoSnapshotFrequencyDaily   MachinesUpdateJSONBodyAutoSnapshotFrequency = "daily"
	MachinesUpdateJSONBodyAutoSnapshotFrequencyHourly  MachinesUpdateJSONBodyAutoSnapshotFrequency = "hourly"
	MachinesUpdateJSONBodyAutoSnapshotFrequencyMonthly MachinesUpdateJSONBodyAutoSnapshotFrequency = "monthly"
	MachinesUpdateJSONBodyAutoSnapshotFrequencyWeekly  MachinesUpdateJSONBodyAutoSnapshotFrequency = "weekly"
)

// Defines values for MachinesUpdateJSONBodyDiskSize0.
const (
	MachinesUpdateJSONBodyDiskSize0N50 MachinesUpdateJSONBodyDiskSize0 = 50
)

// Defines values for MachinesUpdateJSONBodyDiskSize1.
const (
	MachinesUpdateJSONBodyDiskSize1N100 MachinesUpdateJSONBodyDiskSize1 = 100
)

// Defines values for MachinesUpdateJSONBodyDiskSize2.
const (
	MachinesUpdateJSONBodyDiskSize2N250 MachinesUpdateJSONBodyDiskSize2 = 250
)

// Defines values for MachinesUpdateJSONBodyDiskSize3.
const (
	MachinesUpdateJSONBodyDiskSize3N500 MachinesUpdateJSONBodyDiskSize3 = 500
)

// Defines values for MachinesUpdateJSONBodyDiskSize4.
const (
	MachinesUpdateJSONBodyDiskSize4N1000 MachinesUpdateJSONBodyDiskSize4 = 1000
)

// Defines values for MachinesUpdateJSONBodyDiskSize5.
const (
	MachinesUpdateJSONBodyDiskSize5N2000 MachinesUpdateJSONBodyDiskSize5 = 2000
)

// Defines values for MachinesUpdateJSONBodyDiskSize6.
const (
	MachinesUpdateJSONBodyDiskSize6N4000 MachinesUpdateJSONBodyDiskSize6 = 4000
)

// Defines values for MachinesUpdateJSONBodyDiskSize7.
const (
	MachinesUpdateJSONBodyDiskSize7N8000 MachinesUpdateJSONBodyDiskSize7 = 8000
)

// Defines values for MachinesUpdateJSONBodyDiskSize8.
const (
	MachinesUpdateJSONBodyDiskSize8N12000 MachinesUpdateJSONBodyDiskSize8 = 12000
)

// Defines values for MachinesUpdateJSONBodyDiskSize9.
const (
	MachinesUpdateJSONBodyDiskSize9N16000 MachinesUpdateJSONBodyDiskSize9 = 16000
)

// Defines values for MachinesUpdateJSONBodyPublicIpType.
const (
	MachinesUpdateJSONBodyPublicIpTypeDynamic MachinesUpdateJSONBodyPublicIpType = "dynamic"
	MachinesUpdateJSONBodyPublicIpTypeNone    MachinesUpdateJSONBodyPublicIpType = "none"
	MachinesUpdateJSONBodyPublicIpTypeStatic  MachinesUpdateJSONBodyPublicIpType = "static"
)

// Defines values for MachinesUpdateJSONBodyRestorePointFrequency.
const (
	MachinesUpdateJSONBodyRestorePointFrequencyShutdown MachinesUpdateJSONBodyRestorePointFrequency = "shutdown"
)

// Defines values for MachinesListAccessorsParamsOrderBy.
const (
	Id MachinesListAccessorsParamsOrderBy = "id"
)

// Defines values for MachinesListAccessorsParamsOrder.
const (
	MachinesListAccessorsParamsOrderAsc  MachinesListAccessorsParamsOrder = "asc"
	MachinesListAccessorsParamsOrderDesc MachinesListAccessorsParamsOrder = "desc"
)

// Defines values for ModelsListParamsOrderBy.
const (
	ModelsListParamsOrderByDtCreated ModelsListParamsOrderBy = "dtCreated"
)

// Defines values for ModelsListParamsOrder.
const (
	ModelsListParamsOrderAsc  ModelsListParamsOrder = "asc"
	ModelsListParamsOrderDesc ModelsListParamsOrder = "desc"
)

// Defines values for OsTemplatesListParamsOrderBy.
const (
	OsTemplatesListParamsOrderByName OsTemplatesListParamsOrderBy = "name"
)

// Defines values for OsTemplatesListParamsOrder.
const (
	OsTemplatesListParamsOrderAsc  OsTemplatesListParamsOrder = "asc"
	OsTemplatesListParamsOrderDesc OsTemplatesListParamsOrder = "desc"
)

// Defines values for PrivateNetworksListParamsOrderBy.
const (
	PrivateNetworksListParamsOrderByDtCreated PrivateNetworksListParamsOrderBy = "dtCreated"
	PrivateNetworksListParamsOrderByName      PrivateNetworksListParamsOrderBy = "name"
)

// Defines values for PrivateNetworksListParamsOrder.
const (
	PrivateNetworksListParamsOrderAsc  PrivateNetworksListParamsOrder = "asc"
	PrivateNetworksListParamsOrderDesc PrivateNetworksListParamsOrder = "desc"
)

// Defines values for PrivateNetworksListParamsRegion0.
const (
	PrivateNetworksListParamsRegion0Ny2 PrivateNetworksListParamsRegion0 = "ny2"
)

// Defines values for PrivateNetworksListParamsRegion1.
const (
	PrivateNetworksListParamsRegion1Ca1 PrivateNetworksListParamsRegion1 = "ca1"
)

// Defines values for PrivateNetworksListParamsRegion2.
const (
	PrivateNetworksListParamsRegion2Ams1 PrivateNetworksListParamsRegion2 = "ams1"
)

// Defines values for PrivateNetworksCreateJSONBodyRegion0.
const (
	PrivateNetworksCreateJSONBodyRegion0Ny2 PrivateNetworksCreateJSONBodyRegion0 = "ny2"
)

// Defines values for PrivateNetworksCreateJSONBodyRegion1.
const (
	PrivateNetworksCreateJSONBodyRegion1Ca1 PrivateNetworksCreateJSONBodyRegion1 = "ca1"
)

// Defines values for PrivateNetworksCreateJSONBodyRegion2.
const (
	PrivateNetworksCreateJSONBodyRegion2Ams1 PrivateNetworksCreateJSONBodyRegion2 = "ams1"
)

// Defines values for ProjectsListParamsOrderBy.
const (
	ProjectsListParamsOrderByDtCreated ProjectsListParamsOrderBy = "dtCreated"
)

// Defines values for ProjectsListParamsOrder.
const (
	ProjectsListParamsOrderAsc  ProjectsListParamsOrder = "asc"
	ProjectsListParamsOrderDesc ProjectsListParamsOrder = "desc"
)

// Defines values for ProjectActivityListParamsOrderBy.
const (
	ProjectActivityListParamsOrderByDtCreated ProjectActivityListParamsOrderBy = "dtCreated"
)

// Defines values for ProjectActivityListParamsOrder.
const (
	ProjectActivityListParamsOrderAsc  ProjectActivityListParamsOrder = "asc"
	ProjectActivityListParamsOrderDesc ProjectActivityListParamsOrder = "desc"
)

// Defines values for ProjectCollaboratorsListParamsOrderBy.
const (
	ProjectCollaboratorsListParamsOrderByDtCreated ProjectCollaboratorsListParamsOrderBy = "dtCreated"
)

// Defines values for ProjectCollaboratorsListParamsOrder.
const (
	ProjectCollaboratorsListParamsOrderAsc  ProjectCollaboratorsListParamsOrder = "asc"
	ProjectCollaboratorsListParamsOrderDesc ProjectCollaboratorsListParamsOrder = "desc"
)

// Defines values for ProjectDeploymentsListParamsOrderBy.
const (
	ProjectDeploymentsListParamsOrderByDtCreated ProjectDeploymentsListParamsOrderBy = "dtCreated"
)

// Defines values for ProjectDeploymentsListParamsOrder.
const (
	ProjectDeploymentsListParamsOrderAsc  ProjectDeploymentsListParamsOrder = "asc"
	ProjectDeploymentsListParamsOrderDesc ProjectDeploymentsListParamsOrder = "desc"
)

// Defines values for ProjectModelsListParamsOrderBy.
const (
	ProjectModelsListParamsOrderByDtCreated ProjectModelsListParamsOrderBy = "dtCreated"
)

// Defines values for ProjectModelsListParamsOrder.
const (
	ProjectModelsListParamsOrderAsc  ProjectModelsListParamsOrder = "asc"
	ProjectModelsListParamsOrderDesc ProjectModelsListParamsOrder = "desc"
)

// Defines values for ProjectSecretsListParamsOrderBy.
const (
	ProjectSecretsListParamsOrderByDtCreated ProjectSecretsListParamsOrderBy = "dtCreated"
)

// Defines values for ProjectSecretsListParamsOrder.
const (
	ProjectSecretsListParamsOrderAsc  ProjectSecretsListParamsOrder = "asc"
	ProjectSecretsListParamsOrderDesc ProjectSecretsListParamsOrder = "desc"
)

// Defines values for ProjectTagsListParamsOrderBy.
const (
	ProjectTagsListParamsOrderByDtCreated ProjectTagsListParamsOrderBy = "dtCreated"
)

// Defines values for ProjectTagsListParamsOrder.
const (
	ProjectTagsListParamsOrderAsc  ProjectTagsListParamsOrder = "asc"
	ProjectTagsListParamsOrderDesc ProjectTagsListParamsOrder = "desc"
)

// Defines values for PublicIpsListParamsOrderBy.
const (
	PublicIpsListParamsOrderByDtCreated PublicIpsListParamsOrderBy = "dtCreated"
)

// Defines values for PublicIpsListParamsOrder.
const (
	PublicIpsListParamsOrderAsc  PublicIpsListParamsOrder = "asc"
	PublicIpsListParamsOrderDesc PublicIpsListParamsOrder = "desc"
)

// Defines values for PublicIpsListParamsRegion0.
const (
	PublicIpsListParamsRegion0Ny2 PublicIpsListParamsRegion0 = "ny2"
)

// Defines values for PublicIpsListParamsRegion1.
const (
	PublicIpsListParamsRegion1Ca1 PublicIpsListParamsRegion1 = "ca1"
)

// Defines values for PublicIpsListParamsRegion2.
const (
	PublicIpsListParamsRegion2Ams1 PublicIpsListParamsRegion2 = "ams1"
)

// Defines values for PublicIpsClaimJSONBodyRegion0.
const (
	PublicIpsClaimJSONBodyRegion0Ny2 PublicIpsClaimJSONBodyRegion0 = "ny2"
)

// Defines values for PublicIpsClaimJSONBodyRegion1.
const (
	PublicIpsClaimJSONBodyRegion1Ca1 PublicIpsClaimJSONBodyRegion1 = "ca1"
)

// Defines values for PublicIpsClaimJSONBodyRegion2.
const (
	PublicIpsClaimJSONBodyRegion2Ams1 PublicIpsClaimJSONBodyRegion2 = "ams1"
)

// Defines values for SharedDrivesListParamsOrderBy.
const (
	SharedDrivesListParamsOrderByDtCreated SharedDrivesListParamsOrderBy = "dtCreated"
	SharedDrivesListParamsOrderByName      SharedDrivesListParamsOrderBy = "name"
)

// Defines values for SharedDrivesListParamsOrder.
const (
	SharedDrivesListParamsOrderAsc  SharedDrivesListParamsOrder = "asc"
	SharedDrivesListParamsOrderDesc SharedDrivesListParamsOrder = "desc"
)

// Defines values for SharedDrivesCreateJSONBodySize0.
const (
	N50 SharedDrivesCreateJSONBodySize0 = 50
)

// Defines values for SharedDrivesCreateJSONBodySize1.
const (
	N100 SharedDrivesCreateJSONBodySize1 = 100
)

// Defines values for SharedDrivesCreateJSONBodySize2.
const (
	N250 SharedDrivesCreateJSONBodySize2 = 250
)

// Defines values for SharedDrivesCreateJSONBodySize3.
const (
	N500 SharedDrivesCreateJSONBodySize3 = 500
)

// Defines values for SharedDrivesCreateJSONBodySize4.
const (
	N1000 SharedDrivesCreateJSONBodySize4 = 1000
)

// Defines values for SharedDrivesCreateJSONBodySize5.
const (
	N2000 SharedDrivesCreateJSONBodySize5 = 2000
)

// Defines values for SharedDrivesCreateJSONBodySize6.
const (
	N4000 SharedDrivesCreateJSONBodySize6 = 4000
)

// Defines values for SharedDrivesCreateJSONBodySize7.
const (
	N8000 SharedDrivesCreateJSONBodySize7 = 8000
)

// Defines values for SharedDrivesCreateJSONBodySize8.
const (
	N12000 SharedDrivesCreateJSONBodySize8 = 12000
)

// Defines values for SharedDrivesCreateJSONBodySize9.
const (
	N16000 SharedDrivesCreateJSONBodySize9 = 16000
)

// Defines values for SnapshotsListParamsOrderBy.
const (
	SnapshotsListParamsOrderByDtCreated SnapshotsListParamsOrderBy = "dtCreated"
	SnapshotsListParamsOrderByName      SnapshotsListParamsOrderBy = "name"
)

// Defines values for SnapshotsListParamsOrder.
const (
	SnapshotsListParamsOrderAsc  SnapshotsListParamsOrder = "asc"
	SnapshotsListParamsOrderDesc SnapshotsListParamsOrder = "desc"
)

// Defines values for StartupScriptsListParamsOrderBy.
const (
	StartupScriptsListParamsOrderByDtCreated StartupScriptsListParamsOrderBy = "dtCreated"
	StartupScriptsListParamsOrderByName      StartupScriptsListParamsOrderBy = "name"
)

// Defines values for StartupScriptsListParamsOrder.
const (
	StartupScriptsListParamsOrderAsc  StartupScriptsListParamsOrder = "asc"
	StartupScriptsListParamsOrderDesc StartupScriptsListParamsOrder = "desc"
)

// Defines values for StorageProvidersListParamsOrderBy.
const (
	StorageProvidersListParamsOrderByDtCreated StorageProvidersListParamsOrderBy = "dtCreated"
)

// Defines values for StorageProvidersListParamsOrder.
const (
	StorageProvidersListParamsOrderAsc  StorageProvidersListParamsOrder = "asc"
	StorageProvidersListParamsOrderDesc StorageProvidersListParamsOrder = "desc"
)

// Defines values for StorageProvidersCreateJSONBodyS3ConfigRegion0.
const (
	StorageProvidersCreateJSONBodyS3ConfigRegion0Ny2 StorageProvidersCreateJSONBodyS3ConfigRegion0 = "ny2"
)

// Defines values for StorageProvidersCreateJSONBodyS3ConfigRegion1.
const (
	StorageProvidersCreateJSONBodyS3ConfigRegion1Ca1 StorageProvidersCreateJSONBodyS3ConfigRegion1 = "ca1"
)

// Defines values for StorageProvidersCreateJSONBodyS3ConfigRegion2.
const (
	StorageProvidersCreateJSONBodyS3ConfigRegion2Ams1 StorageProvidersCreateJSONBodyS3ConfigRegion2 = "ams1"
)

// Defines values for StorageProvidersCreateJSONBodyStorageProviderType.
const (
	S3 StorageProvidersCreateJSONBodyStorageProviderType = "s3"
)

// Defines values for StorageProvidersUpdateJSONBodyS3ConfigRegion0.
const (
	StorageProvidersUpdateJSONBodyS3ConfigRegion0Ny2 StorageProvidersUpdateJSONBodyS3ConfigRegion0 = "ny2"
)

// Defines values for StorageProvidersUpdateJSONBodyS3ConfigRegion1.
const (
	StorageProvidersUpdateJSONBodyS3ConfigRegion1Ca1 StorageProvidersUpdateJSONBodyS3ConfigRegion1 = "ca1"
)

// Defines values for StorageProvidersUpdateJSONBodyS3ConfigRegion2.
const (
	StorageProvidersUpdateJSONBodyS3ConfigRegion2Ams1 StorageProvidersUpdateJSONBodyS3ConfigRegion2 = "ams1"
)

// Defines values for TeamSecretsListParamsOrderBy.
const (
	DtCreated TeamSecretsListParamsOrderBy = "dtCreated"
)

// Defines values for TeamSecretsListParamsOrder.
const (
	TeamSecretsListParamsOrderAsc  TeamSecretsListParamsOrder = "asc"
	TeamSecretsListParamsOrderDesc TeamSecretsListParamsOrder = "desc"
)

// Defines values for TeamMembershipsListByTeamIdParamsOrderBy.
const (
	DtConfirmed TeamMembershipsListByTeamIdParamsOrderBy = "dtConfirmed"
)

// Defines values for TeamMembershipsListByTeamIdParamsOrder.
const (
	Asc  TeamMembershipsListByTeamIdParamsOrder = "asc"
	Desc TeamMembershipsListByTeamIdParamsOrder = "desc"
)

// Defines values for TeamMembershipsListByTeamIdParamsRole.
const (
	Admin  TeamMembershipsListByTeamIdParamsRole = "admin"
	Member TeamMembershipsListByTeamIdParamsRole = "member"
	Owner  TeamMembershipsListByTeamIdParamsRole = "owner"
)

// Error defines model for error.
type Error struct {
	Code    string                  `json:"code"`
	Details *map[string]interface{} `json:"details,omitempty"`
	Message string                  `json:"message"`
}

// ContainerRegistriesListParams defines parameters for ContainerRegistriesList.
type ContainerRegistriesListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *ContainerRegistriesListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *ContainerRegistriesListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// ContainerRegistriesListParamsOrderBy defines parameters for ContainerRegistriesList.
type ContainerRegistriesListParamsOrderBy string

// ContainerRegistriesListParamsOrder defines parameters for ContainerRegistriesList.
type ContainerRegistriesListParamsOrder string

// ContainerRegistriesCreateJSONBody defines parameters for ContainerRegistriesCreate.
type ContainerRegistriesCreateJSONBody struct {
	// Kind The kind of provider the registry is. If provided, the registry will be validated against the provider's rules.
	Kind *ContainerRegistriesCreateJSONBodyKind `json:"kind,omitempty"`

	// Name The name of the container registry.
	Name string `json:"name"`

	// Namespace The namespace of the container registry. See https://docs.digitalocean.com/products/container-registry/.
	Namespace string `json:"namespace"`

	// Password The password for the registry. See https://docs.digitalocean.com/products/container-registry/.
	Password string `json:"password"`

	// Url The URL of the container registry. See https://docs.digitalocean.com/products/container-registry/.
	Url string `json:"url"`

	// Username A username for the container registry. See https://docs.digitalocean.com/products/container-registry/.
	Username string `json:"username"`
}

// ContainerRegistriesCreateJSONBodyKind defines parameters for ContainerRegistriesCreate.
type ContainerRegistriesCreateJSONBodyKind string

// ContainerRegistriesUpdateJSONBody defines parameters for ContainerRegistriesUpdate.
type ContainerRegistriesUpdateJSONBody struct {
	// Kind The kind of provider the registry is. If provided, the registry will be validated against the provider's rules.
	Kind *ContainerRegistriesUpdateJSONBodyKind `json:"kind,omitempty"`

	// Name The name of the container registry.
	Name *string `json:"name,omitempty"`

	// Namespace The namespace of the container registry. See https://docs.digitalocean.com/products/container-registry/.
	Namespace *string `json:"namespace,omitempty"`

	// Password An updated password for the registry. See https://docs.digitalocean.com/products/container-registry/.
	Password *string `json:"password,omitempty"`

	// Url The URL of the container registry. See https://docs.digitalocean.com/products/container-registry/.
	Url *string `json:"url,omitempty"`

	// Username A username for the container registry. See https://docs.digitalocean.com/products/container-registry/.
	Username *string `json:"username,omitempty"`
}

// ContainerRegistriesUpdateJSONBodyKind defines parameters for ContainerRegistriesUpdate.
type ContainerRegistriesUpdateJSONBodyKind string

// CustomTemplatesListParams defines parameters for CustomTemplatesList.
type CustomTemplatesListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *CustomTemplatesListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order     *CustomTemplatesListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
	Name      *string                         `form:"name,omitempty" json:"name,omitempty"`
	MachineId *string                         `form:"machineId,omitempty" json:"machineId,omitempty"`
}

// CustomTemplatesListParamsOrderBy defines parameters for CustomTemplatesList.
type CustomTemplatesListParamsOrderBy string

// CustomTemplatesListParamsOrder defines parameters for CustomTemplatesList.
type CustomTemplatesListParamsOrder string

// CustomTemplatesCreateJSONBody defines parameters for CustomTemplatesCreate.
type CustomTemplatesCreateJSONBody struct {
	// MachineId The ID of the machine to create a template from.
	MachineId string `json:"machineId"`

	// Name The name of the template.
	Name string `json:"name"`
}

// CustomTemplatesUpdateJSONBody defines parameters for CustomTemplatesUpdate.
type CustomTemplatesUpdateJSONBody struct {
	// Name The name of the template.
	Name string `json:"name"`
}

// DatasetsListParams defines parameters for DatasetsList.
type DatasetsListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *DatasetsListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order   *DatasetsListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
	TeamId  *string                  `form:"teamId,omitempty" json:"teamId,omitempty"`
	Privacy *struct {
		union json.RawMessage
	} `form:"privacy,omitempty" json:"privacy,omitempty"`
}

// DatasetsListParamsOrderBy defines parameters for DatasetsList.
type DatasetsListParamsOrderBy string

// DatasetsListParamsOrder defines parameters for DatasetsList.
type DatasetsListParamsOrder string

// DatasetsListParamsPrivacy0 defines parameters for DatasetsList.
type DatasetsListParamsPrivacy0 = interface{}

// DatasetsListParamsPrivacy1 defines parameters for DatasetsList.
type DatasetsListParamsPrivacy1 string

// DatasetsCreateJSONBody defines parameters for DatasetsCreate.
type DatasetsCreateJSONBody struct {
	// Description The description of the dataset
	Description *DatasetsCreateJSONBody_Description `json:"description"`

	// IsPublic Whether the dataset is public
	IsPublic bool `json:"isPublic"`

	// Name The name of the dataset
	Name string `json:"name"`

	// StorageProviderId The ID of the storage provider
	StorageProviderId *string `json:"storageProviderId,omitempty"`
}

// DatasetsCreateJSONBodyDescription0 defines parameters for DatasetsCreate.
type DatasetsCreateJSONBodyDescription0 = interface{}

// DatasetsCreateJSONBodyDescription1 defines parameters for DatasetsCreate.
type DatasetsCreateJSONBodyDescription1 = string

// DatasetsCreateJSONBody_Description defines parameters for DatasetsCreate.
type DatasetsCreateJSONBody_Description struct {
	union json.RawMessage
}

// DatasetVersionsListParams defines parameters for DatasetVersionsList.
type DatasetVersionsListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *DatasetVersionsListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *DatasetVersionsListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
	Tags  *string                         `form:"tags,omitempty" json:"tags,omitempty"`
}

// DatasetVersionsListParamsOrderBy defines parameters for DatasetVersionsList.
type DatasetVersionsListParamsOrderBy string

// DatasetVersionsListParamsOrder defines parameters for DatasetVersionsList.
type DatasetVersionsListParamsOrder string

// DatasetVersionsCreateJSONBody defines parameters for DatasetVersionsCreate.
type DatasetVersionsCreateJSONBody struct {
	// Message The description of the dataset version
	Message *string `json:"message,omitempty"`

	// Metadata Metadata for the version.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Tags The tags for the version, comma-delimited
	Tags *string `json:"tags,omitempty"`
}

// DatasetVersionsUpdateJSONBody defines parameters for DatasetVersionsUpdate.
type DatasetVersionsUpdateJSONBody struct {
	// IsCommitted Whether the version is committed
	IsCommitted *bool `json:"isCommitted,omitempty"`

	// Message The description of the dataset version
	Message *string `json:"message,omitempty"`

	// Metadata Metadata for the version.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Tags The tags for the version, comma-delimited
	Tags *string `json:"tags,omitempty"`
}

// DatasetsUpdateJSONBody defines parameters for DatasetsUpdate.
type DatasetsUpdateJSONBody struct {
	// Description The description of the dataset
	Description *DatasetsUpdateJSONBody_Description `json:"description"`

	// Name The name of the dataset
	Name *string `json:"name,omitempty"`
}

// DatasetsUpdateJSONBodyDescription0 defines parameters for DatasetsUpdate.
type DatasetsUpdateJSONBodyDescription0 = interface{}

// DatasetsUpdateJSONBodyDescription1 defines parameters for DatasetsUpdate.
type DatasetsUpdateJSONBodyDescription1 = string

// DatasetsUpdateJSONBody_Description defines parameters for DatasetsUpdate.
type DatasetsUpdateJSONBody_Description struct {
	union json.RawMessage
}

// DeploymentsListParams defines parameters for DeploymentsList.
type DeploymentsListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *DeploymentsListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *DeploymentsListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// DeploymentsListParamsOrderBy defines parameters for DeploymentsList.
type DeploymentsListParamsOrderBy string

// DeploymentsListParamsOrder defines parameters for DeploymentsList.
type DeploymentsListParamsOrder string

// DeploymentsUpsertJSONBody defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody struct {
	// Config The deployment configuration
	Config DeploymentsUpsertJSONBody_Config `json:"config"`

	// DeploymentId The ID of the deployment to update.
	DeploymentId *string `json:"deploymentId"`

	// ProjectId The project ID to deploy resources under.
	ProjectId string `json:"projectId"`
}

// DeploymentsUpsertJSONBodyConfig0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig0 struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig00 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00 struct {
	ApiVersion        DeploymentsUpsertJSONBodyConfig00ApiVersion `json:"apiVersion"`
	Command           *[]string                                   `json:"command,omitempty"`
	ContainerRegistry *string                                     `json:"containerRegistry,omitempty"`
	Enabled           *bool                                       `json:"enabled,omitempty"`
	Env               *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"env,omitempty"`
	HealthChecks *struct {
		Liveness  *DeploymentsUpsertJSONBody_Config_0_0_HealthChecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentsUpsertJSONBody_Config_0_0_HealthChecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentsUpsertJSONBody_Config_0_0_HealthChecks_Startup   `json:"startup,omitempty"`
	} `json:"healthChecks,omitempty"`
	Image  string `json:"image"`
	Models *[]struct {
		Id   string  `json:"id"`
		Path *string `json:"path,omitempty"`
	} `json:"models,omitempty"`
	Name         string                                       `json:"name"`
	Port         *float32                                     `json:"port,omitempty"`
	Region       *DeploymentsUpsertJSONBody_Config_0_0_Region `json:"region,omitempty"`
	Repositories *struct {
		Dataset      string  `json:"dataset"`
		MountPath    *string `json:"mountPath,omitempty"`
		Repositories []struct {
			Name     string  `json:"name"`
			Password *string `json:"password,omitempty"`
			Ref      *string `json:"ref,omitempty"`
			Url      string  `json:"url"`
			Username *string `json:"username,omitempty"`
		} `json:"repositories"`
	} `json:"repositories,omitempty"`
	Resources struct {
		Autoscaling *struct {
			Enabled     *bool                                                                     `json:"enabled,omitempty"`
			MaxReplicas float32                                                                   `json:"maxReplicas"`
			Metrics     []DeploymentsUpsertJSONBody_Config_0_0_Resources_Autoscaling_Metrics_Item `json:"metrics"`
		} `json:"autoscaling,omitempty"`
		InstanceType string   `json:"instanceType"`
		Replicas     *float32 `json:"replicas,omitempty"`
	} `json:"resources"`
}

// DeploymentsUpsertJSONBodyConfig00ApiVersion defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00ApiVersion string

// DeploymentsUpsertJSONBodyConfig00HealthChecksLiveness0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00HealthChecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBodyConfig00HealthChecksLiveness1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00HealthChecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBody_Config_0_0_HealthChecks_Liveness defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_0_0_HealthChecks_Liveness struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig00HealthChecksReadiness0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00HealthChecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBodyConfig00HealthChecksReadiness1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00HealthChecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBody_Config_0_0_HealthChecks_Readiness defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_0_0_HealthChecks_Readiness struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig00HealthChecksStartup0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00HealthChecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBodyConfig00HealthChecksStartup1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00HealthChecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBody_Config_0_0_HealthChecks_Startup defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_0_0_HealthChecks_Startup struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig00Region0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00Region0 string

// DeploymentsUpsertJSONBodyConfig00Region1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00Region1 string

// DeploymentsUpsertJSONBodyConfig00Region2 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00Region2 string

// DeploymentsUpsertJSONBodyConfig00Region3 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00Region3 = string

// DeploymentsUpsertJSONBody_Config_0_0_Region defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_0_0_Region struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics0 struct {
	Metric  DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics0Metric  `json:"metric"`
	Summary DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics0Summary `json:"summary"`
	Value   float32                                                              `json:"value"`
}

// DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics0Metric defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics0Metric string

// DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics0Summary defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics0Summary string

// DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics1 struct {
	Metric  DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics1Metric  `json:"metric"`
	Summary DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics1Summary `json:"summary"`
	Value   int                                                                  `json:"value"`
}

// DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics1Metric defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics1Metric string

// DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics1Summary defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig00ResourcesAutoscalingMetrics1Summary string

// DeploymentsUpsertJSONBody_Config_0_0_Resources_Autoscaling_Metrics_Item defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_0_0_Resources_Autoscaling_Metrics_Item struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig01 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01 struct {
	ApiVersion        DeploymentsUpsertJSONBodyConfig01ApiVersion `json:"apiVersion"`
	BasicAuthKey      *string                                     `json:"basicAuthKey,omitempty"`
	Command           *[]string                                   `json:"command,omitempty"`
	ContainerRegistry *string                                     `json:"containerRegistry,omitempty"`
	Enabled           *bool                                       `json:"enabled,omitempty"`
	Env               *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"env,omitempty"`
	HealthChecks *struct {
		Liveness  *DeploymentsUpsertJSONBody_Config_0_1_HealthChecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentsUpsertJSONBody_Config_0_1_HealthChecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentsUpsertJSONBody_Config_0_1_HealthChecks_Startup   `json:"startup,omitempty"`
	} `json:"healthChecks,omitempty"`
	Healthchecks *struct {
		Liveness  *DeploymentsUpsertJSONBody_Config_0_1_Healthchecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentsUpsertJSONBody_Config_0_1_Healthchecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentsUpsertJSONBody_Config_0_1_Healthchecks_Startup   `json:"startup,omitempty"`
	} `json:"healthchecks,omitempty"`
	Image        string                                                    `json:"image"`
	Integrations *[]DeploymentsUpsertJSONBody_Config_0_1_Integrations_Item `json:"integrations,omitempty"`
	Name         string                                                    `json:"name"`
	Region       *DeploymentsUpsertJSONBody_Config_0_1_Region              `json:"region,omitempty"`
	Resources    struct {
		Autoscaling *struct {
			Enabled     *bool                                                                     `json:"enabled,omitempty"`
			MaxReplicas float32                                                                   `json:"maxReplicas"`
			Metrics     []DeploymentsUpsertJSONBody_Config_0_1_Resources_Autoscaling_Metrics_Item `json:"metrics"`
		} `json:"autoscaling,omitempty"`
		MachineType string    `json:"machineType"`
		Ports       []float32 `json:"ports"`
		Replicas    *float32  `json:"replicas,omitempty"`
	} `json:"resources"`
}

// DeploymentsUpsertJSONBodyConfig01ApiVersion defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01ApiVersion string

// DeploymentsUpsertJSONBodyConfig01HealthChecksLiveness0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01HealthChecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBodyConfig01HealthChecksLiveness1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01HealthChecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBody_Config_0_1_HealthChecks_Liveness defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_0_1_HealthChecks_Liveness struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig01HealthChecksReadiness0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01HealthChecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBodyConfig01HealthChecksReadiness1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01HealthChecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBody_Config_0_1_HealthChecks_Readiness defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_0_1_HealthChecks_Readiness struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig01HealthChecksStartup0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01HealthChecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBodyConfig01HealthChecksStartup1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01HealthChecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBody_Config_0_1_HealthChecks_Startup defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_0_1_HealthChecks_Startup struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig01HealthchecksLiveness0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01HealthchecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBodyConfig01HealthchecksLiveness1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01HealthchecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBody_Config_0_1_Healthchecks_Liveness defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_0_1_Healthchecks_Liveness struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig01HealthchecksReadiness0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01HealthchecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBodyConfig01HealthchecksReadiness1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01HealthchecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBody_Config_0_1_Healthchecks_Readiness defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_0_1_Healthchecks_Readiness struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig01HealthchecksStartup0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01HealthchecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBodyConfig01HealthchecksStartup1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01HealthchecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBody_Config_0_1_Healthchecks_Startup defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_0_1_Healthchecks_Startup struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig01Integrations0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Integrations0 struct {
	Id   string                                             `json:"id"`
	Name string                                             `json:"name"`
	Path *string                                            `json:"path,omitempty"`
	Type DeploymentsUpsertJSONBodyConfig01Integrations0Type `json:"type"`
}

// DeploymentsUpsertJSONBodyConfig01Integrations0Type defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Integrations0Type string

// DeploymentsUpsertJSONBodyConfig01Integrations1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Integrations1 struct {
	AccessKeyId     *string                                                     `json:"accessKeyId,omitempty"`
	Endpoint        *string                                                     `json:"endpoint,omitempty"`
	Name            string                                                      `json:"name"`
	Path            *string                                                     `json:"path,omitempty"`
	Region          *DeploymentsUpsertJSONBody_Config_0_1_Integrations_1_Region `json:"region,omitempty"`
	SecretAccessKey *string                                                     `json:"secretAccessKey,omitempty"`
	Type            DeploymentsUpsertJSONBodyConfig01Integrations1Type          `json:"type"`
	Url             string                                                      `json:"url"`
}

// DeploymentsUpsertJSONBodyConfig01Integrations1Region0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Integrations1Region0 string

// DeploymentsUpsertJSONBodyConfig01Integrations1Region1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Integrations1Region1 string

// DeploymentsUpsertJSONBodyConfig01Integrations1Region2 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Integrations1Region2 string

// DeploymentsUpsertJSONBodyConfig01Integrations1Region3 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Integrations1Region3 = string

// DeploymentsUpsertJSONBody_Config_0_1_Integrations_1_Region defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_0_1_Integrations_1_Region struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig01Integrations1Type defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Integrations1Type string

// DeploymentsUpsertJSONBodyConfig01Integrations2 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Integrations2 struct {
	AccessKeyId     *string                                            `json:"accessKeyId,omitempty"`
	Endpoint        string                                             `json:"endpoint"`
	Name            string                                             `json:"name"`
	Path            *string                                            `json:"path,omitempty"`
	SecretAccessKey *string                                            `json:"secretAccessKey,omitempty"`
	Type            DeploymentsUpsertJSONBodyConfig01Integrations2Type `json:"type"`
}

// DeploymentsUpsertJSONBodyConfig01Integrations2Type defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Integrations2Type string

// DeploymentsUpsertJSONBodyConfig01Integrations3 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Integrations3 struct {
	Name string                                             `json:"name"`
	Type DeploymentsUpsertJSONBodyConfig01Integrations3Type `json:"type"`
}

// DeploymentsUpsertJSONBodyConfig01Integrations3Type defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Integrations3Type string

// DeploymentsUpsertJSONBodyConfig01Integrations4 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Integrations4 struct {
	Name string                                             `json:"name"`
	Path *string                                            `json:"path,omitempty"`
	Type DeploymentsUpsertJSONBodyConfig01Integrations4Type `json:"type"`
	Url  string                                             `json:"url"`
}

// DeploymentsUpsertJSONBodyConfig01Integrations4Type defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Integrations4Type string

// DeploymentsUpsertJSONBody_Config_0_1_Integrations_Item defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_0_1_Integrations_Item struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig01Region0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Region0 string

// DeploymentsUpsertJSONBodyConfig01Region1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Region1 string

// DeploymentsUpsertJSONBodyConfig01Region2 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Region2 string

// DeploymentsUpsertJSONBodyConfig01Region3 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01Region3 = string

// DeploymentsUpsertJSONBody_Config_0_1_Region defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_0_1_Region struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics0 struct {
	Metric  DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics0Metric  `json:"metric"`
	Summary DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics0Summary `json:"summary"`
	Value   float32                                                              `json:"value"`
}

// DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics0Metric defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics0Metric string

// DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics0Summary defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics0Summary string

// DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics1 struct {
	Metric  DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics1Metric  `json:"metric"`
	Summary DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics1Summary `json:"summary"`
	Value   int                                                                  `json:"value"`
}

// DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics1Metric defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics1Metric string

// DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics1Summary defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig01ResourcesAutoscalingMetrics1Summary string

// DeploymentsUpsertJSONBody_Config_0_1_Resources_Autoscaling_Metrics_Item defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_0_1_Resources_Autoscaling_Metrics_Item struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1 struct {
	ApiVersion        DeploymentsUpsertJSONBody_Config_1_ApiVersion `json:"apiVersion"`
	BasicAuthKey      *string                                       `json:"basicAuthKey,omitempty"`
	Command           *[]string                                     `json:"command,omitempty"`
	ContainerRegistry *string                                       `json:"containerRegistry,omitempty"`
	Enabled           *bool                                         `json:"enabled,omitempty"`
	Env               *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"env,omitempty"`
	HealthChecks *struct {
		Liveness  *DeploymentsUpsertJSONBody_Config_1_HealthChecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentsUpsertJSONBody_Config_1_HealthChecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentsUpsertJSONBody_Config_1_HealthChecks_Startup   `json:"startup,omitempty"`
	} `json:"healthChecks,omitempty"`
	Healthchecks *struct {
		Liveness  *DeploymentsUpsertJSONBody_Config_1_Healthchecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentsUpsertJSONBody_Config_1_Healthchecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentsUpsertJSONBody_Config_1_Healthchecks_Startup   `json:"startup,omitempty"`
	} `json:"healthchecks,omitempty"`
	Image        string                                                  `json:"image"`
	Integrations *[]DeploymentsUpsertJSONBody_Config_1_Integrations_Item `json:"integrations,omitempty"`
	Name         string                                                  `json:"name"`
	Region       *DeploymentsUpsertJSONBody_Config_1_Region              `json:"region,omitempty"`
	Resources    struct {
		Autoscaling *struct {
			Enabled     *bool                                                                   `json:"enabled,omitempty"`
			MaxReplicas float32                                                                 `json:"maxReplicas"`
			Metrics     []DeploymentsUpsertJSONBody_Config_1_Resources_Autoscaling_Metrics_Item `json:"metrics"`
		} `json:"autoscaling,omitempty"`
		MachineType string    `json:"machineType"`
		Ports       []float32 `json:"ports"`
		Replicas    *float32  `json:"replicas,omitempty"`
	} `json:"resources"`
}

// DeploymentsUpsertJSONBodyConfig1ApiVersion0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1ApiVersion0 string

// DeploymentsUpsertJSONBodyConfig1ApiVersion1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1ApiVersion1 string

// DeploymentsUpsertJSONBody_Config_1_ApiVersion defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_1_ApiVersion struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig1HealthChecksLiveness0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1HealthChecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBodyConfig1HealthChecksLiveness1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1HealthChecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBody_Config_1_HealthChecks_Liveness defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_1_HealthChecks_Liveness struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig1HealthChecksReadiness0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1HealthChecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBodyConfig1HealthChecksReadiness1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1HealthChecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBody_Config_1_HealthChecks_Readiness defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_1_HealthChecks_Readiness struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig1HealthChecksStartup0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1HealthChecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBodyConfig1HealthChecksStartup1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1HealthChecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBody_Config_1_HealthChecks_Startup defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_1_HealthChecks_Startup struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig1HealthchecksLiveness0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1HealthchecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBodyConfig1HealthchecksLiveness1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1HealthchecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBody_Config_1_Healthchecks_Liveness defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_1_Healthchecks_Liveness struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig1HealthchecksReadiness0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1HealthchecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBodyConfig1HealthchecksReadiness1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1HealthchecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBody_Config_1_Healthchecks_Readiness defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_1_Healthchecks_Readiness struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig1HealthchecksStartup0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1HealthchecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBodyConfig1HealthchecksStartup1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1HealthchecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}

// DeploymentsUpsertJSONBody_Config_1_Healthchecks_Startup defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_1_Healthchecks_Startup struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig1Integrations0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Integrations0 struct {
	Id   string                                            `json:"id"`
	Name string                                            `json:"name"`
	Path *string                                           `json:"path,omitempty"`
	Type DeploymentsUpsertJSONBodyConfig1Integrations0Type `json:"type"`
}

// DeploymentsUpsertJSONBodyConfig1Integrations0Type defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Integrations0Type string

// DeploymentsUpsertJSONBodyConfig1Integrations1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Integrations1 struct {
	AccessKeyId     *string                                                   `json:"accessKeyId,omitempty"`
	Endpoint        *string                                                   `json:"endpoint,omitempty"`
	Name            string                                                    `json:"name"`
	Path            *string                                                   `json:"path,omitempty"`
	Region          *DeploymentsUpsertJSONBody_Config_1_Integrations_1_Region `json:"region,omitempty"`
	SecretAccessKey *string                                                   `json:"secretAccessKey,omitempty"`
	Type            DeploymentsUpsertJSONBodyConfig1Integrations1Type         `json:"type"`
	Url             string                                                    `json:"url"`
}

// DeploymentsUpsertJSONBodyConfig1Integrations1Region0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Integrations1Region0 string

// DeploymentsUpsertJSONBodyConfig1Integrations1Region1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Integrations1Region1 string

// DeploymentsUpsertJSONBodyConfig1Integrations1Region2 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Integrations1Region2 string

// DeploymentsUpsertJSONBodyConfig1Integrations1Region3 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Integrations1Region3 = string

// DeploymentsUpsertJSONBody_Config_1_Integrations_1_Region defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_1_Integrations_1_Region struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig1Integrations1Type defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Integrations1Type string

// DeploymentsUpsertJSONBodyConfig1Integrations2 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Integrations2 struct {
	AccessKeyId     *string                                           `json:"accessKeyId,omitempty"`
	Endpoint        string                                            `json:"endpoint"`
	Name            string                                            `json:"name"`
	Path            *string                                           `json:"path,omitempty"`
	SecretAccessKey *string                                           `json:"secretAccessKey,omitempty"`
	Type            DeploymentsUpsertJSONBodyConfig1Integrations2Type `json:"type"`
}

// DeploymentsUpsertJSONBodyConfig1Integrations2Type defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Integrations2Type string

// DeploymentsUpsertJSONBodyConfig1Integrations3 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Integrations3 struct {
	Name string                                            `json:"name"`
	Type DeploymentsUpsertJSONBodyConfig1Integrations3Type `json:"type"`
}

// DeploymentsUpsertJSONBodyConfig1Integrations3Type defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Integrations3Type string

// DeploymentsUpsertJSONBodyConfig1Integrations4 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Integrations4 struct {
	Name string                                            `json:"name"`
	Path *string                                           `json:"path,omitempty"`
	Type DeploymentsUpsertJSONBodyConfig1Integrations4Type `json:"type"`
	Url  string                                            `json:"url"`
}

// DeploymentsUpsertJSONBodyConfig1Integrations4Type defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Integrations4Type string

// DeploymentsUpsertJSONBody_Config_1_Integrations_Item defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_1_Integrations_Item struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig1Region0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Region0 string

// DeploymentsUpsertJSONBodyConfig1Region1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Region1 string

// DeploymentsUpsertJSONBodyConfig1Region2 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Region2 string

// DeploymentsUpsertJSONBodyConfig1Region3 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1Region3 = string

// DeploymentsUpsertJSONBody_Config_1_Region defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_1_Region struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics0 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics0 struct {
	Metric  DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics0Metric  `json:"metric"`
	Summary DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics0Summary `json:"summary"`
	Value   float32                                                             `json:"value"`
}

// DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics0Metric defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics0Metric string

// DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics0Summary defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics0Summary string

// DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics1 defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics1 struct {
	Metric  DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics1Metric  `json:"metric"`
	Summary DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics1Summary `json:"summary"`
	Value   int                                                                 `json:"value"`
}

// DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics1Metric defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics1Metric string

// DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics1Summary defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBodyConfig1ResourcesAutoscalingMetrics1Summary string

// DeploymentsUpsertJSONBody_Config_1_Resources_Autoscaling_Metrics_Item defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config_1_Resources_Autoscaling_Metrics_Item struct {
	union json.RawMessage
}

// DeploymentsUpsertJSONBody_Config defines parameters for DeploymentsUpsert.
type DeploymentsUpsertJSONBody_Config struct {
	union json.RawMessage
}

// DeploymentHistoryListParams defines parameters for DeploymentHistoryList.
type DeploymentHistoryListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *DeploymentHistoryListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *DeploymentHistoryListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// DeploymentHistoryListParamsOrderBy defines parameters for DeploymentHistoryList.
type DeploymentHistoryListParamsOrderBy string

// DeploymentHistoryListParamsOrder defines parameters for DeploymentHistoryList.
type DeploymentHistoryListParamsOrder string

// DeploymentLogsListParams defines parameters for DeploymentLogsList.
type DeploymentLogsListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *DeploymentLogsListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *DeploymentLogsListParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// InstanceId Get the logs for a particular instance ID
	InstanceId *string `form:"instanceId,omitempty" json:"instanceId,omitempty"`
}

// DeploymentLogsListParamsOrderBy defines parameters for DeploymentLogsList.
type DeploymentLogsListParamsOrderBy string

// DeploymentLogsListParamsOrder defines parameters for DeploymentLogsList.
type DeploymentLogsListParamsOrder string

// DeploymentMetricsGetParams defines parameters for DeploymentMetricsGet.
type DeploymentMetricsGetParams struct {
	// Metric The metric to fetch.
	Metric struct {
		union json.RawMessage
	} `form:"metric" json:"metric"`

	// Timeframe The time frame for the metrics request.
	Timeframe *DeploymentMetricsGetParamsTimeframe `form:"timeframe,omitempty" json:"timeframe,omitempty"`
}

// DeploymentMetricsGetParamsMetric0 defines parameters for DeploymentMetricsGet.
type DeploymentMetricsGetParamsMetric0 string

// DeploymentMetricsGetParamsMetric1 defines parameters for DeploymentMetricsGet.
type DeploymentMetricsGetParamsMetric1 string

// DeploymentMetricsGetParamsMetric2 defines parameters for DeploymentMetricsGet.
type DeploymentMetricsGetParamsMetric2 string

// DeploymentMetricsGetParamsMetric3 defines parameters for DeploymentMetricsGet.
type DeploymentMetricsGetParamsMetric3 string

// DeploymentMetricsGetParamsMetric4 defines parameters for DeploymentMetricsGet.
type DeploymentMetricsGetParamsMetric4 string

// DeploymentMetricsGetParamsMetric5 defines parameters for DeploymentMetricsGet.
type DeploymentMetricsGetParamsMetric5 string

// DeploymentMetricsGetParamsMetric6 defines parameters for DeploymentMetricsGet.
type DeploymentMetricsGetParamsMetric6 string

// DeploymentMetricsGetParamsTimeframe defines parameters for DeploymentMetricsGet.
type DeploymentMetricsGetParamsTimeframe string

// DeploymentRunsGetParams defines parameters for DeploymentRunsGet.
type DeploymentRunsGetParams struct {
	// Limit The latest n number of deployment runs to return
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// MachineAvailabilityListParams defines parameters for MachineAvailabilityList.
type MachineAvailabilityListParams struct {
	// MachineType Filter to machine availabilities with machine types matching this string.
	MachineType string `form:"machineType" json:"machineType"`

	// Region Filter to machine availabilities in this region.
	Region struct {
		union json.RawMessage
	} `form:"region" json:"region"`
}

// MachineAvailabilityListParamsRegion0 defines parameters for MachineAvailabilityList.
type MachineAvailabilityListParamsRegion0 string

// MachineAvailabilityListParamsRegion1 defines parameters for MachineAvailabilityList.
type MachineAvailabilityListParamsRegion1 string

// MachineAvailabilityListParamsRegion2 defines parameters for MachineAvailabilityList.
type MachineAvailabilityListParamsRegion2 string

// MachineAvailabilityListParamsRegion3 defines parameters for MachineAvailabilityList.
type MachineAvailabilityListParamsRegion3 = string

// MachineEventsListParams defines parameters for MachineEventsList.
type MachineEventsListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *MachineEventsListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order     *MachineEventsListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
	MachineId *string                       `form:"machineId,omitempty" json:"machineId,omitempty"`
}

// MachineEventsListParamsOrderBy defines parameters for MachineEventsList.
type MachineEventsListParamsOrderBy string

// MachineEventsListParamsOrder defines parameters for MachineEventsList.
type MachineEventsListParamsOrder string

// MachinesListParams defines parameters for MachinesList.
type MachinesListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *MachinesListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order  *MachinesListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
	Name   *string                  `form:"name,omitempty" json:"name,omitempty"`
	Region *struct {
		union json.RawMessage
	} `form:"region,omitempty" json:"region,omitempty"`
	AgentType   *string `form:"agentType,omitempty" json:"agentType,omitempty"`
	MachineType *string `form:"machineType,omitempty" json:"machineType,omitempty"`
}

// MachinesListParamsOrderBy defines parameters for MachinesList.
type MachinesListParamsOrderBy string

// MachinesListParamsOrder defines parameters for MachinesList.
type MachinesListParamsOrder string

// MachinesListParamsRegion0 defines parameters for MachinesList.
type MachinesListParamsRegion0 string

// MachinesListParamsRegion1 defines parameters for MachinesList.
type MachinesListParamsRegion1 string

// MachinesListParamsRegion2 defines parameters for MachinesList.
type MachinesListParamsRegion2 string

// MachinesListParamsRegion3 defines parameters for MachinesList.
type MachinesListParamsRegion3 = string

// MachinesCreateJSONBody defines parameters for MachinesCreate.
type MachinesCreateJSONBody struct {
	// AccessorIds The IDs of users to grant access to the machine.
	AccessorIds *[]string `json:"accessorIds,omitempty"`

	// AutoShutdownEnabled Whether to enable auto shutdown.
	AutoShutdownEnabled *bool `json:"autoShutdownEnabled,omitempty"`

	// AutoShutdownForce Whether to force shutdown the machine.
	AutoShutdownForce *bool `json:"autoShutdownForce,omitempty"`

	// AutoShutdownTimeout The auto shutdown timeout in hours.
	AutoShutdownTimeout *float32 `json:"autoShutdownTimeout,omitempty"`

	// AutoSnapshotEnabled Whether to enable auto snapshots.
	AutoSnapshotEnabled *bool `json:"autoSnapshotEnabled,omitempty"`

	// AutoSnapshotFrequency The auto snapshot frequency.
	AutoSnapshotFrequency *MachinesCreateJSONBodyAutoSnapshotFrequency `json:"autoSnapshotFrequency,omitempty"`

	// AutoSnapshotSaveCount The number of auto snapshots to save.
	AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount,omitempty"`

	// DiskSize The disk size in gigabytes.
	DiskSize MachinesCreateJSONBody_DiskSize `json:"diskSize"`

	// EmailPassword Whether to email the password.
	EmailPassword *bool `json:"emailPassword,omitempty"`

	// EnableNvlink Whether to enable NVLink.
	EnableNvlink *bool `json:"enableNvlink,omitempty"`

	// MachineType The machine type. This must correspond to a machine type label as indicated in <a href='#operation/osTemplates-list'>List OS templates</a> or <a href='#operation/customTemplates-list'>List templates</a>.
	MachineType string `json:"machineType"`

	// Name The name of the new machine.
	Name string `json:"name"`

	// NetworkId The network ID.
	NetworkId *string `json:"networkId,omitempty"`

	// PublicIpType The public IP type.
	PublicIpType *MachinesCreateJSONBodyPublicIpType `json:"publicIpType,omitempty"`

	// Region The region to create the machine in.
	Region MachinesCreateJSONBody_Region `json:"region"`

	// RestorePointEnabled Whether to use initial snapshot as a restore point.
	RestorePointEnabled *bool `json:"restorePointEnabled,omitempty"`

	// RestorePointFrequency The restore point frequency.
	RestorePointFrequency *MachinesCreateJSONBodyRestorePointFrequency `json:"restorePointFrequency,omitempty"`

	// StartOnCreate Whether to start the machine on creation.
	StartOnCreate *bool `json:"startOnCreate,omitempty"`

	// StartupScriptId The startup script ID.
	StartupScriptId *string `json:"startupScriptId,omitempty"`

	// TakeInitialSnapshot Whether to take an initial snapshot.
	TakeInitialSnapshot *bool `json:"takeInitialSnapshot,omitempty"`

	// TemplateId The template ID. See <a href='#operation/osTemplates-list'>List OS templates</a> or <a href='#operation/customTemplates-list'>List templates</a>.
	TemplateId string `json:"templateId"`
}

// MachinesCreateJSONBodyAutoSnapshotFrequency defines parameters for MachinesCreate.
type MachinesCreateJSONBodyAutoSnapshotFrequency string

// MachinesCreateJSONBodyDiskSize0 defines parameters for MachinesCreate.
type MachinesCreateJSONBodyDiskSize0 float32

// MachinesCreateJSONBodyDiskSize1 defines parameters for MachinesCreate.
type MachinesCreateJSONBodyDiskSize1 float32

// MachinesCreateJSONBodyDiskSize2 defines parameters for MachinesCreate.
type MachinesCreateJSONBodyDiskSize2 float32

// MachinesCreateJSONBodyDiskSize3 defines parameters for MachinesCreate.
type MachinesCreateJSONBodyDiskSize3 float32

// MachinesCreateJSONBodyDiskSize4 defines parameters for MachinesCreate.
type MachinesCreateJSONBodyDiskSize4 float32

// MachinesCreateJSONBodyDiskSize5 defines parameters for MachinesCreate.
type MachinesCreateJSONBodyDiskSize5 float32

// MachinesCreateJSONBodyDiskSize6 defines parameters for MachinesCreate.
type MachinesCreateJSONBodyDiskSize6 float32

// MachinesCreateJSONBodyDiskSize7 defines parameters for MachinesCreate.
type MachinesCreateJSONBodyDiskSize7 float32

// MachinesCreateJSONBodyDiskSize8 defines parameters for MachinesCreate.
type MachinesCreateJSONBodyDiskSize8 float32

// MachinesCreateJSONBodyDiskSize9 defines parameters for MachinesCreate.
type MachinesCreateJSONBodyDiskSize9 float32

// MachinesCreateJSONBodyDiskSize10 defines parameters for MachinesCreate.
type MachinesCreateJSONBodyDiskSize10 = float32

// MachinesCreateJSONBody_DiskSize defines parameters for MachinesCreate.
type MachinesCreateJSONBody_DiskSize struct {
	union json.RawMessage
}

// MachinesCreateJSONBodyPublicIpType defines parameters for MachinesCreate.
type MachinesCreateJSONBodyPublicIpType string

// MachinesCreateJSONBodyRegion0 defines parameters for MachinesCreate.
type MachinesCreateJSONBodyRegion0 string

// MachinesCreateJSONBodyRegion1 defines parameters for MachinesCreate.
type MachinesCreateJSONBodyRegion1 string

// MachinesCreateJSONBodyRegion2 defines parameters for MachinesCreate.
type MachinesCreateJSONBodyRegion2 string

// MachinesCreateJSONBodyRegion3 defines parameters for MachinesCreate.
type MachinesCreateJSONBodyRegion3 = string

// MachinesCreateJSONBody_Region defines parameters for MachinesCreate.
type MachinesCreateJSONBody_Region struct {
	union json.RawMessage
}

// MachinesCreateJSONBodyRestorePointFrequency defines parameters for MachinesCreate.
type MachinesCreateJSONBodyRestorePointFrequency string

// MachinesUpdateJSONBody defines parameters for MachinesUpdate.
type MachinesUpdateJSONBody struct {
	// AutoShutdownEnabled Whether to enable auto shutdown.
	AutoShutdownEnabled *bool `json:"autoShutdownEnabled,omitempty"`

	// AutoShutdownForce Whether to force shutdown the machine.
	AutoShutdownForce *bool `json:"autoShutdownForce,omitempty"`

	// AutoShutdownTimeout The auto shutdown timeout in hours.
	AutoShutdownTimeout *float32 `json:"autoShutdownTimeout,omitempty"`

	// AutoSnapshotEnabled Whether to enable auto snapshots.
	AutoSnapshotEnabled *bool `json:"autoSnapshotEnabled,omitempty"`

	// AutoSnapshotFrequency The auto snapshot frequency.
	AutoSnapshotFrequency *MachinesUpdateJSONBodyAutoSnapshotFrequency `json:"autoSnapshotFrequency,omitempty"`

	// AutoSnapshotSaveCount The number of auto snapshots to save.
	AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount,omitempty"`

	// DiskSize The disk size in gigabytes.
	DiskSize *MachinesUpdateJSONBody_DiskSize `json:"diskSize,omitempty"`

	// MachineType The machine type. This must correspond to a machine type label as indicated in <a href='#operation/osTemplates-list'>List OS templates</a> or <a href='#operation/customTemplates-list'>List templates</a>.
	MachineType *string `json:"machineType,omitempty"`

	// Name The name of the machine.
	Name *string `json:"name,omitempty"`

	// NetworkId The network ID.
	NetworkId *string `json:"networkId,omitempty"`

	// PublicIpType The public IP type.
	PublicIpType *MachinesUpdateJSONBodyPublicIpType `json:"publicIpType,omitempty"`

	// RestorePointEnabled Whether to use initial snapshot as a restore point.
	RestorePointEnabled *bool `json:"restorePointEnabled,omitempty"`

	// RestorePointFrequency The restore point frequency.
	RestorePointFrequency *MachinesUpdateJSONBodyRestorePointFrequency `json:"restorePointFrequency,omitempty"`

	// RestorePointSnapshotId The restore point snapshot ID.
	RestorePointSnapshotId *string `json:"restorePointSnapshotId,omitempty"`
}

// MachinesUpdateJSONBodyAutoSnapshotFrequency defines parameters for MachinesUpdate.
type MachinesUpdateJSONBodyAutoSnapshotFrequency string

// MachinesUpdateJSONBodyDiskSize0 defines parameters for MachinesUpdate.
type MachinesUpdateJSONBodyDiskSize0 float32

// MachinesUpdateJSONBodyDiskSize1 defines parameters for MachinesUpdate.
type MachinesUpdateJSONBodyDiskSize1 float32

// MachinesUpdateJSONBodyDiskSize2 defines parameters for MachinesUpdate.
type MachinesUpdateJSONBodyDiskSize2 float32

// MachinesUpdateJSONBodyDiskSize3 defines parameters for MachinesUpdate.
type MachinesUpdateJSONBodyDiskSize3 float32

// MachinesUpdateJSONBodyDiskSize4 defines parameters for MachinesUpdate.
type MachinesUpdateJSONBodyDiskSize4 float32

// MachinesUpdateJSONBodyDiskSize5 defines parameters for MachinesUpdate.
type MachinesUpdateJSONBodyDiskSize5 float32

// MachinesUpdateJSONBodyDiskSize6 defines parameters for MachinesUpdate.
type MachinesUpdateJSONBodyDiskSize6 float32

// MachinesUpdateJSONBodyDiskSize7 defines parameters for MachinesUpdate.
type MachinesUpdateJSONBodyDiskSize7 float32

// MachinesUpdateJSONBodyDiskSize8 defines parameters for MachinesUpdate.
type MachinesUpdateJSONBodyDiskSize8 float32

// MachinesUpdateJSONBodyDiskSize9 defines parameters for MachinesUpdate.
type MachinesUpdateJSONBodyDiskSize9 float32

// MachinesUpdateJSONBodyDiskSize10 defines parameters for MachinesUpdate.
type MachinesUpdateJSONBodyDiskSize10 = float32

// MachinesUpdateJSONBody_DiskSize defines parameters for MachinesUpdate.
type MachinesUpdateJSONBody_DiskSize struct {
	union json.RawMessage
}

// MachinesUpdateJSONBodyPublicIpType defines parameters for MachinesUpdate.
type MachinesUpdateJSONBodyPublicIpType string

// MachinesUpdateJSONBodyRestorePointFrequency defines parameters for MachinesUpdate.
type MachinesUpdateJSONBodyRestorePointFrequency string

// MachinesListAccessorsParams defines parameters for MachinesListAccessors.
type MachinesListAccessorsParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *MachinesListAccessorsParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *MachinesListAccessorsParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// MachinesListAccessorsParamsOrderBy defines parameters for MachinesListAccessors.
type MachinesListAccessorsParamsOrderBy string

// MachinesListAccessorsParamsOrder defines parameters for MachinesListAccessors.
type MachinesListAccessorsParamsOrder string

// MachinesAddAccessorJSONBody defines parameters for MachinesAddAccessor.
type MachinesAddAccessorJSONBody struct {
	// UserId The ID of the user to add as an accessor. This can be found on the team members page at https://console.paperspace.com/settings/members.
	UserId string `json:"userId"`
}

// ModelsListParams defines parameters for ModelsList.
type ModelsListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *ModelsListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order     *ModelsListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
	ProjectId *string                `form:"projectId,omitempty" json:"projectId,omitempty"`
}

// ModelsListParamsOrderBy defines parameters for ModelsList.
type ModelsListParamsOrderBy string

// ModelsListParamsOrder defines parameters for ModelsList.
type ModelsListParamsOrder string

// ModelsCreateJSONBody defines parameters for ModelsCreate.
type ModelsCreateJSONBody struct {
	// Description The description of the model
	Description *ModelsCreateJSONBody_Description `json:"description"`

	// IsPublic Whether the model is public
	IsPublic bool `json:"isPublic"`

	// Name The name of the model
	Name string `json:"name"`

	// ProjectId The ID of the project
	ProjectId *string `json:"projectId,omitempty"`

	// StorageProviderId The ID of the storage provider
	StorageProviderId *string `json:"storageProviderId,omitempty"`
}

// ModelsCreateJSONBodyDescription0 defines parameters for ModelsCreate.
type ModelsCreateJSONBodyDescription0 = interface{}

// ModelsCreateJSONBodyDescription1 defines parameters for ModelsCreate.
type ModelsCreateJSONBodyDescription1 = string

// ModelsCreateJSONBody_Description defines parameters for ModelsCreate.
type ModelsCreateJSONBody_Description struct {
	union json.RawMessage
}

// OsTemplatesListParams defines parameters for OsTemplatesList.
type OsTemplatesListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *OsTemplatesListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *OsTemplatesListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
	Name  *string                     `form:"name,omitempty" json:"name,omitempty"`
}

// OsTemplatesListParamsOrderBy defines parameters for OsTemplatesList.
type OsTemplatesListParamsOrderBy string

// OsTemplatesListParamsOrder defines parameters for OsTemplatesList.
type OsTemplatesListParamsOrder string

// PrivateNetworksListParams defines parameters for PrivateNetworksList.
type PrivateNetworksListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *PrivateNetworksListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order  *PrivateNetworksListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
	Name   *string                         `form:"name,omitempty" json:"name,omitempty"`
	Region *struct {
		union json.RawMessage
	} `form:"region,omitempty" json:"region,omitempty"`
}

// PrivateNetworksListParamsOrderBy defines parameters for PrivateNetworksList.
type PrivateNetworksListParamsOrderBy string

// PrivateNetworksListParamsOrder defines parameters for PrivateNetworksList.
type PrivateNetworksListParamsOrder string

// PrivateNetworksListParamsRegion0 defines parameters for PrivateNetworksList.
type PrivateNetworksListParamsRegion0 string

// PrivateNetworksListParamsRegion1 defines parameters for PrivateNetworksList.
type PrivateNetworksListParamsRegion1 string

// PrivateNetworksListParamsRegion2 defines parameters for PrivateNetworksList.
type PrivateNetworksListParamsRegion2 string

// PrivateNetworksListParamsRegion3 defines parameters for PrivateNetworksList.
type PrivateNetworksListParamsRegion3 = string

// PrivateNetworksCreateJSONBody defines parameters for PrivateNetworksCreate.
type PrivateNetworksCreateJSONBody struct {
	// MigrateMachines Whether to migrate all machines not currently in a private network to the new private network.
	MigrateMachines *bool `json:"migrateMachines,omitempty"`

	// Name The name of the private network.
	Name string `json:"name"`

	// Region The region the private network is in.
	Region PrivateNetworksCreateJSONBody_Region `json:"region"`
}

// PrivateNetworksCreateJSONBodyRegion0 defines parameters for PrivateNetworksCreate.
type PrivateNetworksCreateJSONBodyRegion0 string

// PrivateNetworksCreateJSONBodyRegion1 defines parameters for PrivateNetworksCreate.
type PrivateNetworksCreateJSONBodyRegion1 string

// PrivateNetworksCreateJSONBodyRegion2 defines parameters for PrivateNetworksCreate.
type PrivateNetworksCreateJSONBodyRegion2 string

// PrivateNetworksCreateJSONBodyRegion3 defines parameters for PrivateNetworksCreate.
type PrivateNetworksCreateJSONBodyRegion3 = string

// PrivateNetworksCreateJSONBody_Region defines parameters for PrivateNetworksCreate.
type PrivateNetworksCreateJSONBody_Region struct {
	union json.RawMessage
}

// PrivateNetworksUpdateJSONBody defines parameters for PrivateNetworksUpdate.
type PrivateNetworksUpdateJSONBody struct {
	// Name The name of the private network.
	Name *string `json:"name,omitempty"`
}

// ProjectsListParams defines parameters for ProjectsList.
type ProjectsListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *ProjectsListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *ProjectsListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// ProjectsListParamsOrderBy defines parameters for ProjectsList.
type ProjectsListParamsOrderBy string

// ProjectsListParamsOrder defines parameters for ProjectsList.
type ProjectsListParamsOrder string

// ProjectsCreateJSONBody defines parameters for ProjectsCreate.
type ProjectsCreateJSONBody struct {
	// Name The name of the project
	Name string `json:"name"`
}

// ProjectsUpdateJSONBody defines parameters for ProjectsUpdate.
type ProjectsUpdateJSONBody struct {
	// Name The new name of the project
	Name string `json:"name"`
}

// ProjectActivityListParams defines parameters for ProjectActivityList.
type ProjectActivityListParams struct {
	// After Fetch the next page of results after this cursor.
	After *openapi_types.UUID `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *ProjectActivityListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *ProjectActivityListParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// DeploymentId Constrain results to deployment activity.
	DeploymentId *openapi_types.UUID `form:"deploymentId,omitempty" json:"deploymentId,omitempty"`
}

// ProjectActivityListParamsOrderBy defines parameters for ProjectActivityList.
type ProjectActivityListParamsOrderBy string

// ProjectActivityListParamsOrder defines parameters for ProjectActivityList.
type ProjectActivityListParamsOrder string

// ProjectCollaboratorsListParams defines parameters for ProjectCollaboratorsList.
type ProjectCollaboratorsListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *ProjectCollaboratorsListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *ProjectCollaboratorsListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// ProjectCollaboratorsListParamsOrderBy defines parameters for ProjectCollaboratorsList.
type ProjectCollaboratorsListParamsOrderBy string

// ProjectCollaboratorsListParamsOrder defines parameters for ProjectCollaboratorsList.
type ProjectCollaboratorsListParamsOrder string

// ProjectCollaboratorsCreateJSONBody defines parameters for ProjectCollaboratorsCreate.
type ProjectCollaboratorsCreateJSONBody struct {
	// UserId The ID of the user to add to the project. This can be found on the user's profile at https://console.paperspace.com/account/settings/profile.
	UserId string `json:"userId"`
}

// ProjectDeploymentsListParams defines parameters for ProjectDeploymentsList.
type ProjectDeploymentsListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *ProjectDeploymentsListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *ProjectDeploymentsListParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Name Filter to deployments with names matching this string.
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// ProjectDeploymentsListParamsOrderBy defines parameters for ProjectDeploymentsList.
type ProjectDeploymentsListParamsOrderBy string

// ProjectDeploymentsListParamsOrder defines parameters for ProjectDeploymentsList.
type ProjectDeploymentsListParamsOrder string

// ProjectModelsListParams defines parameters for ProjectModelsList.
type ProjectModelsListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *ProjectModelsListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *ProjectModelsListParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Name Filter to models with names matching this string.
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// ProjectModelsListParamsOrderBy defines parameters for ProjectModelsList.
type ProjectModelsListParamsOrderBy string

// ProjectModelsListParamsOrder defines parameters for ProjectModelsList.
type ProjectModelsListParamsOrder string

// ProjectSecretsListParams defines parameters for ProjectSecretsList.
type ProjectSecretsListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *ProjectSecretsListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *ProjectSecretsListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// ProjectSecretsListParamsOrderBy defines parameters for ProjectSecretsList.
type ProjectSecretsListParamsOrderBy string

// ProjectSecretsListParamsOrder defines parameters for ProjectSecretsList.
type ProjectSecretsListParamsOrder string

// ProjectSecretsCreateJSONBody defines parameters for ProjectSecretsCreate.
type ProjectSecretsCreateJSONBody struct {
	// Name The name of the secret, e.g. "DB_PASSWORD".
	Name string `json:"name"`

	// Value The value of the secret, e.g. "password".
	Value string `json:"value"`
}

// ProjectSecretsUpdateJSONBody defines parameters for ProjectSecretsUpdate.
type ProjectSecretsUpdateJSONBody struct {
	// Value The value of the secret, e.g. "password".
	Value string `json:"value"`
}

// ProjectTagsRemoveParams defines parameters for ProjectTagsRemove.
type ProjectTagsRemoveParams struct {
	// Name The name of the tag to remove from the project
	Name string `form:"name" json:"name"`
}

// ProjectTagsListParams defines parameters for ProjectTagsList.
type ProjectTagsListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *ProjectTagsListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *ProjectTagsListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// ProjectTagsListParamsOrderBy defines parameters for ProjectTagsList.
type ProjectTagsListParamsOrderBy string

// ProjectTagsListParamsOrder defines parameters for ProjectTagsList.
type ProjectTagsListParamsOrder string

// ProjectTagsAddJSONBody defines parameters for ProjectTagsAdd.
type ProjectTagsAddJSONBody struct {
	// Name The name of the tag to add to the project
	Name string `json:"name"`
}

// PublicIpsListParams defines parameters for PublicIpsList.
type PublicIpsListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *PublicIpsListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order  *PublicIpsListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
	Region *struct {
		union json.RawMessage
	} `form:"region,omitempty" json:"region,omitempty"`
}

// PublicIpsListParamsOrderBy defines parameters for PublicIpsList.
type PublicIpsListParamsOrderBy string

// PublicIpsListParamsOrder defines parameters for PublicIpsList.
type PublicIpsListParamsOrder string

// PublicIpsListParamsRegion0 defines parameters for PublicIpsList.
type PublicIpsListParamsRegion0 string

// PublicIpsListParamsRegion1 defines parameters for PublicIpsList.
type PublicIpsListParamsRegion1 string

// PublicIpsListParamsRegion2 defines parameters for PublicIpsList.
type PublicIpsListParamsRegion2 string

// PublicIpsListParamsRegion3 defines parameters for PublicIpsList.
type PublicIpsListParamsRegion3 = string

// PublicIpsClaimJSONBody defines parameters for PublicIpsClaim.
type PublicIpsClaimJSONBody struct {
	// Region The region of the public IP.
	Region PublicIpsClaimJSONBody_Region `json:"region"`
}

// PublicIpsClaimJSONBodyRegion0 defines parameters for PublicIpsClaim.
type PublicIpsClaimJSONBodyRegion0 string

// PublicIpsClaimJSONBodyRegion1 defines parameters for PublicIpsClaim.
type PublicIpsClaimJSONBodyRegion1 string

// PublicIpsClaimJSONBodyRegion2 defines parameters for PublicIpsClaim.
type PublicIpsClaimJSONBodyRegion2 string

// PublicIpsClaimJSONBodyRegion3 defines parameters for PublicIpsClaim.
type PublicIpsClaimJSONBodyRegion3 = string

// PublicIpsClaimJSONBody_Region defines parameters for PublicIpsClaim.
type PublicIpsClaimJSONBody_Region struct {
	union json.RawMessage
}

// PublicIpsAssignJSONBody defines parameters for PublicIpsAssign.
type PublicIpsAssignJSONBody struct {
	// MachineId The ID of the machine to assign the public IP to.
	MachineId *string `json:"machineId"`
}

// SharedDrivesListParams defines parameters for SharedDrivesList.
type SharedDrivesListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *SharedDrivesListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order  *SharedDrivesListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
	Name   *string                      `form:"name,omitempty" json:"name,omitempty"`
	Region *string                      `form:"region,omitempty" json:"region,omitempty"`
}

// SharedDrivesListParamsOrderBy defines parameters for SharedDrivesList.
type SharedDrivesListParamsOrderBy string

// SharedDrivesListParamsOrder defines parameters for SharedDrivesList.
type SharedDrivesListParamsOrder string

// SharedDrivesCreateJSONBody defines parameters for SharedDrivesCreate.
type SharedDrivesCreateJSONBody struct {
	// Name The name of the shared drive.
	Name string `json:"name"`

	// NetworkId The ID of the network the shared drive is in.
	NetworkId string `json:"networkId"`

	// Region The region the shared drive is in.
	Region string `json:"region"`

	// Size The size of the shared drive in gigabytes.
	Size SharedDrivesCreateJSONBody_Size `json:"size"`
}

// SharedDrivesCreateJSONBodySize0 defines parameters for SharedDrivesCreate.
type SharedDrivesCreateJSONBodySize0 float32

// SharedDrivesCreateJSONBodySize1 defines parameters for SharedDrivesCreate.
type SharedDrivesCreateJSONBodySize1 float32

// SharedDrivesCreateJSONBodySize2 defines parameters for SharedDrivesCreate.
type SharedDrivesCreateJSONBodySize2 float32

// SharedDrivesCreateJSONBodySize3 defines parameters for SharedDrivesCreate.
type SharedDrivesCreateJSONBodySize3 float32

// SharedDrivesCreateJSONBodySize4 defines parameters for SharedDrivesCreate.
type SharedDrivesCreateJSONBodySize4 float32

// SharedDrivesCreateJSONBodySize5 defines parameters for SharedDrivesCreate.
type SharedDrivesCreateJSONBodySize5 float32

// SharedDrivesCreateJSONBodySize6 defines parameters for SharedDrivesCreate.
type SharedDrivesCreateJSONBodySize6 float32

// SharedDrivesCreateJSONBodySize7 defines parameters for SharedDrivesCreate.
type SharedDrivesCreateJSONBodySize7 float32

// SharedDrivesCreateJSONBodySize8 defines parameters for SharedDrivesCreate.
type SharedDrivesCreateJSONBodySize8 float32

// SharedDrivesCreateJSONBodySize9 defines parameters for SharedDrivesCreate.
type SharedDrivesCreateJSONBodySize9 float32

// SharedDrivesCreateJSONBodySize10 defines parameters for SharedDrivesCreate.
type SharedDrivesCreateJSONBodySize10 = float32

// SharedDrivesCreateJSONBody_Size defines parameters for SharedDrivesCreate.
type SharedDrivesCreateJSONBody_Size struct {
	union json.RawMessage
}

// SharedDrivesUpdateJSONBody defines parameters for SharedDrivesUpdate.
type SharedDrivesUpdateJSONBody struct {
	// Name The name of the shared drive.
	Name *string `json:"name,omitempty"`
}

// SnapshotsListParams defines parameters for SnapshotsList.
type SnapshotsListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *SnapshotsListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order     *SnapshotsListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
	MachineId *string                   `form:"machineId,omitempty" json:"machineId,omitempty"`
}

// SnapshotsListParamsOrderBy defines parameters for SnapshotsList.
type SnapshotsListParamsOrderBy string

// SnapshotsListParamsOrder defines parameters for SnapshotsList.
type SnapshotsListParamsOrder string

// SnapshotsCreateJSONBody defines parameters for SnapshotsCreate.
type SnapshotsCreateJSONBody struct {
	// MachineId The ID of the machine to create a snapshot for.
	MachineId string `json:"machineId"`

	// Name The name of the snapshot.
	Name string `json:"name"`
}

// SnapshotsUpdateJSONBody defines parameters for SnapshotsUpdate.
type SnapshotsUpdateJSONBody struct {
	// Name The updated name of the snapshot.
	Name *string `json:"name,omitempty"`
}

// SnapshotsRestoreJSONBody defines parameters for SnapshotsRestore.
type SnapshotsRestoreJSONBody struct {
	// CreateSnapshotBeforeRestore Create a new snapshot before restoring.
	CreateSnapshotBeforeRestore *bool `json:"createSnapshotBeforeRestore,omitempty"`
}

// StartupScriptsListParams defines parameters for StartupScriptsList.
type StartupScriptsListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *StartupScriptsListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *StartupScriptsListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
	Name  *string                        `form:"name,omitempty" json:"name,omitempty"`
}

// StartupScriptsListParamsOrderBy defines parameters for StartupScriptsList.
type StartupScriptsListParamsOrderBy string

// StartupScriptsListParamsOrder defines parameters for StartupScriptsList.
type StartupScriptsListParamsOrder string

// StartupScriptsCreateJSONBody defines parameters for StartupScriptsCreate.
type StartupScriptsCreateJSONBody struct {
	// IsRunOnce Whether the script should only run once on first boot or on every boot.
	IsRunOnce *bool `json:"isRunOnce,omitempty"`

	// Name The name of the startup script.
	Name string `json:"name"`

	// Script The script to run on startup.
	Script string `json:"script"`
}

// StartupScriptsUpdateJSONBody defines parameters for StartupScriptsUpdate.
type StartupScriptsUpdateJSONBody struct {
	// IsEnabled Whether the startup script is enabled.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// IsRunOnce Whether the script should only run once on first boot or on every boot.
	IsRunOnce *bool `json:"isRunOnce,omitempty"`

	// Name The name of the startup script.
	Name *string `json:"name,omitempty"`

	// Script The script to run on startup.
	Script *string `json:"script,omitempty"`
}

// StartupScriptsAssignJSONBody defines parameters for StartupScriptsAssign.
type StartupScriptsAssignJSONBody struct {
	// MachineId The id of the machine to assign the startup script to.
	MachineId string `json:"machineId"`
}

// StartupScriptsUnassignJSONBody defines parameters for StartupScriptsUnassign.
type StartupScriptsUnassignJSONBody struct {
	// MachineId The id of the machine to unassign the startup script from.
	MachineId string `json:"machineId"`
}

// StorageProvidersListParams defines parameters for StorageProvidersList.
type StorageProvidersListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *StorageProvidersListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *StorageProvidersListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// StorageProvidersListParamsOrderBy defines parameters for StorageProvidersList.
type StorageProvidersListParamsOrderBy string

// StorageProvidersListParamsOrder defines parameters for StorageProvidersList.
type StorageProvidersListParamsOrder string

// StorageProvidersCreateJSONBody defines parameters for StorageProvidersCreate.
type StorageProvidersCreateJSONBody struct {
	// IsTeamDefault Is team default
	IsTeamDefault *bool `json:"isTeamDefault,omitempty"`

	// Name The name of the storage provider
	Name string `json:"name"`

	// S3Config The storage provider configuration
	S3Config struct {
		AccessKey        string                                          `json:"accessKey"`
		Bucket           string                                          `json:"bucket"`
		Endpoint         *string                                         `json:"endpoint"`
		Region           *StorageProvidersCreateJSONBody_S3Config_Region `json:"region"`
		RetainData       *bool                                           `json:"retainData"`
		SecretAccessKey  string                                          `json:"secretAccessKey"`
		SignatureVersion *string                                         `json:"signatureVersion"`
	} `json:"s3Config"`

	// StorageProviderType The type of storage provider
	StorageProviderType StorageProvidersCreateJSONBodyStorageProviderType `json:"storageProviderType"`
}

// StorageProvidersCreateJSONBodyS3ConfigRegion0 defines parameters for StorageProvidersCreate.
type StorageProvidersCreateJSONBodyS3ConfigRegion0 string

// StorageProvidersCreateJSONBodyS3ConfigRegion1 defines parameters for StorageProvidersCreate.
type StorageProvidersCreateJSONBodyS3ConfigRegion1 string

// StorageProvidersCreateJSONBodyS3ConfigRegion2 defines parameters for StorageProvidersCreate.
type StorageProvidersCreateJSONBodyS3ConfigRegion2 string

// StorageProvidersCreateJSONBodyS3ConfigRegion3 defines parameters for StorageProvidersCreate.
type StorageProvidersCreateJSONBodyS3ConfigRegion3 = string

// StorageProvidersCreateJSONBody_S3Config_Region defines parameters for StorageProvidersCreate.
type StorageProvidersCreateJSONBody_S3Config_Region struct {
	union json.RawMessage
}

// StorageProvidersCreateJSONBodyStorageProviderType defines parameters for StorageProvidersCreate.
type StorageProvidersCreateJSONBodyStorageProviderType string

// StorageProvidersUpdateJSONBody defines parameters for StorageProvidersUpdate.
type StorageProvidersUpdateJSONBody struct {
	// IsTeamDefault Is team default
	IsTeamDefault bool `json:"isTeamDefault"`

	// Name The name of the storage provider
	Name string `json:"name"`

	// S3Config The storage provider configuration
	S3Config struct {
		AccessKey        string                                          `json:"accessKey"`
		Bucket           string                                          `json:"bucket"`
		Endpoint         *string                                         `json:"endpoint"`
		Region           *StorageProvidersUpdateJSONBody_S3Config_Region `json:"region"`
		RetainData       *bool                                           `json:"retainData"`
		SecretAccessKey  string                                          `json:"secretAccessKey"`
		SignatureVersion *string                                         `json:"signatureVersion"`
	} `json:"s3Config"`
}

// StorageProvidersUpdateJSONBodyS3ConfigRegion0 defines parameters for StorageProvidersUpdate.
type StorageProvidersUpdateJSONBodyS3ConfigRegion0 string

// StorageProvidersUpdateJSONBodyS3ConfigRegion1 defines parameters for StorageProvidersUpdate.
type StorageProvidersUpdateJSONBodyS3ConfigRegion1 string

// StorageProvidersUpdateJSONBodyS3ConfigRegion2 defines parameters for StorageProvidersUpdate.
type StorageProvidersUpdateJSONBodyS3ConfigRegion2 string

// StorageProvidersUpdateJSONBodyS3ConfigRegion3 defines parameters for StorageProvidersUpdate.
type StorageProvidersUpdateJSONBodyS3ConfigRegion3 = string

// StorageProvidersUpdateJSONBody_S3Config_Region defines parameters for StorageProvidersUpdate.
type StorageProvidersUpdateJSONBody_S3Config_Region struct {
	union json.RawMessage
}

// TeamSecretsListParams defines parameters for TeamSecretsList.
type TeamSecretsListParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *TeamSecretsListParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *TeamSecretsListParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// TeamSecretsListParamsOrderBy defines parameters for TeamSecretsList.
type TeamSecretsListParamsOrderBy string

// TeamSecretsListParamsOrder defines parameters for TeamSecretsList.
type TeamSecretsListParamsOrder string

// TeamSecretsCreateJSONBody defines parameters for TeamSecretsCreate.
type TeamSecretsCreateJSONBody struct {
	// Name The name of the secret, e.g. "DB_PASSWORD".
	Name string `json:"name"`

	// Value The value of the secret, e.g. "password".
	Value string `json:"value"`
}

// TeamSecretsUpdateJSONBody defines parameters for TeamSecretsUpdate.
type TeamSecretsUpdateJSONBody struct {
	// Value The value of the secret, e.g. "password".
	Value string `json:"value"`
}

// TeamMembershipsListByTeamIdParams defines parameters for TeamMembershipsListByTeamId.
type TeamMembershipsListByTeamIdParams struct {
	// After Fetch the next page of results after this cursor.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit The number of items to fetch after this page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order results by one of these fields.
	OrderBy *TeamMembershipsListByTeamIdParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Order The order to sort the results by.
	Order *TeamMembershipsListByTeamIdParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Role Filter team members by their role on the team.
	Role *TeamMembershipsListByTeamIdParamsRole `form:"role,omitempty" json:"role,omitempty"`
}

// TeamMembershipsListByTeamIdParamsOrderBy defines parameters for TeamMembershipsListByTeamId.
type TeamMembershipsListByTeamIdParamsOrderBy string

// TeamMembershipsListByTeamIdParamsOrder defines parameters for TeamMembershipsListByTeamId.
type TeamMembershipsListByTeamIdParamsOrder string

// TeamMembershipsListByTeamIdParamsRole defines parameters for TeamMembershipsListByTeamId.
type TeamMembershipsListByTeamIdParamsRole string

// TeamMembershipsUpdateJSONBody defines parameters for TeamMembershipsUpdate.
type TeamMembershipsUpdateJSONBody struct {
	// IsAdmin Whether the user will gain admin access or not
	IsAdmin bool `json:"isAdmin"`
}

// ContainerRegistriesCreateJSONRequestBody defines body for ContainerRegistriesCreate for application/json ContentType.
type ContainerRegistriesCreateJSONRequestBody ContainerRegistriesCreateJSONBody

// ContainerRegistriesUpdateJSONRequestBody defines body for ContainerRegistriesUpdate for application/json ContentType.
type ContainerRegistriesUpdateJSONRequestBody ContainerRegistriesUpdateJSONBody

// CustomTemplatesCreateJSONRequestBody defines body for CustomTemplatesCreate for application/json ContentType.
type CustomTemplatesCreateJSONRequestBody CustomTemplatesCreateJSONBody

// CustomTemplatesUpdateJSONRequestBody defines body for CustomTemplatesUpdate for application/json ContentType.
type CustomTemplatesUpdateJSONRequestBody CustomTemplatesUpdateJSONBody

// DatasetsCreateJSONRequestBody defines body for DatasetsCreate for application/json ContentType.
type DatasetsCreateJSONRequestBody DatasetsCreateJSONBody

// DatasetVersionsCreateJSONRequestBody defines body for DatasetVersionsCreate for application/json ContentType.
type DatasetVersionsCreateJSONRequestBody DatasetVersionsCreateJSONBody

// DatasetVersionsUpdateJSONRequestBody defines body for DatasetVersionsUpdate for application/json ContentType.
type DatasetVersionsUpdateJSONRequestBody DatasetVersionsUpdateJSONBody

// DatasetsUpdateJSONRequestBody defines body for DatasetsUpdate for application/json ContentType.
type DatasetsUpdateJSONRequestBody DatasetsUpdateJSONBody

// DeploymentsUpsertJSONRequestBody defines body for DeploymentsUpsert for application/json ContentType.
type DeploymentsUpsertJSONRequestBody DeploymentsUpsertJSONBody

// MachinesCreateJSONRequestBody defines body for MachinesCreate for application/json ContentType.
type MachinesCreateJSONRequestBody MachinesCreateJSONBody

// MachinesUpdateJSONRequestBody defines body for MachinesUpdate for application/json ContentType.
type MachinesUpdateJSONRequestBody MachinesUpdateJSONBody

// MachinesAddAccessorJSONRequestBody defines body for MachinesAddAccessor for application/json ContentType.
type MachinesAddAccessorJSONRequestBody MachinesAddAccessorJSONBody

// ModelsCreateJSONRequestBody defines body for ModelsCreate for application/json ContentType.
type ModelsCreateJSONRequestBody ModelsCreateJSONBody

// PrivateNetworksCreateJSONRequestBody defines body for PrivateNetworksCreate for application/json ContentType.
type PrivateNetworksCreateJSONRequestBody PrivateNetworksCreateJSONBody

// PrivateNetworksUpdateJSONRequestBody defines body for PrivateNetworksUpdate for application/json ContentType.
type PrivateNetworksUpdateJSONRequestBody PrivateNetworksUpdateJSONBody

// ProjectsCreateJSONRequestBody defines body for ProjectsCreate for application/json ContentType.
type ProjectsCreateJSONRequestBody ProjectsCreateJSONBody

// ProjectsUpdateJSONRequestBody defines body for ProjectsUpdate for application/json ContentType.
type ProjectsUpdateJSONRequestBody ProjectsUpdateJSONBody

// ProjectCollaboratorsCreateJSONRequestBody defines body for ProjectCollaboratorsCreate for application/json ContentType.
type ProjectCollaboratorsCreateJSONRequestBody ProjectCollaboratorsCreateJSONBody

// ProjectSecretsCreateJSONRequestBody defines body for ProjectSecretsCreate for application/json ContentType.
type ProjectSecretsCreateJSONRequestBody ProjectSecretsCreateJSONBody

// ProjectSecretsUpdateJSONRequestBody defines body for ProjectSecretsUpdate for application/json ContentType.
type ProjectSecretsUpdateJSONRequestBody ProjectSecretsUpdateJSONBody

// ProjectTagsAddJSONRequestBody defines body for ProjectTagsAdd for application/json ContentType.
type ProjectTagsAddJSONRequestBody ProjectTagsAddJSONBody

// PublicIpsClaimJSONRequestBody defines body for PublicIpsClaim for application/json ContentType.
type PublicIpsClaimJSONRequestBody PublicIpsClaimJSONBody

// PublicIpsAssignJSONRequestBody defines body for PublicIpsAssign for application/json ContentType.
type PublicIpsAssignJSONRequestBody PublicIpsAssignJSONBody

// SharedDrivesCreateJSONRequestBody defines body for SharedDrivesCreate for application/json ContentType.
type SharedDrivesCreateJSONRequestBody SharedDrivesCreateJSONBody

// SharedDrivesUpdateJSONRequestBody defines body for SharedDrivesUpdate for application/json ContentType.
type SharedDrivesUpdateJSONRequestBody SharedDrivesUpdateJSONBody

// SnapshotsCreateJSONRequestBody defines body for SnapshotsCreate for application/json ContentType.
type SnapshotsCreateJSONRequestBody SnapshotsCreateJSONBody

// SnapshotsUpdateJSONRequestBody defines body for SnapshotsUpdate for application/json ContentType.
type SnapshotsUpdateJSONRequestBody SnapshotsUpdateJSONBody

// SnapshotsRestoreJSONRequestBody defines body for SnapshotsRestore for application/json ContentType.
type SnapshotsRestoreJSONRequestBody SnapshotsRestoreJSONBody

// StartupScriptsCreateJSONRequestBody defines body for StartupScriptsCreate for application/json ContentType.
type StartupScriptsCreateJSONRequestBody StartupScriptsCreateJSONBody

// StartupScriptsUpdateJSONRequestBody defines body for StartupScriptsUpdate for application/json ContentType.
type StartupScriptsUpdateJSONRequestBody StartupScriptsUpdateJSONBody

// StartupScriptsAssignJSONRequestBody defines body for StartupScriptsAssign for application/json ContentType.
type StartupScriptsAssignJSONRequestBody StartupScriptsAssignJSONBody

// StartupScriptsUnassignJSONRequestBody defines body for StartupScriptsUnassign for application/json ContentType.
type StartupScriptsUnassignJSONRequestBody StartupScriptsUnassignJSONBody

// StorageProvidersCreateJSONRequestBody defines body for StorageProvidersCreate for application/json ContentType.
type StorageProvidersCreateJSONRequestBody StorageProvidersCreateJSONBody

// StorageProvidersUpdateJSONRequestBody defines body for StorageProvidersUpdate for application/json ContentType.
type StorageProvidersUpdateJSONRequestBody StorageProvidersUpdateJSONBody

// TeamSecretsCreateJSONRequestBody defines body for TeamSecretsCreate for application/json ContentType.
type TeamSecretsCreateJSONRequestBody TeamSecretsCreateJSONBody

// TeamSecretsUpdateJSONRequestBody defines body for TeamSecretsUpdate for application/json ContentType.
type TeamSecretsUpdateJSONRequestBody TeamSecretsUpdateJSONBody

// TeamMembershipsUpdateJSONRequestBody defines body for TeamMembershipsUpdate for application/json ContentType.
type TeamMembershipsUpdateJSONRequestBody TeamMembershipsUpdateJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AuthSession request
	AuthSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ContainerRegistriesList request
	ContainerRegistriesList(ctx context.Context, params *ContainerRegistriesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ContainerRegistriesCreateWithBody request with any body
	ContainerRegistriesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ContainerRegistriesCreate(ctx context.Context, body ContainerRegistriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ContainerRegistriesDelete request
	ContainerRegistriesDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ContainerRegistriesGet request
	ContainerRegistriesGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ContainerRegistriesUpdateWithBody request with any body
	ContainerRegistriesUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ContainerRegistriesUpdate(ctx context.Context, id string, body ContainerRegistriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ContainerRegistriesTestConnection request
	ContainerRegistriesTestConnection(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomTemplatesList request
	CustomTemplatesList(ctx context.Context, params *CustomTemplatesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomTemplatesCreateWithBody request with any body
	CustomTemplatesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomTemplatesCreate(ctx context.Context, body CustomTemplatesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomTemplatesDelete request
	CustomTemplatesDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomTemplatesGet request
	CustomTemplatesGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomTemplatesUpdateWithBody request with any body
	CustomTemplatesUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomTemplatesUpdate(ctx context.Context, id string, body CustomTemplatesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetsList request
	DatasetsList(ctx context.Context, params *DatasetsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetsCreateWithBody request with any body
	DatasetsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DatasetsCreate(ctx context.Context, body DatasetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetVersionsList request
	DatasetVersionsList(ctx context.Context, datasetId string, params *DatasetVersionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetVersionsCreateWithBody request with any body
	DatasetVersionsCreateWithBody(ctx context.Context, datasetId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DatasetVersionsCreate(ctx context.Context, datasetId string, body DatasetVersionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetVersionsDelete request
	DatasetVersionsDelete(ctx context.Context, datasetId string, version string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetVersionsGet request
	DatasetVersionsGet(ctx context.Context, datasetId string, version string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetVersionsUpdateWithBody request with any body
	DatasetVersionsUpdateWithBody(ctx context.Context, datasetId string, version string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DatasetVersionsUpdate(ctx context.Context, datasetId string, version string, body DatasetVersionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetsDelete request
	DatasetsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetsGet request
	DatasetsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetsUpdateWithBody request with any body
	DatasetsUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DatasetsUpdate(ctx context.Context, id string, body DatasetsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeploymentsList request
	DeploymentsList(ctx context.Context, params *DeploymentsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeploymentsUpsertWithBody request with any body
	DeploymentsUpsertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeploymentsUpsert(ctx context.Context, body DeploymentsUpsertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeploymentsDelete request
	DeploymentsDelete(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeploymentsGet request
	DeploymentsGet(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeploymentHistoryList request
	DeploymentHistoryList(ctx context.Context, id openapi_types.UUID, params *DeploymentHistoryListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeploymentLogsList request
	DeploymentLogsList(ctx context.Context, id openapi_types.UUID, params *DeploymentLogsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeploymentMetricsGet request
	DeploymentMetricsGet(ctx context.Context, id openapi_types.UUID, params *DeploymentMetricsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeploymentRunsGet request
	DeploymentRunsGet(ctx context.Context, id openapi_types.UUID, params *DeploymentRunsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachineAvailabilityList request
	MachineAvailabilityList(ctx context.Context, params *MachineAvailabilityListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachineEventsList request
	MachineEventsList(ctx context.Context, params *MachineEventsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachineEventsGet request
	MachineEventsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesList request
	MachinesList(ctx context.Context, params *MachinesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesCreateWithBody request with any body
	MachinesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MachinesCreate(ctx context.Context, body MachinesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesDelete request
	MachinesDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesGet request
	MachinesGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesUpdateWithBody request with any body
	MachinesUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MachinesUpdate(ctx context.Context, id string, body MachinesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesListAccessors request
	MachinesListAccessors(ctx context.Context, id string, params *MachinesListAccessorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesAddAccessorWithBody request with any body
	MachinesAddAccessorWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MachinesAddAccessor(ctx context.Context, id string, body MachinesAddAccessorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesRemoveAccessor request
	MachinesRemoveAccessor(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesGetAccessor request
	MachinesGetAccessor(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesGetDesktop request
	MachinesGetDesktop(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesRestart request
	MachinesRestart(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesStart request
	MachinesStart(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesStop request
	MachinesStop(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelsList request
	ModelsList(ctx context.Context, params *ModelsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelsCreateWithBody request with any body
	ModelsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModelsCreate(ctx context.Context, body ModelsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelsDelete request
	ModelsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelsGet request
	ModelsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OsTemplatesList request
	OsTemplatesList(ctx context.Context, params *OsTemplatesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrivateNetworksList request
	PrivateNetworksList(ctx context.Context, params *PrivateNetworksListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrivateNetworksCreateWithBody request with any body
	PrivateNetworksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrivateNetworksCreate(ctx context.Context, body PrivateNetworksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrivateNetworksDelete request
	PrivateNetworksDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrivateNetworksGet request
	PrivateNetworksGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrivateNetworksUpdateWithBody request with any body
	PrivateNetworksUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrivateNetworksUpdate(ctx context.Context, id string, body PrivateNetworksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsList request
	ProjectsList(ctx context.Context, params *ProjectsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsCreateWithBody request with any body
	ProjectsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectsCreate(ctx context.Context, body ProjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsDelete request
	ProjectsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsGet request
	ProjectsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsUpdateWithBody request with any body
	ProjectsUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectsUpdate(ctx context.Context, id string, body ProjectsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectActivityList request
	ProjectActivityList(ctx context.Context, id string, params *ProjectActivityListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectCollaboratorsList request
	ProjectCollaboratorsList(ctx context.Context, id string, params *ProjectCollaboratorsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectCollaboratorsCreateWithBody request with any body
	ProjectCollaboratorsCreateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectCollaboratorsCreate(ctx context.Context, id string, body ProjectCollaboratorsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectCollaboratorsDelete request
	ProjectCollaboratorsDelete(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectDeploymentsList request
	ProjectDeploymentsList(ctx context.Context, id string, params *ProjectDeploymentsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectModelsList request
	ProjectModelsList(ctx context.Context, id string, params *ProjectModelsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectModelsRemove request
	ProjectModelsRemove(ctx context.Context, id string, modelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectModelsAdd request
	ProjectModelsAdd(ctx context.Context, id string, modelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectSecretsList request
	ProjectSecretsList(ctx context.Context, id string, params *ProjectSecretsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectSecretsCreateWithBody request with any body
	ProjectSecretsCreateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectSecretsCreate(ctx context.Context, id string, body ProjectSecretsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectSecretsDelete request
	ProjectSecretsDelete(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectSecretsGetProjectSecret request
	ProjectSecretsGetProjectSecret(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectSecretsUpdateWithBody request with any body
	ProjectSecretsUpdateWithBody(ctx context.Context, id string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectSecretsUpdate(ctx context.Context, id string, name string, body ProjectSecretsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectTagsRemove request
	ProjectTagsRemove(ctx context.Context, id string, params *ProjectTagsRemoveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectTagsList request
	ProjectTagsList(ctx context.Context, id string, params *ProjectTagsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectTagsAddWithBody request with any body
	ProjectTagsAddWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectTagsAdd(ctx context.Context, id string, body ProjectTagsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublicIpsList request
	PublicIpsList(ctx context.Context, params *PublicIpsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublicIpsClaimWithBody request with any body
	PublicIpsClaimWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PublicIpsClaim(ctx context.Context, body PublicIpsClaimJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublicIpsRelease request
	PublicIpsRelease(ctx context.Context, ip string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublicIpsAssignWithBody request with any body
	PublicIpsAssignWithBody(ctx context.Context, ip string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PublicIpsAssign(ctx context.Context, ip string, body PublicIpsAssignJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SharedDrivesList request
	SharedDrivesList(ctx context.Context, params *SharedDrivesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SharedDrivesCreateWithBody request with any body
	SharedDrivesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SharedDrivesCreate(ctx context.Context, body SharedDrivesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SharedDrivesDelete request
	SharedDrivesDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SharedDrivesGet request
	SharedDrivesGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SharedDrivesUpdateWithBody request with any body
	SharedDrivesUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SharedDrivesUpdate(ctx context.Context, id string, body SharedDrivesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnapshotsList request
	SnapshotsList(ctx context.Context, params *SnapshotsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnapshotsCreateWithBody request with any body
	SnapshotsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SnapshotsCreate(ctx context.Context, body SnapshotsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnapshotsDelete request
	SnapshotsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnapshotsGet request
	SnapshotsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnapshotsUpdateWithBody request with any body
	SnapshotsUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SnapshotsUpdate(ctx context.Context, id string, body SnapshotsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnapshotsRestoreWithBody request with any body
	SnapshotsRestoreWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SnapshotsRestore(ctx context.Context, id string, body SnapshotsRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartupScriptsList request
	StartupScriptsList(ctx context.Context, params *StartupScriptsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartupScriptsCreateWithBody request with any body
	StartupScriptsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartupScriptsCreate(ctx context.Context, body StartupScriptsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartupScriptsDelete request
	StartupScriptsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartupScriptsGet request
	StartupScriptsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartupScriptsUpdateWithBody request with any body
	StartupScriptsUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartupScriptsUpdate(ctx context.Context, id string, body StartupScriptsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartupScriptsAssignWithBody request with any body
	StartupScriptsAssignWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartupScriptsAssign(ctx context.Context, id string, body StartupScriptsAssignJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartupScriptsUnassignWithBody request with any body
	StartupScriptsUnassignWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartupScriptsUnassign(ctx context.Context, id string, body StartupScriptsUnassignJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StorageProvidersList request
	StorageProvidersList(ctx context.Context, params *StorageProvidersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StorageProvidersCreateWithBody request with any body
	StorageProvidersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StorageProvidersCreate(ctx context.Context, body StorageProvidersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StorageUtilizationGetPublic request
	StorageUtilizationGetPublic(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StorageProvidersDelete request
	StorageProvidersDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StorageProvidersGet request
	StorageProvidersGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StorageProvidersUpdateWithBody request with any body
	StorageProvidersUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StorageProvidersUpdate(ctx context.Context, id string, body StorageProvidersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamSecretsList request
	TeamSecretsList(ctx context.Context, id string, params *TeamSecretsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamSecretsCreateWithBody request with any body
	TeamSecretsCreateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamSecretsCreate(ctx context.Context, id string, body TeamSecretsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamSecretsDelete request
	TeamSecretsDelete(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamSecretsGet request
	TeamSecretsGet(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamSecretsUpdateWithBody request with any body
	TeamSecretsUpdateWithBody(ctx context.Context, id string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamSecretsUpdate(ctx context.Context, id string, name string, body TeamSecretsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamMembershipsListByTeamId request
	TeamMembershipsListByTeamId(ctx context.Context, teamId string, params *TeamMembershipsListByTeamIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamMembershipsRemoveUser request
	TeamMembershipsRemoveUser(ctx context.Context, teamId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamMembershipsUpdateWithBody request with any body
	TeamMembershipsUpdateWithBody(ctx context.Context, teamId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamMembershipsUpdate(ctx context.Context, teamId string, userId string, body TeamMembershipsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AuthSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthSessionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContainerRegistriesList(ctx context.Context, params *ContainerRegistriesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContainerRegistriesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContainerRegistriesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContainerRegistriesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContainerRegistriesCreate(ctx context.Context, body ContainerRegistriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContainerRegistriesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContainerRegistriesDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContainerRegistriesDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContainerRegistriesGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContainerRegistriesGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContainerRegistriesUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContainerRegistriesUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContainerRegistriesUpdate(ctx context.Context, id string, body ContainerRegistriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContainerRegistriesUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContainerRegistriesTestConnection(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContainerRegistriesTestConnectionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomTemplatesList(ctx context.Context, params *CustomTemplatesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomTemplatesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomTemplatesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomTemplatesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomTemplatesCreate(ctx context.Context, body CustomTemplatesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomTemplatesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomTemplatesDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomTemplatesDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomTemplatesGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomTemplatesGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomTemplatesUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomTemplatesUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomTemplatesUpdate(ctx context.Context, id string, body CustomTemplatesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomTemplatesUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsList(ctx context.Context, params *DatasetsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsCreate(ctx context.Context, body DatasetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetVersionsList(ctx context.Context, datasetId string, params *DatasetVersionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetVersionsListRequest(c.Server, datasetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetVersionsCreateWithBody(ctx context.Context, datasetId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetVersionsCreateRequestWithBody(c.Server, datasetId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetVersionsCreate(ctx context.Context, datasetId string, body DatasetVersionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetVersionsCreateRequest(c.Server, datasetId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetVersionsDelete(ctx context.Context, datasetId string, version string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetVersionsDeleteRequest(c.Server, datasetId, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetVersionsGet(ctx context.Context, datasetId string, version string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetVersionsGetRequest(c.Server, datasetId, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetVersionsUpdateWithBody(ctx context.Context, datasetId string, version string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetVersionsUpdateRequestWithBody(c.Server, datasetId, version, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetVersionsUpdate(ctx context.Context, datasetId string, version string, body DatasetVersionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetVersionsUpdateRequest(c.Server, datasetId, version, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsUpdate(ctx context.Context, id string, body DatasetsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeploymentsList(ctx context.Context, params *DeploymentsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeploymentsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeploymentsUpsertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeploymentsUpsertRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeploymentsUpsert(ctx context.Context, body DeploymentsUpsertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeploymentsUpsertRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeploymentsDelete(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeploymentsDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeploymentsGet(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeploymentsGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeploymentHistoryList(ctx context.Context, id openapi_types.UUID, params *DeploymentHistoryListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeploymentHistoryListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeploymentLogsList(ctx context.Context, id openapi_types.UUID, params *DeploymentLogsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeploymentLogsListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeploymentMetricsGet(ctx context.Context, id openapi_types.UUID, params *DeploymentMetricsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeploymentMetricsGetRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeploymentRunsGet(ctx context.Context, id openapi_types.UUID, params *DeploymentRunsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeploymentRunsGetRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachineAvailabilityList(ctx context.Context, params *MachineAvailabilityListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachineAvailabilityListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachineEventsList(ctx context.Context, params *MachineEventsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachineEventsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachineEventsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachineEventsGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesList(ctx context.Context, params *MachinesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesCreate(ctx context.Context, body MachinesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesUpdate(ctx context.Context, id string, body MachinesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesListAccessors(ctx context.Context, id string, params *MachinesListAccessorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesListAccessorsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesAddAccessorWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesAddAccessorRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesAddAccessor(ctx context.Context, id string, body MachinesAddAccessorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesAddAccessorRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesRemoveAccessor(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesRemoveAccessorRequest(c.Server, id, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesGetAccessor(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesGetAccessorRequest(c.Server, id, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesGetDesktop(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesGetDesktopRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesRestart(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesRestartRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesStart(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesStartRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesStop(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesStopRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsList(ctx context.Context, params *ModelsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsCreate(ctx context.Context, body ModelsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OsTemplatesList(ctx context.Context, params *OsTemplatesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOsTemplatesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrivateNetworksList(ctx context.Context, params *PrivateNetworksListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrivateNetworksListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrivateNetworksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrivateNetworksCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrivateNetworksCreate(ctx context.Context, body PrivateNetworksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrivateNetworksCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrivateNetworksDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrivateNetworksDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrivateNetworksGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrivateNetworksGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrivateNetworksUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrivateNetworksUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrivateNetworksUpdate(ctx context.Context, id string, body PrivateNetworksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrivateNetworksUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsList(ctx context.Context, params *ProjectsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsCreate(ctx context.Context, body ProjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsUpdate(ctx context.Context, id string, body ProjectsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectActivityList(ctx context.Context, id string, params *ProjectActivityListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectActivityListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectCollaboratorsList(ctx context.Context, id string, params *ProjectCollaboratorsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectCollaboratorsListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectCollaboratorsCreateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectCollaboratorsCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectCollaboratorsCreate(ctx context.Context, id string, body ProjectCollaboratorsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectCollaboratorsCreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectCollaboratorsDelete(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectCollaboratorsDeleteRequest(c.Server, id, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectDeploymentsList(ctx context.Context, id string, params *ProjectDeploymentsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectDeploymentsListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectModelsList(ctx context.Context, id string, params *ProjectModelsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectModelsListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectModelsRemove(ctx context.Context, id string, modelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectModelsRemoveRequest(c.Server, id, modelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectModelsAdd(ctx context.Context, id string, modelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectModelsAddRequest(c.Server, id, modelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectSecretsList(ctx context.Context, id string, params *ProjectSecretsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectSecretsListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectSecretsCreateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectSecretsCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectSecretsCreate(ctx context.Context, id string, body ProjectSecretsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectSecretsCreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectSecretsDelete(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectSecretsDeleteRequest(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectSecretsGetProjectSecret(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectSecretsGetProjectSecretRequest(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectSecretsUpdateWithBody(ctx context.Context, id string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectSecretsUpdateRequestWithBody(c.Server, id, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectSecretsUpdate(ctx context.Context, id string, name string, body ProjectSecretsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectSecretsUpdateRequest(c.Server, id, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectTagsRemove(ctx context.Context, id string, params *ProjectTagsRemoveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectTagsRemoveRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectTagsList(ctx context.Context, id string, params *ProjectTagsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectTagsListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectTagsAddWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectTagsAddRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectTagsAdd(ctx context.Context, id string, body ProjectTagsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectTagsAddRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublicIpsList(ctx context.Context, params *PublicIpsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublicIpsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublicIpsClaimWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublicIpsClaimRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublicIpsClaim(ctx context.Context, body PublicIpsClaimJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublicIpsClaimRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublicIpsRelease(ctx context.Context, ip string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublicIpsReleaseRequest(c.Server, ip)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublicIpsAssignWithBody(ctx context.Context, ip string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublicIpsAssignRequestWithBody(c.Server, ip, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublicIpsAssign(ctx context.Context, ip string, body PublicIpsAssignJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublicIpsAssignRequest(c.Server, ip, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SharedDrivesList(ctx context.Context, params *SharedDrivesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSharedDrivesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SharedDrivesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSharedDrivesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SharedDrivesCreate(ctx context.Context, body SharedDrivesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSharedDrivesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SharedDrivesDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSharedDrivesDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SharedDrivesGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSharedDrivesGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SharedDrivesUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSharedDrivesUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SharedDrivesUpdate(ctx context.Context, id string, body SharedDrivesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSharedDrivesUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapshotsList(ctx context.Context, params *SnapshotsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapshotsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapshotsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapshotsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapshotsCreate(ctx context.Context, body SnapshotsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapshotsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapshotsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapshotsDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapshotsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapshotsGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapshotsUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapshotsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapshotsUpdate(ctx context.Context, id string, body SnapshotsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapshotsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapshotsRestoreWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapshotsRestoreRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnapshotsRestore(ctx context.Context, id string, body SnapshotsRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnapshotsRestoreRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartupScriptsList(ctx context.Context, params *StartupScriptsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartupScriptsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartupScriptsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartupScriptsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartupScriptsCreate(ctx context.Context, body StartupScriptsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartupScriptsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartupScriptsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartupScriptsDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartupScriptsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartupScriptsGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartupScriptsUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartupScriptsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartupScriptsUpdate(ctx context.Context, id string, body StartupScriptsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartupScriptsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartupScriptsAssignWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartupScriptsAssignRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartupScriptsAssign(ctx context.Context, id string, body StartupScriptsAssignJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartupScriptsAssignRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartupScriptsUnassignWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartupScriptsUnassignRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartupScriptsUnassign(ctx context.Context, id string, body StartupScriptsUnassignJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartupScriptsUnassignRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorageProvidersList(ctx context.Context, params *StorageProvidersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorageProvidersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorageProvidersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorageProvidersCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorageProvidersCreate(ctx context.Context, body StorageProvidersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorageProvidersCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorageUtilizationGetPublic(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorageUtilizationGetPublicRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorageProvidersDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorageProvidersDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorageProvidersGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorageProvidersGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorageProvidersUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorageProvidersUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorageProvidersUpdate(ctx context.Context, id string, body StorageProvidersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorageProvidersUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamSecretsList(ctx context.Context, id string, params *TeamSecretsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamSecretsListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamSecretsCreateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamSecretsCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamSecretsCreate(ctx context.Context, id string, body TeamSecretsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamSecretsCreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamSecretsDelete(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamSecretsDeleteRequest(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamSecretsGet(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamSecretsGetRequest(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamSecretsUpdateWithBody(ctx context.Context, id string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamSecretsUpdateRequestWithBody(c.Server, id, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamSecretsUpdate(ctx context.Context, id string, name string, body TeamSecretsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamSecretsUpdateRequest(c.Server, id, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamMembershipsListByTeamId(ctx context.Context, teamId string, params *TeamMembershipsListByTeamIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamMembershipsListByTeamIdRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamMembershipsRemoveUser(ctx context.Context, teamId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamMembershipsRemoveUserRequest(c.Server, teamId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamMembershipsUpdateWithBody(ctx context.Context, teamId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamMembershipsUpdateRequestWithBody(c.Server, teamId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamMembershipsUpdate(ctx context.Context, teamId string, userId string, body TeamMembershipsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamMembershipsUpdateRequest(c.Server, teamId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAuthSessionRequest generates requests for AuthSession
func NewAuthSessionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewContainerRegistriesListRequest generates requests for ContainerRegistriesList
func NewContainerRegistriesListRequest(server string, params *ContainerRegistriesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/container-registries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewContainerRegistriesCreateRequest calls the generic ContainerRegistriesCreate builder with application/json body
func NewContainerRegistriesCreateRequest(server string, body ContainerRegistriesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewContainerRegistriesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewContainerRegistriesCreateRequestWithBody generates requests for ContainerRegistriesCreate with any type of body
func NewContainerRegistriesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/container-registries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewContainerRegistriesDeleteRequest generates requests for ContainerRegistriesDelete
func NewContainerRegistriesDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/container-registries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewContainerRegistriesGetRequest generates requests for ContainerRegistriesGet
func NewContainerRegistriesGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/container-registries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewContainerRegistriesUpdateRequest calls the generic ContainerRegistriesUpdate builder with application/json body
func NewContainerRegistriesUpdateRequest(server string, id string, body ContainerRegistriesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewContainerRegistriesUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewContainerRegistriesUpdateRequestWithBody generates requests for ContainerRegistriesUpdate with any type of body
func NewContainerRegistriesUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/container-registries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewContainerRegistriesTestConnectionRequest generates requests for ContainerRegistriesTestConnection
func NewContainerRegistriesTestConnectionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/container-registries/%s/test-connection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCustomTemplatesListRequest generates requests for CustomTemplatesList
func NewCustomTemplatesListRequest(server string, params *CustomTemplatesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MachineId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "machineId", runtime.ParamLocationQuery, *params.MachineId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCustomTemplatesCreateRequest calls the generic CustomTemplatesCreate builder with application/json body
func NewCustomTemplatesCreateRequest(server string, body CustomTemplatesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomTemplatesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomTemplatesCreateRequestWithBody generates requests for CustomTemplatesCreate with any type of body
func NewCustomTemplatesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCustomTemplatesDeleteRequest generates requests for CustomTemplatesDelete
func NewCustomTemplatesDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCustomTemplatesGetRequest generates requests for CustomTemplatesGet
func NewCustomTemplatesGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCustomTemplatesUpdateRequest calls the generic CustomTemplatesUpdate builder with application/json body
func NewCustomTemplatesUpdateRequest(server string, id string, body CustomTemplatesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomTemplatesUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCustomTemplatesUpdateRequestWithBody generates requests for CustomTemplatesUpdate with any type of body
func NewCustomTemplatesUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDatasetsListRequest generates requests for DatasetsList
func NewDatasetsListRequest(server string, params *DatasetsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/datasets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamId", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Privacy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privacy", runtime.ParamLocationQuery, *params.Privacy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetsCreateRequest calls the generic DatasetsCreate builder with application/json body
func NewDatasetsCreateRequest(server string, body DatasetsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDatasetsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewDatasetsCreateRequestWithBody generates requests for DatasetsCreate with any type of body
func NewDatasetsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/datasets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDatasetVersionsListRequest generates requests for DatasetVersionsList
func NewDatasetVersionsListRequest(server string, datasetId string, params *DatasetVersionsListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "datasetId", runtime.ParamLocationPath, datasetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/datasets/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetVersionsCreateRequest calls the generic DatasetVersionsCreate builder with application/json body
func NewDatasetVersionsCreateRequest(server string, datasetId string, body DatasetVersionsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDatasetVersionsCreateRequestWithBody(server, datasetId, "application/json", bodyReader)
}

// NewDatasetVersionsCreateRequestWithBody generates requests for DatasetVersionsCreate with any type of body
func NewDatasetVersionsCreateRequestWithBody(server string, datasetId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "datasetId", runtime.ParamLocationPath, datasetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/datasets/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDatasetVersionsDeleteRequest generates requests for DatasetVersionsDelete
func NewDatasetVersionsDeleteRequest(server string, datasetId string, version string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "datasetId", runtime.ParamLocationPath, datasetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/datasets/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetVersionsGetRequest generates requests for DatasetVersionsGet
func NewDatasetVersionsGetRequest(server string, datasetId string, version string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "datasetId", runtime.ParamLocationPath, datasetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/datasets/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetVersionsUpdateRequest calls the generic DatasetVersionsUpdate builder with application/json body
func NewDatasetVersionsUpdateRequest(server string, datasetId string, version string, body DatasetVersionsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDatasetVersionsUpdateRequestWithBody(server, datasetId, version, "application/json", bodyReader)
}

// NewDatasetVersionsUpdateRequestWithBody generates requests for DatasetVersionsUpdate with any type of body
func NewDatasetVersionsUpdateRequestWithBody(server string, datasetId string, version string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "datasetId", runtime.ParamLocationPath, datasetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/datasets/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDatasetsDeleteRequest generates requests for DatasetsDelete
func NewDatasetsDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/datasets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetsGetRequest generates requests for DatasetsGet
func NewDatasetsGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/datasets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetsUpdateRequest calls the generic DatasetsUpdate builder with application/json body
func NewDatasetsUpdateRequest(server string, id string, body DatasetsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDatasetsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDatasetsUpdateRequestWithBody generates requests for DatasetsUpdate with any type of body
func NewDatasetsUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/datasets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeploymentsListRequest generates requests for DeploymentsList
func NewDeploymentsListRequest(server string, params *DeploymentsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deployments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeploymentsUpsertRequest calls the generic DeploymentsUpsert builder with application/json body
func NewDeploymentsUpsertRequest(server string, body DeploymentsUpsertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeploymentsUpsertRequestWithBody(server, "application/json", bodyReader)
}

// NewDeploymentsUpsertRequestWithBody generates requests for DeploymentsUpsert with any type of body
func NewDeploymentsUpsertRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deployments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeploymentsDeleteRequest generates requests for DeploymentsDelete
func NewDeploymentsDeleteRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deployments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeploymentsGetRequest generates requests for DeploymentsGet
func NewDeploymentsGetRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deployments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeploymentHistoryListRequest generates requests for DeploymentHistoryList
func NewDeploymentHistoryListRequest(server string, id openapi_types.UUID, params *DeploymentHistoryListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deployments/%s/history", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeploymentLogsListRequest generates requests for DeploymentLogsList
func NewDeploymentLogsListRequest(server string, id openapi_types.UUID, params *DeploymentLogsListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deployments/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "instanceId", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeploymentMetricsGetRequest generates requests for DeploymentMetricsGet
func NewDeploymentMetricsGetRequest(server string, id openapi_types.UUID, params *DeploymentMetricsGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deployments/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metric", runtime.ParamLocationQuery, params.Metric); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Timeframe != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeframe", runtime.ParamLocationQuery, *params.Timeframe); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeploymentRunsGetRequest generates requests for DeploymentRunsGet
func NewDeploymentRunsGetRequest(server string, id openapi_types.UUID, params *DeploymentRunsGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deployments/%s/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachineAvailabilityListRequest generates requests for MachineAvailabilityList
func NewMachineAvailabilityListRequest(server string, params *MachineAvailabilityListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machine-availability")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "machineType", runtime.ParamLocationQuery, params.MachineType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, params.Region); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachineEventsListRequest generates requests for MachineEventsList
func NewMachineEventsListRequest(server string, params *MachineEventsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machine-events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MachineId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "machineId", runtime.ParamLocationQuery, *params.MachineId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachineEventsGetRequest generates requests for MachineEventsGet
func NewMachineEventsGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machine-events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesListRequest generates requests for MachinesList
func NewMachinesListRequest(server string, params *MachinesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AgentType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "agentType", runtime.ParamLocationQuery, *params.AgentType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MachineType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "machineType", runtime.ParamLocationQuery, *params.MachineType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesCreateRequest calls the generic MachinesCreate builder with application/json body
func NewMachinesCreateRequest(server string, body MachinesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMachinesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewMachinesCreateRequestWithBody generates requests for MachinesCreate with any type of body
func NewMachinesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMachinesDeleteRequest generates requests for MachinesDelete
func NewMachinesDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesGetRequest generates requests for MachinesGet
func NewMachinesGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesUpdateRequest calls the generic MachinesUpdate builder with application/json body
func NewMachinesUpdateRequest(server string, id string, body MachinesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMachinesUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewMachinesUpdateRequestWithBody generates requests for MachinesUpdate with any type of body
func NewMachinesUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMachinesListAccessorsRequest generates requests for MachinesListAccessors
func NewMachinesListAccessorsRequest(server string, id string, params *MachinesListAccessorsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machines/%s/accessors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesAddAccessorRequest calls the generic MachinesAddAccessor builder with application/json body
func NewMachinesAddAccessorRequest(server string, id string, body MachinesAddAccessorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMachinesAddAccessorRequestWithBody(server, id, "application/json", bodyReader)
}

// NewMachinesAddAccessorRequestWithBody generates requests for MachinesAddAccessor with any type of body
func NewMachinesAddAccessorRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machines/%s/accessors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMachinesRemoveAccessorRequest generates requests for MachinesRemoveAccessor
func NewMachinesRemoveAccessorRequest(server string, id string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machines/%s/accessors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesGetAccessorRequest generates requests for MachinesGetAccessor
func NewMachinesGetAccessorRequest(server string, id string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machines/%s/accessors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesGetDesktopRequest generates requests for MachinesGetDesktop
func NewMachinesGetDesktopRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machines/%s/desktop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesRestartRequest generates requests for MachinesRestart
func NewMachinesRestartRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machines/%s/restart", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesStartRequest generates requests for MachinesStart
func NewMachinesStartRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machines/%s/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesStopRequest generates requests for MachinesStop
func NewMachinesStopRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machines/%s/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelsListRequest generates requests for ModelsList
func NewModelsListRequest(server string, params *ModelsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelsCreateRequest calls the generic ModelsCreate builder with application/json body
func NewModelsCreateRequest(server string, body ModelsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModelsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewModelsCreateRequestWithBody generates requests for ModelsCreate with any type of body
func NewModelsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModelsDeleteRequest generates requests for ModelsDelete
func NewModelsDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelsGetRequest generates requests for ModelsGet
func NewModelsGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOsTemplatesListRequest generates requests for OsTemplatesList
func NewOsTemplatesListRequest(server string, params *OsTemplatesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/os-templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrivateNetworksListRequest generates requests for PrivateNetworksList
func NewPrivateNetworksListRequest(server string, params *PrivateNetworksListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/private-networks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrivateNetworksCreateRequest calls the generic PrivateNetworksCreate builder with application/json body
func NewPrivateNetworksCreateRequest(server string, body PrivateNetworksCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrivateNetworksCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewPrivateNetworksCreateRequestWithBody generates requests for PrivateNetworksCreate with any type of body
func NewPrivateNetworksCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/private-networks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPrivateNetworksDeleteRequest generates requests for PrivateNetworksDelete
func NewPrivateNetworksDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/private-networks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrivateNetworksGetRequest generates requests for PrivateNetworksGet
func NewPrivateNetworksGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/private-networks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrivateNetworksUpdateRequest calls the generic PrivateNetworksUpdate builder with application/json body
func NewPrivateNetworksUpdateRequest(server string, id string, body PrivateNetworksUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrivateNetworksUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPrivateNetworksUpdateRequestWithBody generates requests for PrivateNetworksUpdate with any type of body
func NewPrivateNetworksUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/private-networks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectsListRequest generates requests for ProjectsList
func NewProjectsListRequest(server string, params *ProjectsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsCreateRequest calls the generic ProjectsCreate builder with application/json body
func NewProjectsCreateRequest(server string, body ProjectsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewProjectsCreateRequestWithBody generates requests for ProjectsCreate with any type of body
func NewProjectsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectsDeleteRequest generates requests for ProjectsDelete
func NewProjectsDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsGetRequest generates requests for ProjectsGet
func NewProjectsGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsUpdateRequest calls the generic ProjectsUpdate builder with application/json body
func NewProjectsUpdateRequest(server string, id string, body ProjectsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewProjectsUpdateRequestWithBody generates requests for ProjectsUpdate with any type of body
func NewProjectsUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectActivityListRequest generates requests for ProjectActivityList
func NewProjectActivityListRequest(server string, id string, params *ProjectActivityListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/activity", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeploymentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deploymentId", runtime.ParamLocationQuery, *params.DeploymentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectCollaboratorsListRequest generates requests for ProjectCollaboratorsList
func NewProjectCollaboratorsListRequest(server string, id string, params *ProjectCollaboratorsListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/collaborators", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectCollaboratorsCreateRequest calls the generic ProjectCollaboratorsCreate builder with application/json body
func NewProjectCollaboratorsCreateRequest(server string, id string, body ProjectCollaboratorsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectCollaboratorsCreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewProjectCollaboratorsCreateRequestWithBody generates requests for ProjectCollaboratorsCreate with any type of body
func NewProjectCollaboratorsCreateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/collaborators", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectCollaboratorsDeleteRequest generates requests for ProjectCollaboratorsDelete
func NewProjectCollaboratorsDeleteRequest(server string, id string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/collaborators/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectDeploymentsListRequest generates requests for ProjectDeploymentsList
func NewProjectDeploymentsListRequest(server string, id string, params *ProjectDeploymentsListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/deployments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectModelsListRequest generates requests for ProjectModelsList
func NewProjectModelsListRequest(server string, id string, params *ProjectModelsListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectModelsRemoveRequest generates requests for ProjectModelsRemove
func NewProjectModelsRemoveRequest(server string, id string, modelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectModelsAddRequest generates requests for ProjectModelsAdd
func NewProjectModelsAddRequest(server string, id string, modelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/models/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectSecretsListRequest generates requests for ProjectSecretsList
func NewProjectSecretsListRequest(server string, id string, params *ProjectSecretsListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/secrets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectSecretsCreateRequest calls the generic ProjectSecretsCreate builder with application/json body
func NewProjectSecretsCreateRequest(server string, id string, body ProjectSecretsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectSecretsCreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewProjectSecretsCreateRequestWithBody generates requests for ProjectSecretsCreate with any type of body
func NewProjectSecretsCreateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/secrets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectSecretsDeleteRequest generates requests for ProjectSecretsDelete
func NewProjectSecretsDeleteRequest(server string, id string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/secrets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectSecretsGetProjectSecretRequest generates requests for ProjectSecretsGetProjectSecret
func NewProjectSecretsGetProjectSecretRequest(server string, id string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/secrets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectSecretsUpdateRequest calls the generic ProjectSecretsUpdate builder with application/json body
func NewProjectSecretsUpdateRequest(server string, id string, name string, body ProjectSecretsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectSecretsUpdateRequestWithBody(server, id, name, "application/json", bodyReader)
}

// NewProjectSecretsUpdateRequestWithBody generates requests for ProjectSecretsUpdate with any type of body
func NewProjectSecretsUpdateRequestWithBody(server string, id string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/secrets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectTagsRemoveRequest generates requests for ProjectTagsRemove
func NewProjectTagsRemoveRequest(server string, id string, params *ProjectTagsRemoveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectTagsListRequest generates requests for ProjectTagsList
func NewProjectTagsListRequest(server string, id string, params *ProjectTagsListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectTagsAddRequest calls the generic ProjectTagsAdd builder with application/json body
func NewProjectTagsAddRequest(server string, id string, body ProjectTagsAddJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectTagsAddRequestWithBody(server, id, "application/json", bodyReader)
}

// NewProjectTagsAddRequestWithBody generates requests for ProjectTagsAdd with any type of body
func NewProjectTagsAddRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPublicIpsListRequest generates requests for PublicIpsList
func NewPublicIpsListRequest(server string, params *PublicIpsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/public-ips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPublicIpsClaimRequest calls the generic PublicIpsClaim builder with application/json body
func NewPublicIpsClaimRequest(server string, body PublicIpsClaimJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPublicIpsClaimRequestWithBody(server, "application/json", bodyReader)
}

// NewPublicIpsClaimRequestWithBody generates requests for PublicIpsClaim with any type of body
func NewPublicIpsClaimRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/public-ips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPublicIpsReleaseRequest generates requests for PublicIpsRelease
func NewPublicIpsReleaseRequest(server string, ip string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ip", runtime.ParamLocationPath, ip)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/public-ips/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPublicIpsAssignRequest calls the generic PublicIpsAssign builder with application/json body
func NewPublicIpsAssignRequest(server string, ip string, body PublicIpsAssignJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPublicIpsAssignRequestWithBody(server, ip, "application/json", bodyReader)
}

// NewPublicIpsAssignRequestWithBody generates requests for PublicIpsAssign with any type of body
func NewPublicIpsAssignRequestWithBody(server string, ip string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ip", runtime.ParamLocationPath, ip)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/public-ips/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSharedDrivesListRequest generates requests for SharedDrivesList
func NewSharedDrivesListRequest(server string, params *SharedDrivesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shared-drives")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSharedDrivesCreateRequest calls the generic SharedDrivesCreate builder with application/json body
func NewSharedDrivesCreateRequest(server string, body SharedDrivesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSharedDrivesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewSharedDrivesCreateRequestWithBody generates requests for SharedDrivesCreate with any type of body
func NewSharedDrivesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shared-drives")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSharedDrivesDeleteRequest generates requests for SharedDrivesDelete
func NewSharedDrivesDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shared-drives/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSharedDrivesGetRequest generates requests for SharedDrivesGet
func NewSharedDrivesGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shared-drives/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSharedDrivesUpdateRequest calls the generic SharedDrivesUpdate builder with application/json body
func NewSharedDrivesUpdateRequest(server string, id string, body SharedDrivesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSharedDrivesUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSharedDrivesUpdateRequestWithBody generates requests for SharedDrivesUpdate with any type of body
func NewSharedDrivesUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shared-drives/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSnapshotsListRequest generates requests for SnapshotsList
func NewSnapshotsListRequest(server string, params *SnapshotsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MachineId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "machineId", runtime.ParamLocationQuery, *params.MachineId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnapshotsCreateRequest calls the generic SnapshotsCreate builder with application/json body
func NewSnapshotsCreateRequest(server string, body SnapshotsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSnapshotsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewSnapshotsCreateRequestWithBody generates requests for SnapshotsCreate with any type of body
func NewSnapshotsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSnapshotsDeleteRequest generates requests for SnapshotsDelete
func NewSnapshotsDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshots/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnapshotsGetRequest generates requests for SnapshotsGet
func NewSnapshotsGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshots/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnapshotsUpdateRequest calls the generic SnapshotsUpdate builder with application/json body
func NewSnapshotsUpdateRequest(server string, id string, body SnapshotsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSnapshotsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSnapshotsUpdateRequestWithBody generates requests for SnapshotsUpdate with any type of body
func NewSnapshotsUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshots/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSnapshotsRestoreRequest calls the generic SnapshotsRestore builder with application/json body
func NewSnapshotsRestoreRequest(server string, id string, body SnapshotsRestoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSnapshotsRestoreRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSnapshotsRestoreRequestWithBody generates requests for SnapshotsRestore with any type of body
func NewSnapshotsRestoreRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshots/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartupScriptsListRequest generates requests for StartupScriptsList
func NewStartupScriptsListRequest(server string, params *StartupScriptsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/startup-scripts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartupScriptsCreateRequest calls the generic StartupScriptsCreate builder with application/json body
func NewStartupScriptsCreateRequest(server string, body StartupScriptsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartupScriptsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewStartupScriptsCreateRequestWithBody generates requests for StartupScriptsCreate with any type of body
func NewStartupScriptsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/startup-scripts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartupScriptsDeleteRequest generates requests for StartupScriptsDelete
func NewStartupScriptsDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/startup-scripts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartupScriptsGetRequest generates requests for StartupScriptsGet
func NewStartupScriptsGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/startup-scripts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartupScriptsUpdateRequest calls the generic StartupScriptsUpdate builder with application/json body
func NewStartupScriptsUpdateRequest(server string, id string, body StartupScriptsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartupScriptsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewStartupScriptsUpdateRequestWithBody generates requests for StartupScriptsUpdate with any type of body
func NewStartupScriptsUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/startup-scripts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartupScriptsAssignRequest calls the generic StartupScriptsAssign builder with application/json body
func NewStartupScriptsAssignRequest(server string, id string, body StartupScriptsAssignJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartupScriptsAssignRequestWithBody(server, id, "application/json", bodyReader)
}

// NewStartupScriptsAssignRequestWithBody generates requests for StartupScriptsAssign with any type of body
func NewStartupScriptsAssignRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/startup-scripts/%s/assign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartupScriptsUnassignRequest calls the generic StartupScriptsUnassign builder with application/json body
func NewStartupScriptsUnassignRequest(server string, id string, body StartupScriptsUnassignJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartupScriptsUnassignRequestWithBody(server, id, "application/json", bodyReader)
}

// NewStartupScriptsUnassignRequestWithBody generates requests for StartupScriptsUnassign with any type of body
func NewStartupScriptsUnassignRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/startup-scripts/%s/unassign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStorageProvidersListRequest generates requests for StorageProvidersList
func NewStorageProvidersListRequest(server string, params *StorageProvidersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage-providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStorageProvidersCreateRequest calls the generic StorageProvidersCreate builder with application/json body
func NewStorageProvidersCreateRequest(server string, body StorageProvidersCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStorageProvidersCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewStorageProvidersCreateRequestWithBody generates requests for StorageProvidersCreate with any type of body
func NewStorageProvidersCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage-providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStorageUtilizationGetPublicRequest generates requests for StorageUtilizationGetPublic
func NewStorageUtilizationGetPublicRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage-providers/utilization")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStorageProvidersDeleteRequest generates requests for StorageProvidersDelete
func NewStorageProvidersDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStorageProvidersGetRequest generates requests for StorageProvidersGet
func NewStorageProvidersGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStorageProvidersUpdateRequest calls the generic StorageProvidersUpdate builder with application/json body
func NewStorageProvidersUpdateRequest(server string, id string, body StorageProvidersUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStorageProvidersUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewStorageProvidersUpdateRequestWithBody generates requests for StorageProvidersUpdate with any type of body
func NewStorageProvidersUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamSecretsListRequest generates requests for TeamSecretsList
func NewTeamSecretsListRequest(server string, id string, params *TeamSecretsListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/secrets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamSecretsCreateRequest calls the generic TeamSecretsCreate builder with application/json body
func NewTeamSecretsCreateRequest(server string, id string, body TeamSecretsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamSecretsCreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewTeamSecretsCreateRequestWithBody generates requests for TeamSecretsCreate with any type of body
func NewTeamSecretsCreateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/secrets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamSecretsDeleteRequest generates requests for TeamSecretsDelete
func NewTeamSecretsDeleteRequest(server string, id string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/secrets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamSecretsGetRequest generates requests for TeamSecretsGet
func NewTeamSecretsGetRequest(server string, id string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/secrets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamSecretsUpdateRequest calls the generic TeamSecretsUpdate builder with application/json body
func NewTeamSecretsUpdateRequest(server string, id string, name string, body TeamSecretsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamSecretsUpdateRequestWithBody(server, id, name, "application/json", bodyReader)
}

// NewTeamSecretsUpdateRequestWithBody generates requests for TeamSecretsUpdate with any type of body
func NewTeamSecretsUpdateRequestWithBody(server string, id string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/secrets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamMembershipsListByTeamIdRequest generates requests for TeamMembershipsListByTeamId
func NewTeamMembershipsListByTeamIdRequest(server string, teamId string, params *TeamMembershipsListByTeamIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Role != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role", runtime.ParamLocationQuery, *params.Role); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamMembershipsRemoveUserRequest generates requests for TeamMembershipsRemoveUser
func NewTeamMembershipsRemoveUserRequest(server string, teamId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamMembershipsUpdateRequest calls the generic TeamMembershipsUpdate builder with application/json body
func NewTeamMembershipsUpdateRequest(server string, teamId string, userId string, body TeamMembershipsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamMembershipsUpdateRequestWithBody(server, teamId, userId, "application/json", bodyReader)
}

// NewTeamMembershipsUpdateRequestWithBody generates requests for TeamMembershipsUpdate with any type of body
func NewTeamMembershipsUpdateRequestWithBody(server string, teamId string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AuthSessionWithResponse request
	AuthSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthSessionResponse, error)

	// ContainerRegistriesListWithResponse request
	ContainerRegistriesListWithResponse(ctx context.Context, params *ContainerRegistriesListParams, reqEditors ...RequestEditorFn) (*ContainerRegistriesListResponse, error)

	// ContainerRegistriesCreateWithBodyWithResponse request with any body
	ContainerRegistriesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ContainerRegistriesCreateResponse, error)

	ContainerRegistriesCreateWithResponse(ctx context.Context, body ContainerRegistriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ContainerRegistriesCreateResponse, error)

	// ContainerRegistriesDeleteWithResponse request
	ContainerRegistriesDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ContainerRegistriesDeleteResponse, error)

	// ContainerRegistriesGetWithResponse request
	ContainerRegistriesGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ContainerRegistriesGetResponse, error)

	// ContainerRegistriesUpdateWithBodyWithResponse request with any body
	ContainerRegistriesUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ContainerRegistriesUpdateResponse, error)

	ContainerRegistriesUpdateWithResponse(ctx context.Context, id string, body ContainerRegistriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ContainerRegistriesUpdateResponse, error)

	// ContainerRegistriesTestConnectionWithResponse request
	ContainerRegistriesTestConnectionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ContainerRegistriesTestConnectionResponse, error)

	// CustomTemplatesListWithResponse request
	CustomTemplatesListWithResponse(ctx context.Context, params *CustomTemplatesListParams, reqEditors ...RequestEditorFn) (*CustomTemplatesListResponse, error)

	// CustomTemplatesCreateWithBodyWithResponse request with any body
	CustomTemplatesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomTemplatesCreateResponse, error)

	CustomTemplatesCreateWithResponse(ctx context.Context, body CustomTemplatesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomTemplatesCreateResponse, error)

	// CustomTemplatesDeleteWithResponse request
	CustomTemplatesDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CustomTemplatesDeleteResponse, error)

	// CustomTemplatesGetWithResponse request
	CustomTemplatesGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CustomTemplatesGetResponse, error)

	// CustomTemplatesUpdateWithBodyWithResponse request with any body
	CustomTemplatesUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomTemplatesUpdateResponse, error)

	CustomTemplatesUpdateWithResponse(ctx context.Context, id string, body CustomTemplatesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomTemplatesUpdateResponse, error)

	// DatasetsListWithResponse request
	DatasetsListWithResponse(ctx context.Context, params *DatasetsListParams, reqEditors ...RequestEditorFn) (*DatasetsListResponse, error)

	// DatasetsCreateWithBodyWithResponse request with any body
	DatasetsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetsCreateResponse, error)

	DatasetsCreateWithResponse(ctx context.Context, body DatasetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetsCreateResponse, error)

	// DatasetVersionsListWithResponse request
	DatasetVersionsListWithResponse(ctx context.Context, datasetId string, params *DatasetVersionsListParams, reqEditors ...RequestEditorFn) (*DatasetVersionsListResponse, error)

	// DatasetVersionsCreateWithBodyWithResponse request with any body
	DatasetVersionsCreateWithBodyWithResponse(ctx context.Context, datasetId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetVersionsCreateResponse, error)

	DatasetVersionsCreateWithResponse(ctx context.Context, datasetId string, body DatasetVersionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetVersionsCreateResponse, error)

	// DatasetVersionsDeleteWithResponse request
	DatasetVersionsDeleteWithResponse(ctx context.Context, datasetId string, version string, reqEditors ...RequestEditorFn) (*DatasetVersionsDeleteResponse, error)

	// DatasetVersionsGetWithResponse request
	DatasetVersionsGetWithResponse(ctx context.Context, datasetId string, version string, reqEditors ...RequestEditorFn) (*DatasetVersionsGetResponse, error)

	// DatasetVersionsUpdateWithBodyWithResponse request with any body
	DatasetVersionsUpdateWithBodyWithResponse(ctx context.Context, datasetId string, version string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetVersionsUpdateResponse, error)

	DatasetVersionsUpdateWithResponse(ctx context.Context, datasetId string, version string, body DatasetVersionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetVersionsUpdateResponse, error)

	// DatasetsDeleteWithResponse request
	DatasetsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DatasetsDeleteResponse, error)

	// DatasetsGetWithResponse request
	DatasetsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DatasetsGetResponse, error)

	// DatasetsUpdateWithBodyWithResponse request with any body
	DatasetsUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetsUpdateResponse, error)

	DatasetsUpdateWithResponse(ctx context.Context, id string, body DatasetsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetsUpdateResponse, error)

	// DeploymentsListWithResponse request
	DeploymentsListWithResponse(ctx context.Context, params *DeploymentsListParams, reqEditors ...RequestEditorFn) (*DeploymentsListResponse, error)

	// DeploymentsUpsertWithBodyWithResponse request with any body
	DeploymentsUpsertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeploymentsUpsertResponse, error)

	DeploymentsUpsertWithResponse(ctx context.Context, body DeploymentsUpsertJSONRequestBody, reqEditors ...RequestEditorFn) (*DeploymentsUpsertResponse, error)

	// DeploymentsDeleteWithResponse request
	DeploymentsDeleteWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeploymentsDeleteResponse, error)

	// DeploymentsGetWithResponse request
	DeploymentsGetWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeploymentsGetResponse, error)

	// DeploymentHistoryListWithResponse request
	DeploymentHistoryListWithResponse(ctx context.Context, id openapi_types.UUID, params *DeploymentHistoryListParams, reqEditors ...RequestEditorFn) (*DeploymentHistoryListResponse, error)

	// DeploymentLogsListWithResponse request
	DeploymentLogsListWithResponse(ctx context.Context, id openapi_types.UUID, params *DeploymentLogsListParams, reqEditors ...RequestEditorFn) (*DeploymentLogsListResponse, error)

	// DeploymentMetricsGetWithResponse request
	DeploymentMetricsGetWithResponse(ctx context.Context, id openapi_types.UUID, params *DeploymentMetricsGetParams, reqEditors ...RequestEditorFn) (*DeploymentMetricsGetResponse, error)

	// DeploymentRunsGetWithResponse request
	DeploymentRunsGetWithResponse(ctx context.Context, id openapi_types.UUID, params *DeploymentRunsGetParams, reqEditors ...RequestEditorFn) (*DeploymentRunsGetResponse, error)

	// MachineAvailabilityListWithResponse request
	MachineAvailabilityListWithResponse(ctx context.Context, params *MachineAvailabilityListParams, reqEditors ...RequestEditorFn) (*MachineAvailabilityListResponse, error)

	// MachineEventsListWithResponse request
	MachineEventsListWithResponse(ctx context.Context, params *MachineEventsListParams, reqEditors ...RequestEditorFn) (*MachineEventsListResponse, error)

	// MachineEventsGetWithResponse request
	MachineEventsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*MachineEventsGetResponse, error)

	// MachinesListWithResponse request
	MachinesListWithResponse(ctx context.Context, params *MachinesListParams, reqEditors ...RequestEditorFn) (*MachinesListResponse, error)

	// MachinesCreateWithBodyWithResponse request with any body
	MachinesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesCreateResponse, error)

	MachinesCreateWithResponse(ctx context.Context, body MachinesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesCreateResponse, error)

	// MachinesDeleteWithResponse request
	MachinesDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*MachinesDeleteResponse, error)

	// MachinesGetWithResponse request
	MachinesGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*MachinesGetResponse, error)

	// MachinesUpdateWithBodyWithResponse request with any body
	MachinesUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesUpdateResponse, error)

	MachinesUpdateWithResponse(ctx context.Context, id string, body MachinesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesUpdateResponse, error)

	// MachinesListAccessorsWithResponse request
	MachinesListAccessorsWithResponse(ctx context.Context, id string, params *MachinesListAccessorsParams, reqEditors ...RequestEditorFn) (*MachinesListAccessorsResponse, error)

	// MachinesAddAccessorWithBodyWithResponse request with any body
	MachinesAddAccessorWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesAddAccessorResponse, error)

	MachinesAddAccessorWithResponse(ctx context.Context, id string, body MachinesAddAccessorJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesAddAccessorResponse, error)

	// MachinesRemoveAccessorWithResponse request
	MachinesRemoveAccessorWithResponse(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*MachinesRemoveAccessorResponse, error)

	// MachinesGetAccessorWithResponse request
	MachinesGetAccessorWithResponse(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*MachinesGetAccessorResponse, error)

	// MachinesGetDesktopWithResponse request
	MachinesGetDesktopWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*MachinesGetDesktopResponse, error)

	// MachinesRestartWithResponse request
	MachinesRestartWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*MachinesRestartResponse, error)

	// MachinesStartWithResponse request
	MachinesStartWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*MachinesStartResponse, error)

	// MachinesStopWithResponse request
	MachinesStopWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*MachinesStopResponse, error)

	// ModelsListWithResponse request
	ModelsListWithResponse(ctx context.Context, params *ModelsListParams, reqEditors ...RequestEditorFn) (*ModelsListResponse, error)

	// ModelsCreateWithBodyWithResponse request with any body
	ModelsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModelsCreateResponse, error)

	ModelsCreateWithResponse(ctx context.Context, body ModelsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ModelsCreateResponse, error)

	// ModelsDeleteWithResponse request
	ModelsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ModelsDeleteResponse, error)

	// ModelsGetWithResponse request
	ModelsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ModelsGetResponse, error)

	// OsTemplatesListWithResponse request
	OsTemplatesListWithResponse(ctx context.Context, params *OsTemplatesListParams, reqEditors ...RequestEditorFn) (*OsTemplatesListResponse, error)

	// PrivateNetworksListWithResponse request
	PrivateNetworksListWithResponse(ctx context.Context, params *PrivateNetworksListParams, reqEditors ...RequestEditorFn) (*PrivateNetworksListResponse, error)

	// PrivateNetworksCreateWithBodyWithResponse request with any body
	PrivateNetworksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrivateNetworksCreateResponse, error)

	PrivateNetworksCreateWithResponse(ctx context.Context, body PrivateNetworksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PrivateNetworksCreateResponse, error)

	// PrivateNetworksDeleteWithResponse request
	PrivateNetworksDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PrivateNetworksDeleteResponse, error)

	// PrivateNetworksGetWithResponse request
	PrivateNetworksGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PrivateNetworksGetResponse, error)

	// PrivateNetworksUpdateWithBodyWithResponse request with any body
	PrivateNetworksUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrivateNetworksUpdateResponse, error)

	PrivateNetworksUpdateWithResponse(ctx context.Context, id string, body PrivateNetworksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PrivateNetworksUpdateResponse, error)

	// ProjectsListWithResponse request
	ProjectsListWithResponse(ctx context.Context, params *ProjectsListParams, reqEditors ...RequestEditorFn) (*ProjectsListResponse, error)

	// ProjectsCreateWithBodyWithResponse request with any body
	ProjectsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsCreateResponse, error)

	ProjectsCreateWithResponse(ctx context.Context, body ProjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsCreateResponse, error)

	// ProjectsDeleteWithResponse request
	ProjectsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ProjectsDeleteResponse, error)

	// ProjectsGetWithResponse request
	ProjectsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ProjectsGetResponse, error)

	// ProjectsUpdateWithBodyWithResponse request with any body
	ProjectsUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsUpdateResponse, error)

	ProjectsUpdateWithResponse(ctx context.Context, id string, body ProjectsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsUpdateResponse, error)

	// ProjectActivityListWithResponse request
	ProjectActivityListWithResponse(ctx context.Context, id string, params *ProjectActivityListParams, reqEditors ...RequestEditorFn) (*ProjectActivityListResponse, error)

	// ProjectCollaboratorsListWithResponse request
	ProjectCollaboratorsListWithResponse(ctx context.Context, id string, params *ProjectCollaboratorsListParams, reqEditors ...RequestEditorFn) (*ProjectCollaboratorsListResponse, error)

	// ProjectCollaboratorsCreateWithBodyWithResponse request with any body
	ProjectCollaboratorsCreateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectCollaboratorsCreateResponse, error)

	ProjectCollaboratorsCreateWithResponse(ctx context.Context, id string, body ProjectCollaboratorsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectCollaboratorsCreateResponse, error)

	// ProjectCollaboratorsDeleteWithResponse request
	ProjectCollaboratorsDeleteWithResponse(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*ProjectCollaboratorsDeleteResponse, error)

	// ProjectDeploymentsListWithResponse request
	ProjectDeploymentsListWithResponse(ctx context.Context, id string, params *ProjectDeploymentsListParams, reqEditors ...RequestEditorFn) (*ProjectDeploymentsListResponse, error)

	// ProjectModelsListWithResponse request
	ProjectModelsListWithResponse(ctx context.Context, id string, params *ProjectModelsListParams, reqEditors ...RequestEditorFn) (*ProjectModelsListResponse, error)

	// ProjectModelsRemoveWithResponse request
	ProjectModelsRemoveWithResponse(ctx context.Context, id string, modelId string, reqEditors ...RequestEditorFn) (*ProjectModelsRemoveResponse, error)

	// ProjectModelsAddWithResponse request
	ProjectModelsAddWithResponse(ctx context.Context, id string, modelId string, reqEditors ...RequestEditorFn) (*ProjectModelsAddResponse, error)

	// ProjectSecretsListWithResponse request
	ProjectSecretsListWithResponse(ctx context.Context, id string, params *ProjectSecretsListParams, reqEditors ...RequestEditorFn) (*ProjectSecretsListResponse, error)

	// ProjectSecretsCreateWithBodyWithResponse request with any body
	ProjectSecretsCreateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectSecretsCreateResponse, error)

	ProjectSecretsCreateWithResponse(ctx context.Context, id string, body ProjectSecretsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectSecretsCreateResponse, error)

	// ProjectSecretsDeleteWithResponse request
	ProjectSecretsDeleteWithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*ProjectSecretsDeleteResponse, error)

	// ProjectSecretsGetProjectSecretWithResponse request
	ProjectSecretsGetProjectSecretWithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*ProjectSecretsGetProjectSecretResponse, error)

	// ProjectSecretsUpdateWithBodyWithResponse request with any body
	ProjectSecretsUpdateWithBodyWithResponse(ctx context.Context, id string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectSecretsUpdateResponse, error)

	ProjectSecretsUpdateWithResponse(ctx context.Context, id string, name string, body ProjectSecretsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectSecretsUpdateResponse, error)

	// ProjectTagsRemoveWithResponse request
	ProjectTagsRemoveWithResponse(ctx context.Context, id string, params *ProjectTagsRemoveParams, reqEditors ...RequestEditorFn) (*ProjectTagsRemoveResponse, error)

	// ProjectTagsListWithResponse request
	ProjectTagsListWithResponse(ctx context.Context, id string, params *ProjectTagsListParams, reqEditors ...RequestEditorFn) (*ProjectTagsListResponse, error)

	// ProjectTagsAddWithBodyWithResponse request with any body
	ProjectTagsAddWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectTagsAddResponse, error)

	ProjectTagsAddWithResponse(ctx context.Context, id string, body ProjectTagsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectTagsAddResponse, error)

	// PublicIpsListWithResponse request
	PublicIpsListWithResponse(ctx context.Context, params *PublicIpsListParams, reqEditors ...RequestEditorFn) (*PublicIpsListResponse, error)

	// PublicIpsClaimWithBodyWithResponse request with any body
	PublicIpsClaimWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublicIpsClaimResponse, error)

	PublicIpsClaimWithResponse(ctx context.Context, body PublicIpsClaimJSONRequestBody, reqEditors ...RequestEditorFn) (*PublicIpsClaimResponse, error)

	// PublicIpsReleaseWithResponse request
	PublicIpsReleaseWithResponse(ctx context.Context, ip string, reqEditors ...RequestEditorFn) (*PublicIpsReleaseResponse, error)

	// PublicIpsAssignWithBodyWithResponse request with any body
	PublicIpsAssignWithBodyWithResponse(ctx context.Context, ip string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublicIpsAssignResponse, error)

	PublicIpsAssignWithResponse(ctx context.Context, ip string, body PublicIpsAssignJSONRequestBody, reqEditors ...RequestEditorFn) (*PublicIpsAssignResponse, error)

	// SharedDrivesListWithResponse request
	SharedDrivesListWithResponse(ctx context.Context, params *SharedDrivesListParams, reqEditors ...RequestEditorFn) (*SharedDrivesListResponse, error)

	// SharedDrivesCreateWithBodyWithResponse request with any body
	SharedDrivesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SharedDrivesCreateResponse, error)

	SharedDrivesCreateWithResponse(ctx context.Context, body SharedDrivesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SharedDrivesCreateResponse, error)

	// SharedDrivesDeleteWithResponse request
	SharedDrivesDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SharedDrivesDeleteResponse, error)

	// SharedDrivesGetWithResponse request
	SharedDrivesGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SharedDrivesGetResponse, error)

	// SharedDrivesUpdateWithBodyWithResponse request with any body
	SharedDrivesUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SharedDrivesUpdateResponse, error)

	SharedDrivesUpdateWithResponse(ctx context.Context, id string, body SharedDrivesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SharedDrivesUpdateResponse, error)

	// SnapshotsListWithResponse request
	SnapshotsListWithResponse(ctx context.Context, params *SnapshotsListParams, reqEditors ...RequestEditorFn) (*SnapshotsListResponse, error)

	// SnapshotsCreateWithBodyWithResponse request with any body
	SnapshotsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapshotsCreateResponse, error)

	SnapshotsCreateWithResponse(ctx context.Context, body SnapshotsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapshotsCreateResponse, error)

	// SnapshotsDeleteWithResponse request
	SnapshotsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SnapshotsDeleteResponse, error)

	// SnapshotsGetWithResponse request
	SnapshotsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SnapshotsGetResponse, error)

	// SnapshotsUpdateWithBodyWithResponse request with any body
	SnapshotsUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapshotsUpdateResponse, error)

	SnapshotsUpdateWithResponse(ctx context.Context, id string, body SnapshotsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapshotsUpdateResponse, error)

	// SnapshotsRestoreWithBodyWithResponse request with any body
	SnapshotsRestoreWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapshotsRestoreResponse, error)

	SnapshotsRestoreWithResponse(ctx context.Context, id string, body SnapshotsRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapshotsRestoreResponse, error)

	// StartupScriptsListWithResponse request
	StartupScriptsListWithResponse(ctx context.Context, params *StartupScriptsListParams, reqEditors ...RequestEditorFn) (*StartupScriptsListResponse, error)

	// StartupScriptsCreateWithBodyWithResponse request with any body
	StartupScriptsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartupScriptsCreateResponse, error)

	StartupScriptsCreateWithResponse(ctx context.Context, body StartupScriptsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*StartupScriptsCreateResponse, error)

	// StartupScriptsDeleteWithResponse request
	StartupScriptsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*StartupScriptsDeleteResponse, error)

	// StartupScriptsGetWithResponse request
	StartupScriptsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*StartupScriptsGetResponse, error)

	// StartupScriptsUpdateWithBodyWithResponse request with any body
	StartupScriptsUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartupScriptsUpdateResponse, error)

	StartupScriptsUpdateWithResponse(ctx context.Context, id string, body StartupScriptsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*StartupScriptsUpdateResponse, error)

	// StartupScriptsAssignWithBodyWithResponse request with any body
	StartupScriptsAssignWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartupScriptsAssignResponse, error)

	StartupScriptsAssignWithResponse(ctx context.Context, id string, body StartupScriptsAssignJSONRequestBody, reqEditors ...RequestEditorFn) (*StartupScriptsAssignResponse, error)

	// StartupScriptsUnassignWithBodyWithResponse request with any body
	StartupScriptsUnassignWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartupScriptsUnassignResponse, error)

	StartupScriptsUnassignWithResponse(ctx context.Context, id string, body StartupScriptsUnassignJSONRequestBody, reqEditors ...RequestEditorFn) (*StartupScriptsUnassignResponse, error)

	// StorageProvidersListWithResponse request
	StorageProvidersListWithResponse(ctx context.Context, params *StorageProvidersListParams, reqEditors ...RequestEditorFn) (*StorageProvidersListResponse, error)

	// StorageProvidersCreateWithBodyWithResponse request with any body
	StorageProvidersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StorageProvidersCreateResponse, error)

	StorageProvidersCreateWithResponse(ctx context.Context, body StorageProvidersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*StorageProvidersCreateResponse, error)

	// StorageUtilizationGetPublicWithResponse request
	StorageUtilizationGetPublicWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StorageUtilizationGetPublicResponse, error)

	// StorageProvidersDeleteWithResponse request
	StorageProvidersDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*StorageProvidersDeleteResponse, error)

	// StorageProvidersGetWithResponse request
	StorageProvidersGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*StorageProvidersGetResponse, error)

	// StorageProvidersUpdateWithBodyWithResponse request with any body
	StorageProvidersUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StorageProvidersUpdateResponse, error)

	StorageProvidersUpdateWithResponse(ctx context.Context, id string, body StorageProvidersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*StorageProvidersUpdateResponse, error)

	// TeamSecretsListWithResponse request
	TeamSecretsListWithResponse(ctx context.Context, id string, params *TeamSecretsListParams, reqEditors ...RequestEditorFn) (*TeamSecretsListResponse, error)

	// TeamSecretsCreateWithBodyWithResponse request with any body
	TeamSecretsCreateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamSecretsCreateResponse, error)

	TeamSecretsCreateWithResponse(ctx context.Context, id string, body TeamSecretsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamSecretsCreateResponse, error)

	// TeamSecretsDeleteWithResponse request
	TeamSecretsDeleteWithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*TeamSecretsDeleteResponse, error)

	// TeamSecretsGetWithResponse request
	TeamSecretsGetWithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*TeamSecretsGetResponse, error)

	// TeamSecretsUpdateWithBodyWithResponse request with any body
	TeamSecretsUpdateWithBodyWithResponse(ctx context.Context, id string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamSecretsUpdateResponse, error)

	TeamSecretsUpdateWithResponse(ctx context.Context, id string, name string, body TeamSecretsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamSecretsUpdateResponse, error)

	// TeamMembershipsListByTeamIdWithResponse request
	TeamMembershipsListByTeamIdWithResponse(ctx context.Context, teamId string, params *TeamMembershipsListByTeamIdParams, reqEditors ...RequestEditorFn) (*TeamMembershipsListByTeamIdResponse, error)

	// TeamMembershipsRemoveUserWithResponse request
	TeamMembershipsRemoveUserWithResponse(ctx context.Context, teamId string, userId string, reqEditors ...RequestEditorFn) (*TeamMembershipsRemoveUserResponse, error)

	// TeamMembershipsUpdateWithBodyWithResponse request with any body
	TeamMembershipsUpdateWithBodyWithResponse(ctx context.Context, teamId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamMembershipsUpdateResponse, error)

	TeamMembershipsUpdateWithResponse(ctx context.Context, teamId string, userId string, body TeamMembershipsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamMembershipsUpdateResponse, error)
}

type AuthSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Team struct {
			// AnalyticsId An internal, numeric ID for the team
			AnalyticsId float32 `json:"analyticsId"`

			// Id A unique ID for the team
			Id string `json:"id"`

			// IsPrivate Whether the team is private or not
			IsPrivate bool `json:"isPrivate"`

			// MaxMachines The maximum number of machines
			MaxMachines float32 `json:"maxMachines"`

			// Namespace The namespace for the team
			Namespace string `json:"namespace"`
		} `json:"team"`
		User struct {
			// AnalyticsId An internal, numeric ID for the user
			AnalyticsId float32 `json:"analyticsId"`

			// DtConfirmed The date the account was confirmed
			DtConfirmed *time.Time `json:"dtConfirmed"`

			// DtCreated The date the user was created
			DtCreated time.Time `json:"dtCreated"`

			// Email The user's email address
			Email string `json:"email"`

			// FirstName The user's first name
			FirstName *string `json:"firstName"`

			// Id A unique ID for the user
			Id string `json:"id"`

			// IsPasswordAuthEnabled Whether the user has a password set
			IsPasswordAuthEnabled bool `json:"isPasswordAuthEnabled"`

			// IsPhoneVerified Whether the user's phone number has been verified
			IsPhoneVerified bool `json:"isPhoneVerified"`

			// IsQrCodeBasedMfaConfirmed Whether the user has a QR code based MFA confirmed
			IsQrCodeBasedMfaConfirmed bool `json:"isQrCodeBasedMfaConfirmed"`

			// IsQrCodeBasedMfaEnabled Whether the user has a QR code based MFA enabled
			IsQrCodeBasedMfaEnabled bool `json:"isQrCodeBasedMfaEnabled"`

			// LastName The user's last name
			LastName *string `json:"lastName"`

			// Metadata Metadata about the user
			Metadata struct {
				// CoreSurvey Core survey question-answer pairs
				CoreSurvey *map[string]string `json:"coreSurvey"`

				// GradientSurvey Gradient survey question-answer pairs
				GradientSurvey *map[string]string `json:"gradientSurvey"`

				// GraphcoreTermsAccepted Whether the user has accepted the Graphcore terms of service
				GraphcoreTermsAccepted *bool `json:"graphcoreTermsAccepted,omitempty"`

				// Tags Tags for the user
				Tags *string `json:"tags"`
			} `json:"metadata"`

			// Preferences The user's preferences
			Preferences *struct {
				DefaultProduct *string                             `json:"defaultProduct"`
				DefaultTeamId  *string                             `json:"defaultTeamId"`
				DisableHotkeys *bool                               `json:"disableHotkeys"`
				FontSize       *float32                            `json:"fontSize"`
				Theme          *AuthSession200UserPreferencesTheme `json:"theme"`
			} `json:"preferences"`

			// TeamMemberships The teams this user is a member of
			TeamMemberships []struct {
				// IsAdmin Whether the user is an admin of the team
				IsAdmin bool `json:"isAdmin"`

				// IsOwner Whether the user is the owner of the team
				IsOwner bool `json:"isOwner"`

				// Team The team the user is a member of
				Team struct {
					// DtCreated The date the team was created
					DtCreated time.Time `json:"dtCreated"`

					// Id The ID of the team
					Id string `json:"id"`

					// IsUserTeam Whether the team is the user's team
					IsUserTeam bool `json:"isUserTeam"`

					// Name The name of the team
					Name string `json:"name"`

					// Namespace The namespace of the team
					Namespace string `json:"namespace"`

					// PublicProfileImageUrl The URL of the team's profile image.
					PublicProfileImageUrl *string `json:"publicProfileImageUrl"`
				} `json:"team"`
			} `json:"teamMemberships"`
		} `json:"user"`
	}
	JSONDefault *Error
}
type AuthSession200UserPreferencesTheme string

// Status returns HTTPResponse.Status
func (r AuthSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ContainerRegistriesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// DtCreated The date the container registry was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the container registry was last modified
			DtModified time.Time `json:"dtModified"`

			// Id The id of the container registry.
			Id string `json:"id"`

			// Kind The kind of container registry
			Kind ContainerRegistriesList200ItemsKind `json:"kind"`

			// Name The name of the container registry.
			Name string `json:"name"`

			// Namespace The namespace of the container registry. See https://docs.digitalocean.com/products/container-registry/.
			Namespace string `json:"namespace"`

			// Url The URL of the container registry. See https://docs.digitalocean.com/products/container-registry/.
			Url string `json:"url"`

			// Username A username for the container registry. See https://docs.digitalocean.com/products/container-registry/.
			Username string `json:"username"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}
type ContainerRegistriesList200ItemsKind string

// Status returns HTTPResponse.Status
func (r ContainerRegistriesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ContainerRegistriesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ContainerRegistriesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the container registry was created
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the container registry was last modified
		DtModified time.Time `json:"dtModified"`

		// Id The id of the container registry.
		Id string `json:"id"`

		// Kind The kind of container registry
		Kind ContainerRegistriesCreate200Kind `json:"kind"`

		// Name The name of the container registry.
		Name string `json:"name"`

		// Namespace The namespace of the container registry. See https://docs.digitalocean.com/products/container-registry/.
		Namespace string `json:"namespace"`

		// Url The URL of the container registry. See https://docs.digitalocean.com/products/container-registry/.
		Url string `json:"url"`

		// Username A username for the container registry. See https://docs.digitalocean.com/products/container-registry/.
		Username string `json:"username"`
	}
	JSONDefault *Error
}
type ContainerRegistriesCreate200Kind string

// Status returns HTTPResponse.Status
func (r ContainerRegistriesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ContainerRegistriesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ContainerRegistriesDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the container registry was created
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the container registry was last modified
		DtModified time.Time `json:"dtModified"`

		// Id The id of the container registry.
		Id string `json:"id"`

		// Kind The kind of container registry
		Kind ContainerRegistriesDelete200Kind `json:"kind"`

		// Name The name of the container registry.
		Name string `json:"name"`

		// Namespace The namespace of the container registry. See https://docs.digitalocean.com/products/container-registry/.
		Namespace string `json:"namespace"`

		// Url The URL of the container registry. See https://docs.digitalocean.com/products/container-registry/.
		Url string `json:"url"`

		// Username A username for the container registry. See https://docs.digitalocean.com/products/container-registry/.
		Username string `json:"username"`
	}
	JSONDefault *Error
}
type ContainerRegistriesDelete200Kind string

// Status returns HTTPResponse.Status
func (r ContainerRegistriesDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ContainerRegistriesDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ContainerRegistriesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the container registry was created
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the container registry was last modified
		DtModified time.Time `json:"dtModified"`

		// Id The id of the container registry.
		Id string `json:"id"`

		// Kind The kind of container registry
		Kind ContainerRegistriesGet200Kind `json:"kind"`

		// Name The name of the container registry.
		Name string `json:"name"`

		// Namespace The namespace of the container registry. See https://docs.digitalocean.com/products/container-registry/.
		Namespace string `json:"namespace"`

		// Url The URL of the container registry. See https://docs.digitalocean.com/products/container-registry/.
		Url string `json:"url"`

		// Username A username for the container registry. See https://docs.digitalocean.com/products/container-registry/.
		Username string `json:"username"`
	}
	JSONDefault *Error
}
type ContainerRegistriesGet200Kind string

// Status returns HTTPResponse.Status
func (r ContainerRegistriesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ContainerRegistriesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ContainerRegistriesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the container registry was created
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the container registry was last modified
		DtModified time.Time `json:"dtModified"`

		// Id The id of the container registry.
		Id string `json:"id"`

		// Kind The kind of container registry
		Kind ContainerRegistriesUpdate200Kind `json:"kind"`

		// Name The name of the container registry.
		Name string `json:"name"`

		// Namespace The namespace of the container registry. See https://docs.digitalocean.com/products/container-registry/.
		Namespace string `json:"namespace"`

		// Url The URL of the container registry. See https://docs.digitalocean.com/products/container-registry/.
		Url string `json:"url"`

		// Username A username for the container registry. See https://docs.digitalocean.com/products/container-registry/.
		Username string `json:"username"`
	}
	JSONDefault *Error
}
type ContainerRegistriesUpdate200Kind string

// Status returns HTTPResponse.Status
func (r ContainerRegistriesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ContainerRegistriesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ContainerRegistriesTestConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Error The error message, if any
		Error *string `json:"error,omitempty"`

		// Success Whether the connection was successful
		Success bool `json:"success"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ContainerRegistriesTestConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ContainerRegistriesTestConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomTemplatesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// AgentType The type of agent installed on the template.
			AgentType string `json:"agentType"`

			// AvailableMachineTypes The machine types the template is available on.
			AvailableMachineTypes []struct {
				// IsAvailable Whether the template is available on this machine type.
				IsAvailable bool `json:"isAvailable"`

				// MachineTypeLabel The label of the machine type.
				MachineTypeLabel string `json:"machineTypeLabel"`
			} `json:"availableMachineTypes"`

			// DefaultSizeGb The default size of the template in gigabytes.
			DefaultSizeGb CustomTemplatesList_200_Items_DefaultSizeGb `json:"defaultSizeGb"`

			// DtCreated The date the template was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the shared drive was deleted.
			DtDeleted *CustomTemplatesList_200_Items_DtDeleted `json:"dtDeleted"`

			// Id The ID of the template.
			Id string `json:"id"`

			// Name The name of the template.
			Name string `json:"name"`

			// OperatingSystemLabel The operating system installed on the template.
			OperatingSystemLabel string `json:"operatingSystemLabel"`

			// ParentMachineId The ID of the parent machine.
			ParentMachineId string `json:"parentMachineId"`

			// Region The region the template is in.
			Region CustomTemplatesList_200_Items_Region `json:"region"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}
type CustomTemplatesList200ItemsDefaultSizeGb0 float32
type CustomTemplatesList200ItemsDefaultSizeGb1 float32
type CustomTemplatesList200ItemsDefaultSizeGb2 float32
type CustomTemplatesList200ItemsDefaultSizeGb3 float32
type CustomTemplatesList200ItemsDefaultSizeGb4 float32
type CustomTemplatesList200ItemsDefaultSizeGb5 float32
type CustomTemplatesList200ItemsDefaultSizeGb6 float32
type CustomTemplatesList200ItemsDefaultSizeGb7 float32
type CustomTemplatesList200ItemsDefaultSizeGb8 float32
type CustomTemplatesList200ItemsDefaultSizeGb9 float32
type CustomTemplatesList200ItemsDefaultSizeGb10 = float32
type CustomTemplatesList_200_Items_DefaultSizeGb struct {
	union json.RawMessage
}
type CustomTemplatesList200ItemsDtDeleted0 = interface{}
type CustomTemplatesList200ItemsDtDeleted1 = time.Time
type CustomTemplatesList_200_Items_DtDeleted struct {
	union json.RawMessage
}
type CustomTemplatesList200ItemsRegion0 string
type CustomTemplatesList200ItemsRegion1 string
type CustomTemplatesList200ItemsRegion2 string
type CustomTemplatesList200ItemsRegion3 = string
type CustomTemplatesList_200_Items_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r CustomTemplatesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomTemplatesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomTemplatesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The template.
		Data struct {
			// AgentType The type of agent installed on the template.
			AgentType string `json:"agentType"`

			// AvailableMachineTypes The machine types the template is available on.
			AvailableMachineTypes []struct {
				// IsAvailable Whether the template is available on this machine type.
				IsAvailable bool `json:"isAvailable"`

				// MachineTypeLabel The label of the machine type.
				MachineTypeLabel string `json:"machineTypeLabel"`
			} `json:"availableMachineTypes"`

			// DefaultSizeGb The default size of the template in gigabytes.
			DefaultSizeGb CustomTemplatesCreate_200_Data_DefaultSizeGb `json:"defaultSizeGb"`

			// DtCreated The date the template was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the shared drive was deleted.
			DtDeleted *CustomTemplatesCreate_200_Data_DtDeleted `json:"dtDeleted"`

			// Id The ID of the template.
			Id string `json:"id"`

			// Name The name of the template.
			Name string `json:"name"`

			// OperatingSystemLabel The operating system installed on the template.
			OperatingSystemLabel string `json:"operatingSystemLabel"`

			// ParentMachineId The ID of the parent machine.
			ParentMachineId string `json:"parentMachineId"`

			// Region The region the template is in.
			Region CustomTemplatesCreate_200_Data_Region `json:"region"`
		} `json:"data"`

		// Event The machine event to poll for the async operation.
		Event struct {
			// DtCreated The date the event was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtFinished The date the event was finished.
			DtFinished *time.Time `json:"dtFinished"`

			// DtStarted The date the event was started.
			DtStarted *time.Time `json:"dtStarted"`

			// Error The error message of the event, if any.
			Error *string `json:"error"`

			// Id The ID of the event.
			Id string `json:"id"`

			// MachineId The ID of the machine the event is for.
			MachineId *string `json:"machineId"`

			// Name The name of the event, e.g. "create".
			Name CustomTemplatesCreate200EventName `json:"name"`

			// State The state of the event, e.g. "done".
			State CustomTemplatesCreate200EventState `json:"state"`
		} `json:"event"`
	}
	JSONDefault *Error
}
type CustomTemplatesCreate200DataDefaultSizeGb0 float32
type CustomTemplatesCreate200DataDefaultSizeGb1 float32
type CustomTemplatesCreate200DataDefaultSizeGb2 float32
type CustomTemplatesCreate200DataDefaultSizeGb3 float32
type CustomTemplatesCreate200DataDefaultSizeGb4 float32
type CustomTemplatesCreate200DataDefaultSizeGb5 float32
type CustomTemplatesCreate200DataDefaultSizeGb6 float32
type CustomTemplatesCreate200DataDefaultSizeGb7 float32
type CustomTemplatesCreate200DataDefaultSizeGb8 float32
type CustomTemplatesCreate200DataDefaultSizeGb9 float32
type CustomTemplatesCreate200DataDefaultSizeGb10 = float32
type CustomTemplatesCreate_200_Data_DefaultSizeGb struct {
	union json.RawMessage
}
type CustomTemplatesCreate200DataDtDeleted0 = interface{}
type CustomTemplatesCreate200DataDtDeleted1 = time.Time
type CustomTemplatesCreate_200_Data_DtDeleted struct {
	union json.RawMessage
}
type CustomTemplatesCreate200DataRegion0 string
type CustomTemplatesCreate200DataRegion1 string
type CustomTemplatesCreate200DataRegion2 string
type CustomTemplatesCreate200DataRegion3 = string
type CustomTemplatesCreate_200_Data_Region struct {
	union json.RawMessage
}
type CustomTemplatesCreate200EventName string
type CustomTemplatesCreate200EventState string

// Status returns HTTPResponse.Status
func (r CustomTemplatesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomTemplatesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomTemplatesDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AgentType The type of agent installed on the template.
		AgentType string `json:"agentType"`

		// AvailableMachineTypes The machine types the template is available on.
		AvailableMachineTypes []struct {
			// IsAvailable Whether the template is available on this machine type.
			IsAvailable bool `json:"isAvailable"`

			// MachineTypeLabel The label of the machine type.
			MachineTypeLabel string `json:"machineTypeLabel"`
		} `json:"availableMachineTypes"`

		// DefaultSizeGb The default size of the template in gigabytes.
		DefaultSizeGb CustomTemplatesDelete_200_DefaultSizeGb `json:"defaultSizeGb"`

		// DtCreated The date the template was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the shared drive was deleted.
		DtDeleted *CustomTemplatesDelete_200_DtDeleted `json:"dtDeleted"`

		// Id The ID of the template.
		Id string `json:"id"`

		// Name The name of the template.
		Name string `json:"name"`

		// OperatingSystemLabel The operating system installed on the template.
		OperatingSystemLabel string `json:"operatingSystemLabel"`

		// ParentMachineId The ID of the parent machine.
		ParentMachineId string `json:"parentMachineId"`

		// Region The region the template is in.
		Region CustomTemplatesDelete_200_Region `json:"region"`
	}
	JSONDefault *Error
}
type CustomTemplatesDelete200DefaultSizeGb0 float32
type CustomTemplatesDelete200DefaultSizeGb1 float32
type CustomTemplatesDelete200DefaultSizeGb2 float32
type CustomTemplatesDelete200DefaultSizeGb3 float32
type CustomTemplatesDelete200DefaultSizeGb4 float32
type CustomTemplatesDelete200DefaultSizeGb5 float32
type CustomTemplatesDelete200DefaultSizeGb6 float32
type CustomTemplatesDelete200DefaultSizeGb7 float32
type CustomTemplatesDelete200DefaultSizeGb8 float32
type CustomTemplatesDelete200DefaultSizeGb9 float32
type CustomTemplatesDelete200DefaultSizeGb10 = float32
type CustomTemplatesDelete_200_DefaultSizeGb struct {
	union json.RawMessage
}
type CustomTemplatesDelete200DtDeleted0 = interface{}
type CustomTemplatesDelete200DtDeleted1 = time.Time
type CustomTemplatesDelete_200_DtDeleted struct {
	union json.RawMessage
}
type CustomTemplatesDelete200Region0 string
type CustomTemplatesDelete200Region1 string
type CustomTemplatesDelete200Region2 string
type CustomTemplatesDelete200Region3 = string
type CustomTemplatesDelete_200_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r CustomTemplatesDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomTemplatesDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomTemplatesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AgentType The type of agent installed on the template.
		AgentType string `json:"agentType"`

		// AvailableMachineTypes The machine types the template is available on.
		AvailableMachineTypes []struct {
			// IsAvailable Whether the template is available on this machine type.
			IsAvailable bool `json:"isAvailable"`

			// MachineTypeLabel The label of the machine type.
			MachineTypeLabel string `json:"machineTypeLabel"`
		} `json:"availableMachineTypes"`

		// DefaultSizeGb The default size of the template in gigabytes.
		DefaultSizeGb CustomTemplatesGet_200_DefaultSizeGb `json:"defaultSizeGb"`

		// DtCreated The date the template was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the shared drive was deleted.
		DtDeleted *CustomTemplatesGet_200_DtDeleted `json:"dtDeleted"`

		// Id The ID of the template.
		Id string `json:"id"`

		// Name The name of the template.
		Name string `json:"name"`

		// OperatingSystemLabel The operating system installed on the template.
		OperatingSystemLabel string `json:"operatingSystemLabel"`

		// ParentMachineId The ID of the parent machine.
		ParentMachineId string `json:"parentMachineId"`

		// Region The region the template is in.
		Region CustomTemplatesGet_200_Region `json:"region"`
	}
	JSONDefault *Error
}
type CustomTemplatesGet200DefaultSizeGb0 float32
type CustomTemplatesGet200DefaultSizeGb1 float32
type CustomTemplatesGet200DefaultSizeGb2 float32
type CustomTemplatesGet200DefaultSizeGb3 float32
type CustomTemplatesGet200DefaultSizeGb4 float32
type CustomTemplatesGet200DefaultSizeGb5 float32
type CustomTemplatesGet200DefaultSizeGb6 float32
type CustomTemplatesGet200DefaultSizeGb7 float32
type CustomTemplatesGet200DefaultSizeGb8 float32
type CustomTemplatesGet200DefaultSizeGb9 float32
type CustomTemplatesGet200DefaultSizeGb10 = float32
type CustomTemplatesGet_200_DefaultSizeGb struct {
	union json.RawMessage
}
type CustomTemplatesGet200DtDeleted0 = interface{}
type CustomTemplatesGet200DtDeleted1 = time.Time
type CustomTemplatesGet_200_DtDeleted struct {
	union json.RawMessage
}
type CustomTemplatesGet200Region0 string
type CustomTemplatesGet200Region1 string
type CustomTemplatesGet200Region2 string
type CustomTemplatesGet200Region3 = string
type CustomTemplatesGet_200_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r CustomTemplatesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomTemplatesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomTemplatesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AgentType The type of agent installed on the template.
		AgentType string `json:"agentType"`

		// AvailableMachineTypes The machine types the template is available on.
		AvailableMachineTypes []struct {
			// IsAvailable Whether the template is available on this machine type.
			IsAvailable bool `json:"isAvailable"`

			// MachineTypeLabel The label of the machine type.
			MachineTypeLabel string `json:"machineTypeLabel"`
		} `json:"availableMachineTypes"`

		// DefaultSizeGb The default size of the template in gigabytes.
		DefaultSizeGb CustomTemplatesUpdate_200_DefaultSizeGb `json:"defaultSizeGb"`

		// DtCreated The date the template was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the shared drive was deleted.
		DtDeleted *CustomTemplatesUpdate_200_DtDeleted `json:"dtDeleted"`

		// Id The ID of the template.
		Id string `json:"id"`

		// Name The name of the template.
		Name string `json:"name"`

		// OperatingSystemLabel The operating system installed on the template.
		OperatingSystemLabel string `json:"operatingSystemLabel"`

		// ParentMachineId The ID of the parent machine.
		ParentMachineId string `json:"parentMachineId"`

		// Region The region the template is in.
		Region CustomTemplatesUpdate_200_Region `json:"region"`
	}
	JSONDefault *Error
}
type CustomTemplatesUpdate200DefaultSizeGb0 float32
type CustomTemplatesUpdate200DefaultSizeGb1 float32
type CustomTemplatesUpdate200DefaultSizeGb2 float32
type CustomTemplatesUpdate200DefaultSizeGb3 float32
type CustomTemplatesUpdate200DefaultSizeGb4 float32
type CustomTemplatesUpdate200DefaultSizeGb5 float32
type CustomTemplatesUpdate200DefaultSizeGb6 float32
type CustomTemplatesUpdate200DefaultSizeGb7 float32
type CustomTemplatesUpdate200DefaultSizeGb8 float32
type CustomTemplatesUpdate200DefaultSizeGb9 float32
type CustomTemplatesUpdate200DefaultSizeGb10 = float32
type CustomTemplatesUpdate_200_DefaultSizeGb struct {
	union json.RawMessage
}
type CustomTemplatesUpdate200DtDeleted0 = interface{}
type CustomTemplatesUpdate200DtDeleted1 = time.Time
type CustomTemplatesUpdate_200_DtDeleted struct {
	union json.RawMessage
}
type CustomTemplatesUpdate200Region0 string
type CustomTemplatesUpdate200Region1 string
type CustomTemplatesUpdate200Region2 string
type CustomTemplatesUpdate200Region3 = string
type CustomTemplatesUpdate_200_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r CustomTemplatesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomTemplatesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// Description The description of the dataset
			Description *string `json:"description"`

			// DtCreated The date the dataset was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the dataset was last modified
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the dataset
			Id string `json:"id"`

			// IsPublic Whether the dataset is public
			IsPublic bool `json:"isPublic"`

			// Name The name of the dataset
			Name *string `json:"name"`

			// StorageProviderId The ID of the storage provider
			StorageProviderId *string `json:"storageProviderId"`

			// TeamId The ID of the team that owns the dataset
			TeamId string `json:"teamId"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DatasetsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Description The description of the dataset
		Description *string `json:"description"`

		// DtCreated The date the dataset was created
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the dataset was last modified
		DtModified time.Time `json:"dtModified"`

		// Id The ID of the dataset
		Id string `json:"id"`

		// IsPublic Whether the dataset is public
		IsPublic bool `json:"isPublic"`

		// Name The name of the dataset
		Name *string `json:"name"`

		// StorageProviderId The ID of the storage provider
		StorageProviderId *string `json:"storageProviderId"`

		// TeamId The ID of the team that owns the dataset
		TeamId string `json:"teamId"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DatasetsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetVersionsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// DatasetId The ID of the dataset
			DatasetId string `json:"datasetId"`

			// DtCreated The date the version was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the version was last modified
			DtModified time.Time `json:"dtModified"`

			// IsCommitted Whether the version is committed
			IsCommitted bool `json:"isCommitted"`

			// Message The description of the dataset version
			Message *string `json:"message"`

			// Metadata Metadata for the version.
			Metadata *map[string]interface{} `json:"metadata"`

			// Tags The tags for the version
			Tags []string `json:"tags"`

			// Url The URL of the version
			Url *string `json:"url"`

			// UsageBytes The size of the dataset at this version in bytes
			UsageBytes *string `json:"usageBytes"`

			// UserId The ID of the user that created the version
			UserId *string `json:"userId"`

			// Version The version of the dataset
			Version string `json:"version"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DatasetVersionsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetVersionsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetVersionsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DatasetId The ID of the dataset
		DatasetId string `json:"datasetId"`

		// DtCreated The date the version was created
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the version was last modified
		DtModified time.Time `json:"dtModified"`

		// IsCommitted Whether the version is committed
		IsCommitted bool `json:"isCommitted"`

		// Message The description of the dataset version
		Message *string `json:"message"`

		// Metadata Metadata for the version.
		Metadata *map[string]interface{} `json:"metadata"`

		// Tags The tags for the version
		Tags []string `json:"tags"`

		// Url The URL of the version
		Url *string `json:"url"`

		// UsageBytes The size of the dataset at this version in bytes
		UsageBytes *string `json:"usageBytes"`

		// UserId The ID of the user that created the version
		UserId *string `json:"userId"`

		// Version The version of the dataset
		Version string `json:"version"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DatasetVersionsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetVersionsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetVersionsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DatasetId The ID of the dataset
		DatasetId string `json:"datasetId"`

		// Version The version of the dataset
		Version string `json:"version"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DatasetVersionsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetVersionsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetVersionsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DatasetId The ID of the dataset
		DatasetId string `json:"datasetId"`

		// DtCreated The date the version was created
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the version was last modified
		DtModified time.Time `json:"dtModified"`

		// IsCommitted Whether the version is committed
		IsCommitted bool `json:"isCommitted"`

		// Message The description of the dataset version
		Message *string `json:"message"`

		// Metadata Metadata for the version.
		Metadata *map[string]interface{} `json:"metadata"`

		// Tags The tags for the version
		Tags []string `json:"tags"`

		// Url The URL of the version
		Url *string `json:"url"`

		// UsageBytes The size of the dataset at this version in bytes
		UsageBytes *string `json:"usageBytes"`

		// UserId The ID of the user that created the version
		UserId *string `json:"userId"`

		// Version The version of the dataset
		Version string `json:"version"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DatasetVersionsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetVersionsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetVersionsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DatasetId The ID of the dataset
		DatasetId string `json:"datasetId"`

		// DtCreated The date the version was created
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the version was last modified
		DtModified time.Time `json:"dtModified"`

		// IsCommitted Whether the version is committed
		IsCommitted bool `json:"isCommitted"`

		// Message The description of the dataset version
		Message *string `json:"message"`

		// Metadata Metadata for the version.
		Metadata *map[string]interface{} `json:"metadata"`

		// Tags The tags for the version
		Tags []string `json:"tags"`

		// Url The URL of the version
		Url *string `json:"url"`

		// UsageBytes The size of the dataset at this version in bytes
		UsageBytes *string `json:"usageBytes"`

		// UserId The ID of the user that created the version
		UserId *string `json:"userId"`

		// Version The version of the dataset
		Version string `json:"version"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DatasetVersionsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetVersionsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The ID of the dataset
		Id string `json:"id"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DatasetsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Description The description of the dataset
		Description *string `json:"description"`

		// DtCreated The date the dataset was created
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the dataset was last modified
		DtModified time.Time `json:"dtModified"`

		// Id The ID of the dataset
		Id string `json:"id"`

		// IsPublic Whether the dataset is public
		IsPublic bool `json:"isPublic"`

		// Name The name of the dataset
		Name *string `json:"name"`

		// StorageProviderId The ID of the storage provider
		StorageProviderId *string `json:"storageProviderId"`

		// TeamId The ID of the team that owns the dataset
		TeamId string `json:"teamId"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DatasetsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Description The description of the dataset
		Description *string `json:"description"`

		// DtCreated The date the dataset was created
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the dataset was last modified
		DtModified time.Time `json:"dtModified"`

		// Id The ID of the dataset
		Id string `json:"id"`

		// IsPublic Whether the dataset is public
		IsPublic bool `json:"isPublic"`

		// Name The name of the dataset
		Name *string `json:"name"`

		// StorageProviderId The ID of the storage provider
		StorageProviderId *string `json:"storageProviderId"`

		// TeamId The ID of the team that owns the dataset
		TeamId string `json:"teamId"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DatasetsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeploymentsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// BasicAuthKey The endpoint security key for the deployment
			BasicAuthKey *string `json:"basicAuthKey"`

			// DtCreated The date the deployment was created
			DtCreated time.Time `json:"dtCreated"`

			// Endpoint The unique endpoint for the deployment
			Endpoint string `json:"endpoint"`

			// Id The ID of the deployment
			Id string `json:"id"`

			// LatestSpec The latest deployment configuration. If invalid, null is returned.
			LatestSpec *struct {
				// Data The data for the deployment spec
				Data *DeploymentsList_200_Items_LatestSpec_Data `json:"data"`

				// DeploymentId The ID of the deployment the spec belongs to
				DeploymentId string `json:"deploymentId"`

				// DtHealthy The date the deployment was marked "healthy"
				DtHealthy *time.Time `json:"dtHealthy"`

				// Error The fatal configuration error. Only present if the cluster was unable to apply the entire deployment configuration. This is not the same as an instance error.
				Error *string `json:"error"`

				// ExternalApplied The date the deployment configuration was applied to the cluster
				ExternalApplied *time.Time `json:"externalApplied"`

				// Id The ID of the deployment spec
				Id string `json:"id"`

				// Metadata Metadata about the source of the configuration
				Metadata *struct {
					GitHeaders *struct {
						XGitActor string                                                            `json:"x-git-actor"`
						XGitHost  DeploymentsList_200_Items_LatestSpec_Metadata_GitHeaders_XGitHost `json:"x-git-host"`
						XGitOwner string                                                            `json:"x-git-owner"`
						XGitRef   string                                                            `json:"x-git-ref"`
						XGitRepo  string                                                            `json:"x-git-repo"`
						XGitSha   string                                                            `json:"x-git-sha"`
					} `json:"gitHeaders,omitempty"`
				} `json:"metadata"`

				// UserId The ID of the user the deployment belongs to
				UserId string `json:"userId"`
			} `json:"latestSpec"`

			// LatestSpecHash The last version hash for the deployment
			LatestSpecHash *string `json:"latestSpecHash"`

			// Name The name of the deployment
			Name string `json:"name"`

			// ProjectId The ID of the project the deployment belongs to
			ProjectId string `json:"projectId"`

			// TeamId The ID of the team the deployment belongs to
			TeamId string `json:"teamId"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}
type DeploymentsList200ItemsLatestSpecData0 struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData00 struct {
	ApiVersion        DeploymentsList200ItemsLatestSpecData00ApiVersion `json:"apiVersion"`
	Command           *[]string                                         `json:"command,omitempty"`
	ContainerRegistry *string                                           `json:"containerRegistry,omitempty"`
	Enabled           *bool                                             `json:"enabled,omitempty"`
	Env               *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"env,omitempty"`
	HealthChecks *struct {
		Liveness  *DeploymentsList_200_Items_LatestSpec_Data_0_0_HealthChecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentsList_200_Items_LatestSpec_Data_0_0_HealthChecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentsList_200_Items_LatestSpec_Data_0_0_HealthChecks_Startup   `json:"startup,omitempty"`
	} `json:"healthChecks,omitempty"`
	Image  string `json:"image"`
	Models *[]struct {
		Id   string  `json:"id"`
		Path *string `json:"path,omitempty"`
	} `json:"models,omitempty"`
	Name         string                                                `json:"name"`
	Port         *float32                                              `json:"port,omitempty"`
	Region       *DeploymentsList_200_Items_LatestSpec_Data_0_0_Region `json:"region,omitempty"`
	Repositories *struct {
		Dataset      string  `json:"dataset"`
		MountPath    *string `json:"mountPath,omitempty"`
		Repositories []struct {
			Name     string  `json:"name"`
			Password *string `json:"password,omitempty"`
			Ref      *string `json:"ref,omitempty"`
			Url      string  `json:"url"`
			Username *string `json:"username,omitempty"`
		} `json:"repositories"`
	} `json:"repositories,omitempty"`
	Resources struct {
		Autoscaling *struct {
			Enabled     *bool                                                                              `json:"enabled,omitempty"`
			MaxReplicas float32                                                                            `json:"maxReplicas"`
			Metrics     []DeploymentsList_200_Items_LatestSpec_Data_0_0_Resources_Autoscaling_Metrics_Item `json:"metrics"`
		} `json:"autoscaling,omitempty"`
		InstanceType string   `json:"instanceType"`
		Replicas     *float32 `json:"replicas,omitempty"`
	} `json:"resources"`
}
type DeploymentsList200ItemsLatestSpecData00ApiVersion string
type DeploymentsList200ItemsLatestSpecData00HealthChecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList200ItemsLatestSpecData00HealthChecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList_200_Items_LatestSpec_Data_0_0_HealthChecks_Liveness struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData00HealthChecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList200ItemsLatestSpecData00HealthChecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList_200_Items_LatestSpec_Data_0_0_HealthChecks_Readiness struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData00HealthChecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList200ItemsLatestSpecData00HealthChecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList_200_Items_LatestSpec_Data_0_0_HealthChecks_Startup struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData00Region0 string
type DeploymentsList200ItemsLatestSpecData00Region1 string
type DeploymentsList200ItemsLatestSpecData00Region2 string
type DeploymentsList200ItemsLatestSpecData00Region3 = string
type DeploymentsList_200_Items_LatestSpec_Data_0_0_Region struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics0 struct {
	Metric  DeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics0Metric  `json:"metric"`
	Summary DeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics0Summary `json:"summary"`
	Value   float32                                                                    `json:"value"`
}
type DeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics0Metric string
type DeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics0Summary string
type DeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics1 struct {
	Metric  DeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics1Metric  `json:"metric"`
	Summary DeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics1Summary `json:"summary"`
	Value   int                                                                        `json:"value"`
}
type DeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics1Metric string
type DeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics1Summary string
type DeploymentsList_200_Items_LatestSpec_Data_0_0_Resources_Autoscaling_Metrics_Item struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData01 struct {
	ApiVersion        DeploymentsList200ItemsLatestSpecData01ApiVersion `json:"apiVersion"`
	BasicAuthKey      *string                                           `json:"basicAuthKey,omitempty"`
	Command           *[]string                                         `json:"command,omitempty"`
	ContainerRegistry *string                                           `json:"containerRegistry,omitempty"`
	Enabled           *bool                                             `json:"enabled,omitempty"`
	Env               *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"env,omitempty"`
	HealthChecks *struct {
		Liveness  *DeploymentsList_200_Items_LatestSpec_Data_0_1_HealthChecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentsList_200_Items_LatestSpec_Data_0_1_HealthChecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentsList_200_Items_LatestSpec_Data_0_1_HealthChecks_Startup   `json:"startup,omitempty"`
	} `json:"healthChecks,omitempty"`
	Healthchecks *struct {
		Liveness  *DeploymentsList_200_Items_LatestSpec_Data_0_1_Healthchecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentsList_200_Items_LatestSpec_Data_0_1_Healthchecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentsList_200_Items_LatestSpec_Data_0_1_Healthchecks_Startup   `json:"startup,omitempty"`
	} `json:"healthchecks,omitempty"`
	Image        string                                                             `json:"image"`
	Integrations *[]DeploymentsList_200_Items_LatestSpec_Data_0_1_Integrations_Item `json:"integrations,omitempty"`
	Name         string                                                             `json:"name"`
	Region       *DeploymentsList_200_Items_LatestSpec_Data_0_1_Region              `json:"region,omitempty"`
	Resources    struct {
		Autoscaling *struct {
			Enabled     *bool                                                                              `json:"enabled,omitempty"`
			MaxReplicas float32                                                                            `json:"maxReplicas"`
			Metrics     []DeploymentsList_200_Items_LatestSpec_Data_0_1_Resources_Autoscaling_Metrics_Item `json:"metrics"`
		} `json:"autoscaling,omitempty"`
		MachineType string    `json:"machineType"`
		Ports       []float32 `json:"ports"`
		Replicas    *float32  `json:"replicas,omitempty"`
	} `json:"resources"`
}
type DeploymentsList200ItemsLatestSpecData01ApiVersion string
type DeploymentsList200ItemsLatestSpecData01HealthChecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList200ItemsLatestSpecData01HealthChecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList_200_Items_LatestSpec_Data_0_1_HealthChecks_Liveness struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData01HealthChecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList200ItemsLatestSpecData01HealthChecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList_200_Items_LatestSpec_Data_0_1_HealthChecks_Readiness struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData01HealthChecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList200ItemsLatestSpecData01HealthChecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList_200_Items_LatestSpec_Data_0_1_HealthChecks_Startup struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData01HealthchecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList200ItemsLatestSpecData01HealthchecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList_200_Items_LatestSpec_Data_0_1_Healthchecks_Liveness struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData01HealthchecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList200ItemsLatestSpecData01HealthchecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList_200_Items_LatestSpec_Data_0_1_Healthchecks_Readiness struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData01HealthchecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList200ItemsLatestSpecData01HealthchecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList_200_Items_LatestSpec_Data_0_1_Healthchecks_Startup struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData01Integrations0 struct {
	Id   string                                                   `json:"id"`
	Name string                                                   `json:"name"`
	Path *string                                                  `json:"path,omitempty"`
	Type DeploymentsList200ItemsLatestSpecData01Integrations0Type `json:"type"`
}
type DeploymentsList200ItemsLatestSpecData01Integrations0Type string
type DeploymentsList200ItemsLatestSpecData01Integrations1 struct {
	AccessKeyId     *string                                                              `json:"accessKeyId,omitempty"`
	Endpoint        *string                                                              `json:"endpoint,omitempty"`
	Name            string                                                               `json:"name"`
	Path            *string                                                              `json:"path,omitempty"`
	Region          *DeploymentsList_200_Items_LatestSpec_Data_0_1_Integrations_1_Region `json:"region,omitempty"`
	SecretAccessKey *string                                                              `json:"secretAccessKey,omitempty"`
	Type            DeploymentsList200ItemsLatestSpecData01Integrations1Type             `json:"type"`
	Url             string                                                               `json:"url"`
}
type DeploymentsList200ItemsLatestSpecData01Integrations1Region0 string
type DeploymentsList200ItemsLatestSpecData01Integrations1Region1 string
type DeploymentsList200ItemsLatestSpecData01Integrations1Region2 string
type DeploymentsList200ItemsLatestSpecData01Integrations1Region3 = string
type DeploymentsList_200_Items_LatestSpec_Data_0_1_Integrations_1_Region struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData01Integrations1Type string
type DeploymentsList200ItemsLatestSpecData01Integrations2 struct {
	AccessKeyId     *string                                                  `json:"accessKeyId,omitempty"`
	Endpoint        string                                                   `json:"endpoint"`
	Name            string                                                   `json:"name"`
	Path            *string                                                  `json:"path,omitempty"`
	SecretAccessKey *string                                                  `json:"secretAccessKey,omitempty"`
	Type            DeploymentsList200ItemsLatestSpecData01Integrations2Type `json:"type"`
}
type DeploymentsList200ItemsLatestSpecData01Integrations2Type string
type DeploymentsList200ItemsLatestSpecData01Integrations3 struct {
	Name string                                                   `json:"name"`
	Type DeploymentsList200ItemsLatestSpecData01Integrations3Type `json:"type"`
}
type DeploymentsList200ItemsLatestSpecData01Integrations3Type string
type DeploymentsList200ItemsLatestSpecData01Integrations4 struct {
	Name string                                                   `json:"name"`
	Path *string                                                  `json:"path,omitempty"`
	Type DeploymentsList200ItemsLatestSpecData01Integrations4Type `json:"type"`
	Url  string                                                   `json:"url"`
}
type DeploymentsList200ItemsLatestSpecData01Integrations4Type string
type DeploymentsList_200_Items_LatestSpec_Data_0_1_Integrations_Item struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData01Region0 string
type DeploymentsList200ItemsLatestSpecData01Region1 string
type DeploymentsList200ItemsLatestSpecData01Region2 string
type DeploymentsList200ItemsLatestSpecData01Region3 = string
type DeploymentsList_200_Items_LatestSpec_Data_0_1_Region struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics0 struct {
	Metric  DeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics0Metric  `json:"metric"`
	Summary DeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics0Summary `json:"summary"`
	Value   float32                                                                    `json:"value"`
}
type DeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics0Metric string
type DeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics0Summary string
type DeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics1 struct {
	Metric  DeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics1Metric  `json:"metric"`
	Summary DeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics1Summary `json:"summary"`
	Value   int                                                                        `json:"value"`
}
type DeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics1Metric string
type DeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics1Summary string
type DeploymentsList_200_Items_LatestSpec_Data_0_1_Resources_Autoscaling_Metrics_Item struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData1 struct {
	ApiVersion        DeploymentsList_200_Items_LatestSpec_Data_1_ApiVersion `json:"apiVersion"`
	BasicAuthKey      *string                                                `json:"basicAuthKey,omitempty"`
	Command           *[]string                                              `json:"command,omitempty"`
	ContainerRegistry *string                                                `json:"containerRegistry,omitempty"`
	Enabled           *bool                                                  `json:"enabled,omitempty"`
	Env               *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"env,omitempty"`
	HealthChecks *struct {
		Liveness  *DeploymentsList_200_Items_LatestSpec_Data_1_HealthChecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentsList_200_Items_LatestSpec_Data_1_HealthChecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentsList_200_Items_LatestSpec_Data_1_HealthChecks_Startup   `json:"startup,omitempty"`
	} `json:"healthChecks,omitempty"`
	Healthchecks *struct {
		Liveness  *DeploymentsList_200_Items_LatestSpec_Data_1_Healthchecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentsList_200_Items_LatestSpec_Data_1_Healthchecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentsList_200_Items_LatestSpec_Data_1_Healthchecks_Startup   `json:"startup,omitempty"`
	} `json:"healthchecks,omitempty"`
	Image        string                                                           `json:"image"`
	Integrations *[]DeploymentsList_200_Items_LatestSpec_Data_1_Integrations_Item `json:"integrations,omitempty"`
	Name         string                                                           `json:"name"`
	Region       *DeploymentsList_200_Items_LatestSpec_Data_1_Region              `json:"region,omitempty"`
	Resources    struct {
		Autoscaling *struct {
			Enabled     *bool                                                                            `json:"enabled,omitempty"`
			MaxReplicas float32                                                                          `json:"maxReplicas"`
			Metrics     []DeploymentsList_200_Items_LatestSpec_Data_1_Resources_Autoscaling_Metrics_Item `json:"metrics"`
		} `json:"autoscaling,omitempty"`
		MachineType string    `json:"machineType"`
		Ports       []float32 `json:"ports"`
		Replicas    *float32  `json:"replicas,omitempty"`
	} `json:"resources"`
}
type DeploymentsList200ItemsLatestSpecData1ApiVersion0 string
type DeploymentsList200ItemsLatestSpecData1ApiVersion1 string
type DeploymentsList_200_Items_LatestSpec_Data_1_ApiVersion struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData1HealthChecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList200ItemsLatestSpecData1HealthChecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList_200_Items_LatestSpec_Data_1_HealthChecks_Liveness struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData1HealthChecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList200ItemsLatestSpecData1HealthChecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList_200_Items_LatestSpec_Data_1_HealthChecks_Readiness struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData1HealthChecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList200ItemsLatestSpecData1HealthChecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList_200_Items_LatestSpec_Data_1_HealthChecks_Startup struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData1HealthchecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList200ItemsLatestSpecData1HealthchecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList_200_Items_LatestSpec_Data_1_Healthchecks_Liveness struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData1HealthchecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList200ItemsLatestSpecData1HealthchecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList_200_Items_LatestSpec_Data_1_Healthchecks_Readiness struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData1HealthchecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList200ItemsLatestSpecData1HealthchecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsList_200_Items_LatestSpec_Data_1_Healthchecks_Startup struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData1Integrations0 struct {
	Id   string                                                  `json:"id"`
	Name string                                                  `json:"name"`
	Path *string                                                 `json:"path,omitempty"`
	Type DeploymentsList200ItemsLatestSpecData1Integrations0Type `json:"type"`
}
type DeploymentsList200ItemsLatestSpecData1Integrations0Type string
type DeploymentsList200ItemsLatestSpecData1Integrations1 struct {
	AccessKeyId     *string                                                            `json:"accessKeyId,omitempty"`
	Endpoint        *string                                                            `json:"endpoint,omitempty"`
	Name            string                                                             `json:"name"`
	Path            *string                                                            `json:"path,omitempty"`
	Region          *DeploymentsList_200_Items_LatestSpec_Data_1_Integrations_1_Region `json:"region,omitempty"`
	SecretAccessKey *string                                                            `json:"secretAccessKey,omitempty"`
	Type            DeploymentsList200ItemsLatestSpecData1Integrations1Type            `json:"type"`
	Url             string                                                             `json:"url"`
}
type DeploymentsList200ItemsLatestSpecData1Integrations1Region0 string
type DeploymentsList200ItemsLatestSpecData1Integrations1Region1 string
type DeploymentsList200ItemsLatestSpecData1Integrations1Region2 string
type DeploymentsList200ItemsLatestSpecData1Integrations1Region3 = string
type DeploymentsList_200_Items_LatestSpec_Data_1_Integrations_1_Region struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData1Integrations1Type string
type DeploymentsList200ItemsLatestSpecData1Integrations2 struct {
	AccessKeyId     *string                                                 `json:"accessKeyId,omitempty"`
	Endpoint        string                                                  `json:"endpoint"`
	Name            string                                                  `json:"name"`
	Path            *string                                                 `json:"path,omitempty"`
	SecretAccessKey *string                                                 `json:"secretAccessKey,omitempty"`
	Type            DeploymentsList200ItemsLatestSpecData1Integrations2Type `json:"type"`
}
type DeploymentsList200ItemsLatestSpecData1Integrations2Type string
type DeploymentsList200ItemsLatestSpecData1Integrations3 struct {
	Name string                                                  `json:"name"`
	Type DeploymentsList200ItemsLatestSpecData1Integrations3Type `json:"type"`
}
type DeploymentsList200ItemsLatestSpecData1Integrations3Type string
type DeploymentsList200ItemsLatestSpecData1Integrations4 struct {
	Name string                                                  `json:"name"`
	Path *string                                                 `json:"path,omitempty"`
	Type DeploymentsList200ItemsLatestSpecData1Integrations4Type `json:"type"`
	Url  string                                                  `json:"url"`
}
type DeploymentsList200ItemsLatestSpecData1Integrations4Type string
type DeploymentsList_200_Items_LatestSpec_Data_1_Integrations_Item struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData1Region0 string
type DeploymentsList200ItemsLatestSpecData1Region1 string
type DeploymentsList200ItemsLatestSpecData1Region2 string
type DeploymentsList200ItemsLatestSpecData1Region3 = string
type DeploymentsList_200_Items_LatestSpec_Data_1_Region struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics0 struct {
	Metric  DeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics0Metric  `json:"metric"`
	Summary DeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics0Summary `json:"summary"`
	Value   float32                                                                   `json:"value"`
}
type DeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics0Metric string
type DeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics0Summary string
type DeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics1 struct {
	Metric  DeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics1Metric  `json:"metric"`
	Summary DeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics1Summary `json:"summary"`
	Value   int                                                                       `json:"value"`
}
type DeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics1Metric string
type DeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics1Summary string
type DeploymentsList_200_Items_LatestSpec_Data_1_Resources_Autoscaling_Metrics_Item struct {
	union json.RawMessage
}
type DeploymentsList_200_Items_LatestSpec_Data struct {
	union json.RawMessage
}
type DeploymentsList200ItemsLatestSpecMetadataGitHeadersXGitHost0 string
type DeploymentsList200ItemsLatestSpecMetadataGitHeadersXGitHost1 string
type DeploymentsList_200_Items_LatestSpec_Metadata_GitHeaders_XGitHost struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeploymentsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeploymentsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeploymentsUpsertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DeploymentId The ID of the deployment
		DeploymentId string `json:"deploymentId"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DeploymentsUpsertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeploymentsUpsertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeploymentsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The ID of the deleted deployment
		Id string `json:"id"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DeploymentsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeploymentsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeploymentsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BasicAuthKey The endpoint security key for the deployment
		BasicAuthKey *string `json:"basicAuthKey"`

		// DtCreated The date the deployment was created
		DtCreated time.Time `json:"dtCreated"`

		// Endpoint The unique endpoint for the deployment
		Endpoint string `json:"endpoint"`

		// Id The ID of the deployment
		Id string `json:"id"`

		// LatestSpec The latest deployment configuration. If invalid, null is returned.
		LatestSpec *struct {
			// Data The data for the deployment spec
			Data *DeploymentsGet_200_LatestSpec_Data `json:"data"`

			// DeploymentId The ID of the deployment the spec belongs to
			DeploymentId string `json:"deploymentId"`

			// DtHealthy The date the deployment was marked "healthy"
			DtHealthy *time.Time `json:"dtHealthy"`

			// Error The fatal configuration error. Only present if the cluster was unable to apply the entire deployment configuration. This is not the same as an instance error.
			Error *string `json:"error"`

			// ExternalApplied The date the deployment configuration was applied to the cluster
			ExternalApplied *time.Time `json:"externalApplied"`

			// Id The ID of the deployment spec
			Id string `json:"id"`

			// Metadata Metadata about the source of the configuration
			Metadata *struct {
				GitHeaders *struct {
					XGitActor string                                                     `json:"x-git-actor"`
					XGitHost  DeploymentsGet_200_LatestSpec_Metadata_GitHeaders_XGitHost `json:"x-git-host"`
					XGitOwner string                                                     `json:"x-git-owner"`
					XGitRef   string                                                     `json:"x-git-ref"`
					XGitRepo  string                                                     `json:"x-git-repo"`
					XGitSha   string                                                     `json:"x-git-sha"`
				} `json:"gitHeaders,omitempty"`
			} `json:"metadata"`

			// UserId The ID of the user the deployment belongs to
			UserId string `json:"userId"`
		} `json:"latestSpec"`

		// LatestSpecHash The last version hash for the deployment
		LatestSpecHash *string `json:"latestSpecHash"`

		// Name The name of the deployment
		Name string `json:"name"`

		// ProjectId The ID of the project the deployment belongs to
		ProjectId string `json:"projectId"`

		// TeamId The ID of the team the deployment belongs to
		TeamId string `json:"teamId"`
	}
	JSONDefault *Error
}
type DeploymentsGet200LatestSpecData0 struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData00 struct {
	ApiVersion        DeploymentsGet200LatestSpecData00ApiVersion `json:"apiVersion"`
	Command           *[]string                                   `json:"command,omitempty"`
	ContainerRegistry *string                                     `json:"containerRegistry,omitempty"`
	Enabled           *bool                                       `json:"enabled,omitempty"`
	Env               *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"env,omitempty"`
	HealthChecks *struct {
		Liveness  *DeploymentsGet_200_LatestSpec_Data_0_0_HealthChecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentsGet_200_LatestSpec_Data_0_0_HealthChecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentsGet_200_LatestSpec_Data_0_0_HealthChecks_Startup   `json:"startup,omitempty"`
	} `json:"healthChecks,omitempty"`
	Image  string `json:"image"`
	Models *[]struct {
		Id   string  `json:"id"`
		Path *string `json:"path,omitempty"`
	} `json:"models,omitempty"`
	Name         string                                         `json:"name"`
	Port         *float32                                       `json:"port,omitempty"`
	Region       *DeploymentsGet_200_LatestSpec_Data_0_0_Region `json:"region,omitempty"`
	Repositories *struct {
		Dataset      string  `json:"dataset"`
		MountPath    *string `json:"mountPath,omitempty"`
		Repositories []struct {
			Name     string  `json:"name"`
			Password *string `json:"password,omitempty"`
			Ref      *string `json:"ref,omitempty"`
			Url      string  `json:"url"`
			Username *string `json:"username,omitempty"`
		} `json:"repositories"`
	} `json:"repositories,omitempty"`
	Resources struct {
		Autoscaling *struct {
			Enabled     *bool                                                                       `json:"enabled,omitempty"`
			MaxReplicas float32                                                                     `json:"maxReplicas"`
			Metrics     []DeploymentsGet_200_LatestSpec_Data_0_0_Resources_Autoscaling_Metrics_Item `json:"metrics"`
		} `json:"autoscaling,omitempty"`
		InstanceType string   `json:"instanceType"`
		Replicas     *float32 `json:"replicas,omitempty"`
	} `json:"resources"`
}
type DeploymentsGet200LatestSpecData00ApiVersion string
type DeploymentsGet200LatestSpecData00HealthChecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet200LatestSpecData00HealthChecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet_200_LatestSpec_Data_0_0_HealthChecks_Liveness struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData00HealthChecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet200LatestSpecData00HealthChecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet_200_LatestSpec_Data_0_0_HealthChecks_Readiness struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData00HealthChecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet200LatestSpecData00HealthChecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet_200_LatestSpec_Data_0_0_HealthChecks_Startup struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData00Region0 string
type DeploymentsGet200LatestSpecData00Region1 string
type DeploymentsGet200LatestSpecData00Region2 string
type DeploymentsGet200LatestSpecData00Region3 = string
type DeploymentsGet_200_LatestSpec_Data_0_0_Region struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData00ResourcesAutoscalingMetrics0 struct {
	Metric  DeploymentsGet200LatestSpecData00ResourcesAutoscalingMetrics0Metric  `json:"metric"`
	Summary DeploymentsGet200LatestSpecData00ResourcesAutoscalingMetrics0Summary `json:"summary"`
	Value   float32                                                              `json:"value"`
}
type DeploymentsGet200LatestSpecData00ResourcesAutoscalingMetrics0Metric string
type DeploymentsGet200LatestSpecData00ResourcesAutoscalingMetrics0Summary string
type DeploymentsGet200LatestSpecData00ResourcesAutoscalingMetrics1 struct {
	Metric  DeploymentsGet200LatestSpecData00ResourcesAutoscalingMetrics1Metric  `json:"metric"`
	Summary DeploymentsGet200LatestSpecData00ResourcesAutoscalingMetrics1Summary `json:"summary"`
	Value   int                                                                  `json:"value"`
}
type DeploymentsGet200LatestSpecData00ResourcesAutoscalingMetrics1Metric string
type DeploymentsGet200LatestSpecData00ResourcesAutoscalingMetrics1Summary string
type DeploymentsGet_200_LatestSpec_Data_0_0_Resources_Autoscaling_Metrics_Item struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData01 struct {
	ApiVersion        DeploymentsGet200LatestSpecData01ApiVersion `json:"apiVersion"`
	BasicAuthKey      *string                                     `json:"basicAuthKey,omitempty"`
	Command           *[]string                                   `json:"command,omitempty"`
	ContainerRegistry *string                                     `json:"containerRegistry,omitempty"`
	Enabled           *bool                                       `json:"enabled,omitempty"`
	Env               *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"env,omitempty"`
	HealthChecks *struct {
		Liveness  *DeploymentsGet_200_LatestSpec_Data_0_1_HealthChecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentsGet_200_LatestSpec_Data_0_1_HealthChecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentsGet_200_LatestSpec_Data_0_1_HealthChecks_Startup   `json:"startup,omitempty"`
	} `json:"healthChecks,omitempty"`
	Healthchecks *struct {
		Liveness  *DeploymentsGet_200_LatestSpec_Data_0_1_Healthchecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentsGet_200_LatestSpec_Data_0_1_Healthchecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentsGet_200_LatestSpec_Data_0_1_Healthchecks_Startup   `json:"startup,omitempty"`
	} `json:"healthchecks,omitempty"`
	Image        string                                                      `json:"image"`
	Integrations *[]DeploymentsGet_200_LatestSpec_Data_0_1_Integrations_Item `json:"integrations,omitempty"`
	Name         string                                                      `json:"name"`
	Region       *DeploymentsGet_200_LatestSpec_Data_0_1_Region              `json:"region,omitempty"`
	Resources    struct {
		Autoscaling *struct {
			Enabled     *bool                                                                       `json:"enabled,omitempty"`
			MaxReplicas float32                                                                     `json:"maxReplicas"`
			Metrics     []DeploymentsGet_200_LatestSpec_Data_0_1_Resources_Autoscaling_Metrics_Item `json:"metrics"`
		} `json:"autoscaling,omitempty"`
		MachineType string    `json:"machineType"`
		Ports       []float32 `json:"ports"`
		Replicas    *float32  `json:"replicas,omitempty"`
	} `json:"resources"`
}
type DeploymentsGet200LatestSpecData01ApiVersion string
type DeploymentsGet200LatestSpecData01HealthChecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet200LatestSpecData01HealthChecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet_200_LatestSpec_Data_0_1_HealthChecks_Liveness struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData01HealthChecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet200LatestSpecData01HealthChecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet_200_LatestSpec_Data_0_1_HealthChecks_Readiness struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData01HealthChecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet200LatestSpecData01HealthChecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet_200_LatestSpec_Data_0_1_HealthChecks_Startup struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData01HealthchecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet200LatestSpecData01HealthchecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet_200_LatestSpec_Data_0_1_Healthchecks_Liveness struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData01HealthchecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet200LatestSpecData01HealthchecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet_200_LatestSpec_Data_0_1_Healthchecks_Readiness struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData01HealthchecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet200LatestSpecData01HealthchecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet_200_LatestSpec_Data_0_1_Healthchecks_Startup struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData01Integrations0 struct {
	Id   string                                             `json:"id"`
	Name string                                             `json:"name"`
	Path *string                                            `json:"path,omitempty"`
	Type DeploymentsGet200LatestSpecData01Integrations0Type `json:"type"`
}
type DeploymentsGet200LatestSpecData01Integrations0Type string
type DeploymentsGet200LatestSpecData01Integrations1 struct {
	AccessKeyId     *string                                                       `json:"accessKeyId,omitempty"`
	Endpoint        *string                                                       `json:"endpoint,omitempty"`
	Name            string                                                        `json:"name"`
	Path            *string                                                       `json:"path,omitempty"`
	Region          *DeploymentsGet_200_LatestSpec_Data_0_1_Integrations_1_Region `json:"region,omitempty"`
	SecretAccessKey *string                                                       `json:"secretAccessKey,omitempty"`
	Type            DeploymentsGet200LatestSpecData01Integrations1Type            `json:"type"`
	Url             string                                                        `json:"url"`
}
type DeploymentsGet200LatestSpecData01Integrations1Region0 string
type DeploymentsGet200LatestSpecData01Integrations1Region1 string
type DeploymentsGet200LatestSpecData01Integrations1Region2 string
type DeploymentsGet200LatestSpecData01Integrations1Region3 = string
type DeploymentsGet_200_LatestSpec_Data_0_1_Integrations_1_Region struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData01Integrations1Type string
type DeploymentsGet200LatestSpecData01Integrations2 struct {
	AccessKeyId     *string                                            `json:"accessKeyId,omitempty"`
	Endpoint        string                                             `json:"endpoint"`
	Name            string                                             `json:"name"`
	Path            *string                                            `json:"path,omitempty"`
	SecretAccessKey *string                                            `json:"secretAccessKey,omitempty"`
	Type            DeploymentsGet200LatestSpecData01Integrations2Type `json:"type"`
}
type DeploymentsGet200LatestSpecData01Integrations2Type string
type DeploymentsGet200LatestSpecData01Integrations3 struct {
	Name string                                             `json:"name"`
	Type DeploymentsGet200LatestSpecData01Integrations3Type `json:"type"`
}
type DeploymentsGet200LatestSpecData01Integrations3Type string
type DeploymentsGet200LatestSpecData01Integrations4 struct {
	Name string                                             `json:"name"`
	Path *string                                            `json:"path,omitempty"`
	Type DeploymentsGet200LatestSpecData01Integrations4Type `json:"type"`
	Url  string                                             `json:"url"`
}
type DeploymentsGet200LatestSpecData01Integrations4Type string
type DeploymentsGet_200_LatestSpec_Data_0_1_Integrations_Item struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData01Region0 string
type DeploymentsGet200LatestSpecData01Region1 string
type DeploymentsGet200LatestSpecData01Region2 string
type DeploymentsGet200LatestSpecData01Region3 = string
type DeploymentsGet_200_LatestSpec_Data_0_1_Region struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData01ResourcesAutoscalingMetrics0 struct {
	Metric  DeploymentsGet200LatestSpecData01ResourcesAutoscalingMetrics0Metric  `json:"metric"`
	Summary DeploymentsGet200LatestSpecData01ResourcesAutoscalingMetrics0Summary `json:"summary"`
	Value   float32                                                              `json:"value"`
}
type DeploymentsGet200LatestSpecData01ResourcesAutoscalingMetrics0Metric string
type DeploymentsGet200LatestSpecData01ResourcesAutoscalingMetrics0Summary string
type DeploymentsGet200LatestSpecData01ResourcesAutoscalingMetrics1 struct {
	Metric  DeploymentsGet200LatestSpecData01ResourcesAutoscalingMetrics1Metric  `json:"metric"`
	Summary DeploymentsGet200LatestSpecData01ResourcesAutoscalingMetrics1Summary `json:"summary"`
	Value   int                                                                  `json:"value"`
}
type DeploymentsGet200LatestSpecData01ResourcesAutoscalingMetrics1Metric string
type DeploymentsGet200LatestSpecData01ResourcesAutoscalingMetrics1Summary string
type DeploymentsGet_200_LatestSpec_Data_0_1_Resources_Autoscaling_Metrics_Item struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData1 struct {
	ApiVersion        DeploymentsGet_200_LatestSpec_Data_1_ApiVersion `json:"apiVersion"`
	BasicAuthKey      *string                                         `json:"basicAuthKey,omitempty"`
	Command           *[]string                                       `json:"command,omitempty"`
	ContainerRegistry *string                                         `json:"containerRegistry,omitempty"`
	Enabled           *bool                                           `json:"enabled,omitempty"`
	Env               *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"env,omitempty"`
	HealthChecks *struct {
		Liveness  *DeploymentsGet_200_LatestSpec_Data_1_HealthChecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentsGet_200_LatestSpec_Data_1_HealthChecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentsGet_200_LatestSpec_Data_1_HealthChecks_Startup   `json:"startup,omitempty"`
	} `json:"healthChecks,omitempty"`
	Healthchecks *struct {
		Liveness  *DeploymentsGet_200_LatestSpec_Data_1_Healthchecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentsGet_200_LatestSpec_Data_1_Healthchecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentsGet_200_LatestSpec_Data_1_Healthchecks_Startup   `json:"startup,omitempty"`
	} `json:"healthchecks,omitempty"`
	Image        string                                                    `json:"image"`
	Integrations *[]DeploymentsGet_200_LatestSpec_Data_1_Integrations_Item `json:"integrations,omitempty"`
	Name         string                                                    `json:"name"`
	Region       *DeploymentsGet_200_LatestSpec_Data_1_Region              `json:"region,omitempty"`
	Resources    struct {
		Autoscaling *struct {
			Enabled     *bool                                                                     `json:"enabled,omitempty"`
			MaxReplicas float32                                                                   `json:"maxReplicas"`
			Metrics     []DeploymentsGet_200_LatestSpec_Data_1_Resources_Autoscaling_Metrics_Item `json:"metrics"`
		} `json:"autoscaling,omitempty"`
		MachineType string    `json:"machineType"`
		Ports       []float32 `json:"ports"`
		Replicas    *float32  `json:"replicas,omitempty"`
	} `json:"resources"`
}
type DeploymentsGet200LatestSpecData1ApiVersion0 string
type DeploymentsGet200LatestSpecData1ApiVersion1 string
type DeploymentsGet_200_LatestSpec_Data_1_ApiVersion struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData1HealthChecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet200LatestSpecData1HealthChecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet_200_LatestSpec_Data_1_HealthChecks_Liveness struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData1HealthChecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet200LatestSpecData1HealthChecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet_200_LatestSpec_Data_1_HealthChecks_Readiness struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData1HealthChecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet200LatestSpecData1HealthChecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet_200_LatestSpec_Data_1_HealthChecks_Startup struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData1HealthchecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet200LatestSpecData1HealthchecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet_200_LatestSpec_Data_1_Healthchecks_Liveness struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData1HealthchecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet200LatestSpecData1HealthchecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet_200_LatestSpec_Data_1_Healthchecks_Readiness struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData1HealthchecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet200LatestSpecData1HealthchecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentsGet_200_LatestSpec_Data_1_Healthchecks_Startup struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData1Integrations0 struct {
	Id   string                                            `json:"id"`
	Name string                                            `json:"name"`
	Path *string                                           `json:"path,omitempty"`
	Type DeploymentsGet200LatestSpecData1Integrations0Type `json:"type"`
}
type DeploymentsGet200LatestSpecData1Integrations0Type string
type DeploymentsGet200LatestSpecData1Integrations1 struct {
	AccessKeyId     *string                                                     `json:"accessKeyId,omitempty"`
	Endpoint        *string                                                     `json:"endpoint,omitempty"`
	Name            string                                                      `json:"name"`
	Path            *string                                                     `json:"path,omitempty"`
	Region          *DeploymentsGet_200_LatestSpec_Data_1_Integrations_1_Region `json:"region,omitempty"`
	SecretAccessKey *string                                                     `json:"secretAccessKey,omitempty"`
	Type            DeploymentsGet200LatestSpecData1Integrations1Type           `json:"type"`
	Url             string                                                      `json:"url"`
}
type DeploymentsGet200LatestSpecData1Integrations1Region0 string
type DeploymentsGet200LatestSpecData1Integrations1Region1 string
type DeploymentsGet200LatestSpecData1Integrations1Region2 string
type DeploymentsGet200LatestSpecData1Integrations1Region3 = string
type DeploymentsGet_200_LatestSpec_Data_1_Integrations_1_Region struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData1Integrations1Type string
type DeploymentsGet200LatestSpecData1Integrations2 struct {
	AccessKeyId     *string                                           `json:"accessKeyId,omitempty"`
	Endpoint        string                                            `json:"endpoint"`
	Name            string                                            `json:"name"`
	Path            *string                                           `json:"path,omitempty"`
	SecretAccessKey *string                                           `json:"secretAccessKey,omitempty"`
	Type            DeploymentsGet200LatestSpecData1Integrations2Type `json:"type"`
}
type DeploymentsGet200LatestSpecData1Integrations2Type string
type DeploymentsGet200LatestSpecData1Integrations3 struct {
	Name string                                            `json:"name"`
	Type DeploymentsGet200LatestSpecData1Integrations3Type `json:"type"`
}
type DeploymentsGet200LatestSpecData1Integrations3Type string
type DeploymentsGet200LatestSpecData1Integrations4 struct {
	Name string                                            `json:"name"`
	Path *string                                           `json:"path,omitempty"`
	Type DeploymentsGet200LatestSpecData1Integrations4Type `json:"type"`
	Url  string                                            `json:"url"`
}
type DeploymentsGet200LatestSpecData1Integrations4Type string
type DeploymentsGet_200_LatestSpec_Data_1_Integrations_Item struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData1Region0 string
type DeploymentsGet200LatestSpecData1Region1 string
type DeploymentsGet200LatestSpecData1Region2 string
type DeploymentsGet200LatestSpecData1Region3 = string
type DeploymentsGet_200_LatestSpec_Data_1_Region struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecData1ResourcesAutoscalingMetrics0 struct {
	Metric  DeploymentsGet200LatestSpecData1ResourcesAutoscalingMetrics0Metric  `json:"metric"`
	Summary DeploymentsGet200LatestSpecData1ResourcesAutoscalingMetrics0Summary `json:"summary"`
	Value   float32                                                             `json:"value"`
}
type DeploymentsGet200LatestSpecData1ResourcesAutoscalingMetrics0Metric string
type DeploymentsGet200LatestSpecData1ResourcesAutoscalingMetrics0Summary string
type DeploymentsGet200LatestSpecData1ResourcesAutoscalingMetrics1 struct {
	Metric  DeploymentsGet200LatestSpecData1ResourcesAutoscalingMetrics1Metric  `json:"metric"`
	Summary DeploymentsGet200LatestSpecData1ResourcesAutoscalingMetrics1Summary `json:"summary"`
	Value   int                                                                 `json:"value"`
}
type DeploymentsGet200LatestSpecData1ResourcesAutoscalingMetrics1Metric string
type DeploymentsGet200LatestSpecData1ResourcesAutoscalingMetrics1Summary string
type DeploymentsGet_200_LatestSpec_Data_1_Resources_Autoscaling_Metrics_Item struct {
	union json.RawMessage
}
type DeploymentsGet_200_LatestSpec_Data struct {
	union json.RawMessage
}
type DeploymentsGet200LatestSpecMetadataGitHeadersXGitHost0 string
type DeploymentsGet200LatestSpecMetadataGitHeadersXGitHost1 string
type DeploymentsGet_200_LatestSpec_Metadata_GitHeaders_XGitHost struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeploymentsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeploymentsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeploymentHistoryListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// Data The data for the deployment spec
			Data *DeploymentHistoryList_200_Items_Data `json:"data"`

			// DeploymentId The ID of the deployment the spec belongs to
			DeploymentId string `json:"deploymentId"`

			// DtHealthy The date the deployment was marked "healthy"
			DtHealthy *time.Time `json:"dtHealthy"`

			// Error The fatal configuration error. Only present if the cluster was unable to apply the entire deployment configuration. This is not the same as an instance error.
			Error *string `json:"error"`

			// ExternalApplied The date the deployment configuration was applied to the cluster
			ExternalApplied *time.Time `json:"externalApplied"`

			// Id The ID of the deployment spec
			Id string `json:"id"`

			// Metadata Metadata about the source of the configuration
			Metadata *struct {
				GitHeaders *struct {
					XGitActor string                                                       `json:"x-git-actor"`
					XGitHost  DeploymentHistoryList_200_Items_Metadata_GitHeaders_XGitHost `json:"x-git-host"`
					XGitOwner string                                                       `json:"x-git-owner"`
					XGitRef   string                                                       `json:"x-git-ref"`
					XGitRepo  string                                                       `json:"x-git-repo"`
					XGitSha   string                                                       `json:"x-git-sha"`
				} `json:"gitHeaders,omitempty"`
			} `json:"metadata"`

			// UserId The ID of the user the deployment belongs to
			UserId      string `json:"userId"`
			WorkflowRun *struct {
				// DtCreated When the workflow run was created
				DtCreated *time.Time `json:"dtCreated"`

				// DtFinished When the workflow run finished
				DtFinished *time.Time `json:"dtFinished"`

				// DtStarted When the workflow run started
				DtStarted *time.Time `json:"dtStarted"`

				// Id The ID of the workflow run
				Id openapi_types.UUID `json:"id"`

				// Message The message of the workflow run
				Message *string `json:"message"`

				// Phase The phase of the workflow run
				Phase    DeploymentHistoryList200ItemsWorkflowRunPhase `json:"phase"`
				Workflow struct {
					// DtCreated When the workflow was created
					DtCreated *time.Time `json:"dtCreated"`

					// Id The ID of the workflow
					Id openapi_types.UUID `json:"id"`

					// Name The name of the workflow
					Name *string `json:"name"`
				} `json:"workflow"`

				// WorkflowId The ID of the workflow
				WorkflowId openapi_types.UUID `json:"workflowId"`
			} `json:"workflowRun"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}
type DeploymentHistoryList200ItemsData0 struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData00 struct {
	ApiVersion        DeploymentHistoryList200ItemsData00ApiVersion `json:"apiVersion"`
	Command           *[]string                                     `json:"command,omitempty"`
	ContainerRegistry *string                                       `json:"containerRegistry,omitempty"`
	Enabled           *bool                                         `json:"enabled,omitempty"`
	Env               *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"env,omitempty"`
	HealthChecks *struct {
		Liveness  *DeploymentHistoryList_200_Items_Data_0_0_HealthChecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentHistoryList_200_Items_Data_0_0_HealthChecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentHistoryList_200_Items_Data_0_0_HealthChecks_Startup   `json:"startup,omitempty"`
	} `json:"healthChecks,omitempty"`
	Image  string `json:"image"`
	Models *[]struct {
		Id   string  `json:"id"`
		Path *string `json:"path,omitempty"`
	} `json:"models,omitempty"`
	Name         string                                           `json:"name"`
	Port         *float32                                         `json:"port,omitempty"`
	Region       *DeploymentHistoryList_200_Items_Data_0_0_Region `json:"region,omitempty"`
	Repositories *struct {
		Dataset      string  `json:"dataset"`
		MountPath    *string `json:"mountPath,omitempty"`
		Repositories []struct {
			Name     string  `json:"name"`
			Password *string `json:"password,omitempty"`
			Ref      *string `json:"ref,omitempty"`
			Url      string  `json:"url"`
			Username *string `json:"username,omitempty"`
		} `json:"repositories"`
	} `json:"repositories,omitempty"`
	Resources struct {
		Autoscaling *struct {
			Enabled     *bool                                                                         `json:"enabled,omitempty"`
			MaxReplicas float32                                                                       `json:"maxReplicas"`
			Metrics     []DeploymentHistoryList_200_Items_Data_0_0_Resources_Autoscaling_Metrics_Item `json:"metrics"`
		} `json:"autoscaling,omitempty"`
		InstanceType string   `json:"instanceType"`
		Replicas     *float32 `json:"replicas,omitempty"`
	} `json:"resources"`
}
type DeploymentHistoryList200ItemsData00ApiVersion string
type DeploymentHistoryList200ItemsData00HealthChecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList200ItemsData00HealthChecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList_200_Items_Data_0_0_HealthChecks_Liveness struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData00HealthChecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList200ItemsData00HealthChecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList_200_Items_Data_0_0_HealthChecks_Readiness struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData00HealthChecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList200ItemsData00HealthChecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList_200_Items_Data_0_0_HealthChecks_Startup struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData00Region0 string
type DeploymentHistoryList200ItemsData00Region1 string
type DeploymentHistoryList200ItemsData00Region2 string
type DeploymentHistoryList200ItemsData00Region3 = string
type DeploymentHistoryList_200_Items_Data_0_0_Region struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData00ResourcesAutoscalingMetrics0 struct {
	Metric  DeploymentHistoryList200ItemsData00ResourcesAutoscalingMetrics0Metric  `json:"metric"`
	Summary DeploymentHistoryList200ItemsData00ResourcesAutoscalingMetrics0Summary `json:"summary"`
	Value   float32                                                                `json:"value"`
}
type DeploymentHistoryList200ItemsData00ResourcesAutoscalingMetrics0Metric string
type DeploymentHistoryList200ItemsData00ResourcesAutoscalingMetrics0Summary string
type DeploymentHistoryList200ItemsData00ResourcesAutoscalingMetrics1 struct {
	Metric  DeploymentHistoryList200ItemsData00ResourcesAutoscalingMetrics1Metric  `json:"metric"`
	Summary DeploymentHistoryList200ItemsData00ResourcesAutoscalingMetrics1Summary `json:"summary"`
	Value   int                                                                    `json:"value"`
}
type DeploymentHistoryList200ItemsData00ResourcesAutoscalingMetrics1Metric string
type DeploymentHistoryList200ItemsData00ResourcesAutoscalingMetrics1Summary string
type DeploymentHistoryList_200_Items_Data_0_0_Resources_Autoscaling_Metrics_Item struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData01 struct {
	ApiVersion        DeploymentHistoryList200ItemsData01ApiVersion `json:"apiVersion"`
	BasicAuthKey      *string                                       `json:"basicAuthKey,omitempty"`
	Command           *[]string                                     `json:"command,omitempty"`
	ContainerRegistry *string                                       `json:"containerRegistry,omitempty"`
	Enabled           *bool                                         `json:"enabled,omitempty"`
	Env               *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"env,omitempty"`
	HealthChecks *struct {
		Liveness  *DeploymentHistoryList_200_Items_Data_0_1_HealthChecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentHistoryList_200_Items_Data_0_1_HealthChecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentHistoryList_200_Items_Data_0_1_HealthChecks_Startup   `json:"startup,omitempty"`
	} `json:"healthChecks,omitempty"`
	Healthchecks *struct {
		Liveness  *DeploymentHistoryList_200_Items_Data_0_1_Healthchecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentHistoryList_200_Items_Data_0_1_Healthchecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentHistoryList_200_Items_Data_0_1_Healthchecks_Startup   `json:"startup,omitempty"`
	} `json:"healthchecks,omitempty"`
	Image        string                                                        `json:"image"`
	Integrations *[]DeploymentHistoryList_200_Items_Data_0_1_Integrations_Item `json:"integrations,omitempty"`
	Name         string                                                        `json:"name"`
	Region       *DeploymentHistoryList_200_Items_Data_0_1_Region              `json:"region,omitempty"`
	Resources    struct {
		Autoscaling *struct {
			Enabled     *bool                                                                         `json:"enabled,omitempty"`
			MaxReplicas float32                                                                       `json:"maxReplicas"`
			Metrics     []DeploymentHistoryList_200_Items_Data_0_1_Resources_Autoscaling_Metrics_Item `json:"metrics"`
		} `json:"autoscaling,omitempty"`
		MachineType string    `json:"machineType"`
		Ports       []float32 `json:"ports"`
		Replicas    *float32  `json:"replicas,omitempty"`
	} `json:"resources"`
}
type DeploymentHistoryList200ItemsData01ApiVersion string
type DeploymentHistoryList200ItemsData01HealthChecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList200ItemsData01HealthChecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList_200_Items_Data_0_1_HealthChecks_Liveness struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData01HealthChecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList200ItemsData01HealthChecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList_200_Items_Data_0_1_HealthChecks_Readiness struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData01HealthChecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList200ItemsData01HealthChecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList_200_Items_Data_0_1_HealthChecks_Startup struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData01HealthchecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList200ItemsData01HealthchecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList_200_Items_Data_0_1_Healthchecks_Liveness struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData01HealthchecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList200ItemsData01HealthchecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList_200_Items_Data_0_1_Healthchecks_Readiness struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData01HealthchecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList200ItemsData01HealthchecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList_200_Items_Data_0_1_Healthchecks_Startup struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData01Integrations0 struct {
	Id   string                                               `json:"id"`
	Name string                                               `json:"name"`
	Path *string                                              `json:"path,omitempty"`
	Type DeploymentHistoryList200ItemsData01Integrations0Type `json:"type"`
}
type DeploymentHistoryList200ItemsData01Integrations0Type string
type DeploymentHistoryList200ItemsData01Integrations1 struct {
	AccessKeyId     *string                                                         `json:"accessKeyId,omitempty"`
	Endpoint        *string                                                         `json:"endpoint,omitempty"`
	Name            string                                                          `json:"name"`
	Path            *string                                                         `json:"path,omitempty"`
	Region          *DeploymentHistoryList_200_Items_Data_0_1_Integrations_1_Region `json:"region,omitempty"`
	SecretAccessKey *string                                                         `json:"secretAccessKey,omitempty"`
	Type            DeploymentHistoryList200ItemsData01Integrations1Type            `json:"type"`
	Url             string                                                          `json:"url"`
}
type DeploymentHistoryList200ItemsData01Integrations1Region0 string
type DeploymentHistoryList200ItemsData01Integrations1Region1 string
type DeploymentHistoryList200ItemsData01Integrations1Region2 string
type DeploymentHistoryList200ItemsData01Integrations1Region3 = string
type DeploymentHistoryList_200_Items_Data_0_1_Integrations_1_Region struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData01Integrations1Type string
type DeploymentHistoryList200ItemsData01Integrations2 struct {
	AccessKeyId     *string                                              `json:"accessKeyId,omitempty"`
	Endpoint        string                                               `json:"endpoint"`
	Name            string                                               `json:"name"`
	Path            *string                                              `json:"path,omitempty"`
	SecretAccessKey *string                                              `json:"secretAccessKey,omitempty"`
	Type            DeploymentHistoryList200ItemsData01Integrations2Type `json:"type"`
}
type DeploymentHistoryList200ItemsData01Integrations2Type string
type DeploymentHistoryList200ItemsData01Integrations3 struct {
	Name string                                               `json:"name"`
	Type DeploymentHistoryList200ItemsData01Integrations3Type `json:"type"`
}
type DeploymentHistoryList200ItemsData01Integrations3Type string
type DeploymentHistoryList200ItemsData01Integrations4 struct {
	Name string                                               `json:"name"`
	Path *string                                              `json:"path,omitempty"`
	Type DeploymentHistoryList200ItemsData01Integrations4Type `json:"type"`
	Url  string                                               `json:"url"`
}
type DeploymentHistoryList200ItemsData01Integrations4Type string
type DeploymentHistoryList_200_Items_Data_0_1_Integrations_Item struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData01Region0 string
type DeploymentHistoryList200ItemsData01Region1 string
type DeploymentHistoryList200ItemsData01Region2 string
type DeploymentHistoryList200ItemsData01Region3 = string
type DeploymentHistoryList_200_Items_Data_0_1_Region struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData01ResourcesAutoscalingMetrics0 struct {
	Metric  DeploymentHistoryList200ItemsData01ResourcesAutoscalingMetrics0Metric  `json:"metric"`
	Summary DeploymentHistoryList200ItemsData01ResourcesAutoscalingMetrics0Summary `json:"summary"`
	Value   float32                                                                `json:"value"`
}
type DeploymentHistoryList200ItemsData01ResourcesAutoscalingMetrics0Metric string
type DeploymentHistoryList200ItemsData01ResourcesAutoscalingMetrics0Summary string
type DeploymentHistoryList200ItemsData01ResourcesAutoscalingMetrics1 struct {
	Metric  DeploymentHistoryList200ItemsData01ResourcesAutoscalingMetrics1Metric  `json:"metric"`
	Summary DeploymentHistoryList200ItemsData01ResourcesAutoscalingMetrics1Summary `json:"summary"`
	Value   int                                                                    `json:"value"`
}
type DeploymentHistoryList200ItemsData01ResourcesAutoscalingMetrics1Metric string
type DeploymentHistoryList200ItemsData01ResourcesAutoscalingMetrics1Summary string
type DeploymentHistoryList_200_Items_Data_0_1_Resources_Autoscaling_Metrics_Item struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData1 struct {
	ApiVersion        DeploymentHistoryList_200_Items_Data_1_ApiVersion `json:"apiVersion"`
	BasicAuthKey      *string                                           `json:"basicAuthKey,omitempty"`
	Command           *[]string                                         `json:"command,omitempty"`
	ContainerRegistry *string                                           `json:"containerRegistry,omitempty"`
	Enabled           *bool                                             `json:"enabled,omitempty"`
	Env               *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"env,omitempty"`
	HealthChecks *struct {
		Liveness  *DeploymentHistoryList_200_Items_Data_1_HealthChecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentHistoryList_200_Items_Data_1_HealthChecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentHistoryList_200_Items_Data_1_HealthChecks_Startup   `json:"startup,omitempty"`
	} `json:"healthChecks,omitempty"`
	Healthchecks *struct {
		Liveness  *DeploymentHistoryList_200_Items_Data_1_Healthchecks_Liveness  `json:"liveness,omitempty"`
		Readiness *DeploymentHistoryList_200_Items_Data_1_Healthchecks_Readiness `json:"readiness,omitempty"`
		Startup   *DeploymentHistoryList_200_Items_Data_1_Healthchecks_Startup   `json:"startup,omitempty"`
	} `json:"healthchecks,omitempty"`
	Image        string                                                      `json:"image"`
	Integrations *[]DeploymentHistoryList_200_Items_Data_1_Integrations_Item `json:"integrations,omitempty"`
	Name         string                                                      `json:"name"`
	Region       *DeploymentHistoryList_200_Items_Data_1_Region              `json:"region,omitempty"`
	Resources    struct {
		Autoscaling *struct {
			Enabled     *bool                                                                       `json:"enabled,omitempty"`
			MaxReplicas float32                                                                     `json:"maxReplicas"`
			Metrics     []DeploymentHistoryList_200_Items_Data_1_Resources_Autoscaling_Metrics_Item `json:"metrics"`
		} `json:"autoscaling,omitempty"`
		MachineType string    `json:"machineType"`
		Ports       []float32 `json:"ports"`
		Replicas    *float32  `json:"replicas,omitempty"`
	} `json:"resources"`
}
type DeploymentHistoryList200ItemsData1ApiVersion0 string
type DeploymentHistoryList200ItemsData1ApiVersion1 string
type DeploymentHistoryList_200_Items_Data_1_ApiVersion struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData1HealthChecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList200ItemsData1HealthChecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList_200_Items_Data_1_HealthChecks_Liveness struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData1HealthChecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList200ItemsData1HealthChecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList_200_Items_Data_1_HealthChecks_Readiness struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData1HealthChecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList200ItemsData1HealthChecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList_200_Items_Data_1_HealthChecks_Startup struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData1HealthchecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList200ItemsData1HealthchecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList_200_Items_Data_1_Healthchecks_Liveness struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData1HealthchecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList200ItemsData1HealthchecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList_200_Items_Data_1_Healthchecks_Readiness struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData1HealthchecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList200ItemsData1HealthchecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type DeploymentHistoryList_200_Items_Data_1_Healthchecks_Startup struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData1Integrations0 struct {
	Id   string                                              `json:"id"`
	Name string                                              `json:"name"`
	Path *string                                             `json:"path,omitempty"`
	Type DeploymentHistoryList200ItemsData1Integrations0Type `json:"type"`
}
type DeploymentHistoryList200ItemsData1Integrations0Type string
type DeploymentHistoryList200ItemsData1Integrations1 struct {
	AccessKeyId     *string                                                       `json:"accessKeyId,omitempty"`
	Endpoint        *string                                                       `json:"endpoint,omitempty"`
	Name            string                                                        `json:"name"`
	Path            *string                                                       `json:"path,omitempty"`
	Region          *DeploymentHistoryList_200_Items_Data_1_Integrations_1_Region `json:"region,omitempty"`
	SecretAccessKey *string                                                       `json:"secretAccessKey,omitempty"`
	Type            DeploymentHistoryList200ItemsData1Integrations1Type           `json:"type"`
	Url             string                                                        `json:"url"`
}
type DeploymentHistoryList200ItemsData1Integrations1Region0 string
type DeploymentHistoryList200ItemsData1Integrations1Region1 string
type DeploymentHistoryList200ItemsData1Integrations1Region2 string
type DeploymentHistoryList200ItemsData1Integrations1Region3 = string
type DeploymentHistoryList_200_Items_Data_1_Integrations_1_Region struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData1Integrations1Type string
type DeploymentHistoryList200ItemsData1Integrations2 struct {
	AccessKeyId     *string                                             `json:"accessKeyId,omitempty"`
	Endpoint        string                                              `json:"endpoint"`
	Name            string                                              `json:"name"`
	Path            *string                                             `json:"path,omitempty"`
	SecretAccessKey *string                                             `json:"secretAccessKey,omitempty"`
	Type            DeploymentHistoryList200ItemsData1Integrations2Type `json:"type"`
}
type DeploymentHistoryList200ItemsData1Integrations2Type string
type DeploymentHistoryList200ItemsData1Integrations3 struct {
	Name string                                              `json:"name"`
	Type DeploymentHistoryList200ItemsData1Integrations3Type `json:"type"`
}
type DeploymentHistoryList200ItemsData1Integrations3Type string
type DeploymentHistoryList200ItemsData1Integrations4 struct {
	Name string                                              `json:"name"`
	Path *string                                             `json:"path,omitempty"`
	Type DeploymentHistoryList200ItemsData1Integrations4Type `json:"type"`
	Url  string                                              `json:"url"`
}
type DeploymentHistoryList200ItemsData1Integrations4Type string
type DeploymentHistoryList_200_Items_Data_1_Integrations_Item struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData1Region0 string
type DeploymentHistoryList200ItemsData1Region1 string
type DeploymentHistoryList200ItemsData1Region2 string
type DeploymentHistoryList200ItemsData1Region3 = string
type DeploymentHistoryList_200_Items_Data_1_Region struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsData1ResourcesAutoscalingMetrics0 struct {
	Metric  DeploymentHistoryList200ItemsData1ResourcesAutoscalingMetrics0Metric  `json:"metric"`
	Summary DeploymentHistoryList200ItemsData1ResourcesAutoscalingMetrics0Summary `json:"summary"`
	Value   float32                                                               `json:"value"`
}
type DeploymentHistoryList200ItemsData1ResourcesAutoscalingMetrics0Metric string
type DeploymentHistoryList200ItemsData1ResourcesAutoscalingMetrics0Summary string
type DeploymentHistoryList200ItemsData1ResourcesAutoscalingMetrics1 struct {
	Metric  DeploymentHistoryList200ItemsData1ResourcesAutoscalingMetrics1Metric  `json:"metric"`
	Summary DeploymentHistoryList200ItemsData1ResourcesAutoscalingMetrics1Summary `json:"summary"`
	Value   int                                                                   `json:"value"`
}
type DeploymentHistoryList200ItemsData1ResourcesAutoscalingMetrics1Metric string
type DeploymentHistoryList200ItemsData1ResourcesAutoscalingMetrics1Summary string
type DeploymentHistoryList_200_Items_Data_1_Resources_Autoscaling_Metrics_Item struct {
	union json.RawMessage
}
type DeploymentHistoryList_200_Items_Data struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsMetadataGitHeadersXGitHost0 string
type DeploymentHistoryList200ItemsMetadataGitHeadersXGitHost1 string
type DeploymentHistoryList_200_Items_Metadata_GitHeaders_XGitHost struct {
	union json.RawMessage
}
type DeploymentHistoryList200ItemsWorkflowRunPhase string

// Status returns HTTPResponse.Status
func (r DeploymentHistoryListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeploymentHistoryListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeploymentLogsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// DtCreated The date the log was created.
			DtCreated time.Time `json:"dtCreated"`

			// Id ID of the log item
			Id string `json:"id"`

			// InstanceId The instance ID the log is associated with.
			InstanceId *string `json:"instanceId"`

			// JobId The associated job ID of the log item.
			JobId string `json:"jobId"`

			// Message The message of the log item.
			Message string `json:"message"`

			// Uuid UUID representing the log item
			Uuid *string `json:"uuid"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DeploymentLogsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeploymentLogsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeploymentMetricsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSONDefault *Error
}
type DeploymentMetricsGet2000 struct {
	union json.RawMessage
}
type DeploymentMetricsGet20000 struct {
	Timestamp time.Time `json:"timestamp"`
	Value     string    `json:"value"`
}
type DeploymentMetricsGet20001 = []struct {
	Gpu        *string   `json:"gpu,omitempty"`
	InstanceId *string   `json:"instanceId,omitempty"`
	Timestamp  time.Time `json:"timestamp"`
	Value      string    `json:"value"`
}
type DeploymentMetricsGet2001 = []struct {
	InstanceId string `json:"instanceId"`
	Values     []struct {
		Timestamp time.Time `json:"timestamp"`
		Value     string    `json:"value"`
	} `json:"values"`
}

// Status returns HTTPResponse.Status
func (r DeploymentMetricsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeploymentMetricsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeploymentRunsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// AvailableReplicas The amount of replicas that are available but not ready
		AvailableReplicas *float32 `json:"availableReplicas"`
		Id                string   `json:"id"`

		// Instances The deployment run instances
		Instances []struct {
			// DtCreated The date the instance was created
			DtCreated time.Time `json:"dtCreated"`

			// DtFinished The date the instance was finished
			DtFinished *time.Time `json:"dtFinished"`

			// History The time series state history of the deployment instance
			History []struct {
				// Message The state message from the instance at the point in time
				Message *string `json:"message"`

				// State The state of the instance at the point in time
				State string `json:"state"`

				// Timestamp The timestamp of the state
				Timestamp time.Time `json:"timestamp"`
			} `json:"history"`

			// Id The ID of the deployment instance
			Id string `json:"id"`

			// InstanceId The ID of the deployment instance
			InstanceId string `json:"instanceId"`

			// State The current state of the instance
			State string `json:"state"`

			// StateMessage The latest state message for the instance
			StateMessage *string `json:"stateMessage"`
		} `json:"instances"`

		// ReadyReplicas The amount of replicas that are ready
		ReadyReplicas *float32 `json:"readyReplicas"`

		// Replicas The desired amount of replicas for the deployment run
		Replicas *float32 `json:"replicas"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DeploymentRunsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeploymentRunsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachineAvailabilityListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Available bool `json:"available"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r MachineAvailabilityListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachineAvailabilityListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachineEventsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// DtCreated The date the event was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtFinished The date the event was finished.
			DtFinished *time.Time `json:"dtFinished"`

			// DtStarted The date the event was started.
			DtStarted *time.Time `json:"dtStarted"`

			// Error The error message of the event, if any.
			Error *string `json:"error"`

			// Id The ID of the event.
			Id string `json:"id"`

			// MachineId The ID of the machine the event is for.
			MachineId *string `json:"machineId"`

			// Name The name of the event, e.g. "create".
			Name MachineEventsList200ItemsName `json:"name"`

			// State The state of the event, e.g. "done".
			State MachineEventsList200ItemsState `json:"state"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}
type MachineEventsList200ItemsName string
type MachineEventsList200ItemsState string

// Status returns HTTPResponse.Status
func (r MachineEventsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachineEventsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachineEventsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the event was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtFinished The date the event was finished.
		DtFinished *time.Time `json:"dtFinished"`

		// DtStarted The date the event was started.
		DtStarted *time.Time `json:"dtStarted"`

		// Error The error message of the event, if any.
		Error *string `json:"error"`

		// Id The ID of the event.
		Id string `json:"id"`

		// MachineId The ID of the machine the event is for.
		MachineId *string `json:"machineId"`

		// Name The name of the event, e.g. "create".
		Name MachineEventsGet200Name `json:"name"`

		// State The state of the event, e.g. "done".
		State MachineEventsGet200State `json:"state"`
	}
	JSONDefault *Error
}
type MachineEventsGet200Name string
type MachineEventsGet200State string

// Status returns HTTPResponse.Status
func (r MachineEventsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachineEventsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// Accelerators The accelerators of the machine.
			Accelerators *[]struct {
				// Count The number of accelerators of this type.
				Count float32 `json:"count"`

				// Memory The amount of memory the accelerator has, if applicable.
				Memory *int `json:"memory"`

				// Name The name of the accelerator.
				Name string `json:"name"`
			} `json:"accelerators"`

			// AgentType The agent type of the machine.
			AgentType string `json:"agentType"`

			// AutoShutdownEnabled Whether auto shutdown is enabled.
			AutoShutdownEnabled bool `json:"autoShutdownEnabled"`

			// AutoShutdownForce Whether to force shutdown the machine.
			AutoShutdownForce *bool `json:"autoShutdownForce"`

			// AutoShutdownTimeout The shutdown timeout of the machine in hours.
			AutoShutdownTimeout *float32 `json:"autoShutdownTimeout"`

			// AutoSnapshotEnabled Whether auto snapshots are enabled.
			AutoSnapshotEnabled bool `json:"autoSnapshotEnabled"`

			// AutoSnapshotFrequency The frequency of auto snapshots.
			AutoSnapshotFrequency *MachinesList200ItemsAutoSnapshotFrequency `json:"autoSnapshotFrequency"`

			// AutoSnapshotSaveCount The number of auto snapshots to save.
			AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount"`

			// Cpus The number of CPUs.
			Cpus float32 `json:"cpus"`

			// DtCreated The date the machine was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the machine was deleted.
			DtDeleted *time.Time `json:"dtDeleted"`

			// DtModified The date the machine was last modified.
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the machine.
			Id string `json:"id"`

			// MachineType The type of the machine.
			MachineType string `json:"machineType"`

			// Name The name of the machine.
			Name string `json:"name"`

			// NetworkId The ID of the network the machine is on.
			NetworkId *string `json:"networkId"`

			// Os The operating system of the machine.
			Os string `json:"os"`

			// PrivateIp The private IP address of the machine.
			PrivateIp *string `json:"privateIp"`

			// PublicIp The public IP address of the machine.
			PublicIp *string `json:"publicIp"`

			// PublicIpType The public IP type.
			PublicIpType MachinesList200ItemsPublicIpType `json:"publicIpType"`

			// Ram The amount of RAM in bytes.
			Ram int64 `json:"ram"`

			// Region The region of the machine.
			Region      MachinesList_200_Items_Region `json:"region"`
			Reservation *struct {
				DtFinished time.Time          `json:"dtFinished"`
				DtStarted  time.Time          `json:"dtStarted"`
				Id         openapi_types.UUID `json:"id"`
				IsActive   bool               `json:"isActive"`
				Name       string             `json:"name"`
			} `json:"reservation"`

			// RestorePointEnabled Whether a restore point is enabled.
			RestorePointEnabled bool `json:"restorePointEnabled"`

			// RestorePointFrequency The frequency of restore points.
			RestorePointFrequency *MachinesList200ItemsRestorePointFrequency `json:"restorePointFrequency"`

			// RestorePointSnapshotId The ID of the snapshot to use as a restore point.
			RestorePointSnapshotId *string `json:"restorePointSnapshotId"`

			// State The state of the machine.
			State MachinesList200ItemsState `json:"state"`

			// StorageRate The storage rate of the machine.
			StorageRate float32 `json:"storageRate"`

			// StorageTotal The total amount of storage.
			StorageTotal int64 `json:"storageTotal"`

			// StorageUsed The amount of storage used.
			StorageUsed int64 `json:"storageUsed"`

			// UpdatesPending Whether updates are pending.
			UpdatesPending bool `json:"updatesPending"`

			// UsageRate The usage rate of the machine.
			UsageRate float32 `json:"usageRate"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}
type MachinesList200ItemsAutoSnapshotFrequency string
type MachinesList200ItemsPublicIpType string
type MachinesList200ItemsRegion0 string
type MachinesList200ItemsRegion1 string
type MachinesList200ItemsRegion2 string
type MachinesList200ItemsRegion3 = string
type MachinesList_200_Items_Region struct {
	union json.RawMessage
}
type MachinesList200ItemsRestorePointFrequency string
type MachinesList200ItemsState string

// Status returns HTTPResponse.Status
func (r MachinesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The machine.
		Data struct {
			// Accelerators The accelerators of the machine.
			Accelerators *[]struct {
				// Count The number of accelerators of this type.
				Count float32 `json:"count"`

				// Memory The amount of memory the accelerator has, if applicable.
				Memory *int `json:"memory"`

				// Name The name of the accelerator.
				Name string `json:"name"`
			} `json:"accelerators"`

			// AgentType The agent type of the machine.
			AgentType string `json:"agentType"`

			// AutoShutdownEnabled Whether auto shutdown is enabled.
			AutoShutdownEnabled bool `json:"autoShutdownEnabled"`

			// AutoShutdownForce Whether to force shutdown the machine.
			AutoShutdownForce *bool `json:"autoShutdownForce"`

			// AutoShutdownTimeout The shutdown timeout of the machine in hours.
			AutoShutdownTimeout *float32 `json:"autoShutdownTimeout"`

			// AutoSnapshotEnabled Whether auto snapshots are enabled.
			AutoSnapshotEnabled bool `json:"autoSnapshotEnabled"`

			// AutoSnapshotFrequency The frequency of auto snapshots.
			AutoSnapshotFrequency *MachinesCreate200DataAutoSnapshotFrequency `json:"autoSnapshotFrequency"`

			// AutoSnapshotSaveCount The number of auto snapshots to save.
			AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount"`

			// Cpus The number of CPUs.
			Cpus float32 `json:"cpus"`

			// DtCreated The date the machine was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the machine was deleted.
			DtDeleted *time.Time `json:"dtDeleted"`

			// DtModified The date the machine was last modified.
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the machine.
			Id string `json:"id"`

			// MachineType The type of the machine.
			MachineType string `json:"machineType"`

			// Name The name of the machine.
			Name string `json:"name"`

			// NetworkId The ID of the network the machine is on.
			NetworkId *string `json:"networkId"`

			// Os The operating system of the machine.
			Os string `json:"os"`

			// PrivateIp The private IP address of the machine.
			PrivateIp *string `json:"privateIp"`

			// PublicIp The public IP address of the machine.
			PublicIp *string `json:"publicIp"`

			// PublicIpType The public IP type.
			PublicIpType MachinesCreate200DataPublicIpType `json:"publicIpType"`

			// Ram The amount of RAM in bytes.
			Ram int64 `json:"ram"`

			// Region The region of the machine.
			Region      MachinesCreate_200_Data_Region `json:"region"`
			Reservation *struct {
				DtFinished time.Time          `json:"dtFinished"`
				DtStarted  time.Time          `json:"dtStarted"`
				Id         openapi_types.UUID `json:"id"`
				IsActive   bool               `json:"isActive"`
				Name       string             `json:"name"`
			} `json:"reservation"`

			// RestorePointEnabled Whether a restore point is enabled.
			RestorePointEnabled bool `json:"restorePointEnabled"`

			// RestorePointFrequency The frequency of restore points.
			RestorePointFrequency *MachinesCreate200DataRestorePointFrequency `json:"restorePointFrequency"`

			// RestorePointSnapshotId The ID of the snapshot to use as a restore point.
			RestorePointSnapshotId *string `json:"restorePointSnapshotId"`

			// State The state of the machine.
			State MachinesCreate200DataState `json:"state"`

			// StorageRate The storage rate of the machine.
			StorageRate float32 `json:"storageRate"`

			// StorageTotal The total amount of storage.
			StorageTotal int64 `json:"storageTotal"`

			// StorageUsed The amount of storage used.
			StorageUsed int64 `json:"storageUsed"`

			// UpdatesPending Whether updates are pending.
			UpdatesPending bool `json:"updatesPending"`

			// UsageRate The usage rate of the machine.
			UsageRate float32 `json:"usageRate"`
		} `json:"data"`

		// Event The machine event to poll for the async operation.
		Event struct {
			// DtCreated The date the event was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtFinished The date the event was finished.
			DtFinished *time.Time `json:"dtFinished"`

			// DtStarted The date the event was started.
			DtStarted *time.Time `json:"dtStarted"`

			// Error The error message of the event, if any.
			Error *string `json:"error"`

			// Id The ID of the event.
			Id string `json:"id"`

			// MachineId The ID of the machine the event is for.
			MachineId *string `json:"machineId"`

			// Name The name of the event, e.g. "create".
			Name MachinesCreate200EventName `json:"name"`

			// State The state of the event, e.g. "done".
			State MachinesCreate200EventState `json:"state"`
		} `json:"event"`
	}
	JSONDefault *Error
}
type MachinesCreate200DataAutoSnapshotFrequency string
type MachinesCreate200DataPublicIpType string
type MachinesCreate200DataRegion0 string
type MachinesCreate200DataRegion1 string
type MachinesCreate200DataRegion2 string
type MachinesCreate200DataRegion3 = string
type MachinesCreate_200_Data_Region struct {
	union json.RawMessage
}
type MachinesCreate200DataRestorePointFrequency string
type MachinesCreate200DataState string
type MachinesCreate200EventName string
type MachinesCreate200EventState string

// Status returns HTTPResponse.Status
func (r MachinesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The machine.
		Data struct {
			// Accelerators The accelerators of the machine.
			Accelerators *[]struct {
				// Count The number of accelerators of this type.
				Count float32 `json:"count"`

				// Memory The amount of memory the accelerator has, if applicable.
				Memory *int `json:"memory"`

				// Name The name of the accelerator.
				Name string `json:"name"`
			} `json:"accelerators"`

			// AgentType The agent type of the machine.
			AgentType string `json:"agentType"`

			// AutoShutdownEnabled Whether auto shutdown is enabled.
			AutoShutdownEnabled bool `json:"autoShutdownEnabled"`

			// AutoShutdownForce Whether to force shutdown the machine.
			AutoShutdownForce *bool `json:"autoShutdownForce"`

			// AutoShutdownTimeout The shutdown timeout of the machine in hours.
			AutoShutdownTimeout *float32 `json:"autoShutdownTimeout"`

			// AutoSnapshotEnabled Whether auto snapshots are enabled.
			AutoSnapshotEnabled bool `json:"autoSnapshotEnabled"`

			// AutoSnapshotFrequency The frequency of auto snapshots.
			AutoSnapshotFrequency *MachinesDelete200DataAutoSnapshotFrequency `json:"autoSnapshotFrequency"`

			// AutoSnapshotSaveCount The number of auto snapshots to save.
			AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount"`

			// Cpus The number of CPUs.
			Cpus float32 `json:"cpus"`

			// DtCreated The date the machine was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the machine was deleted.
			DtDeleted *time.Time `json:"dtDeleted"`

			// DtModified The date the machine was last modified.
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the machine.
			Id string `json:"id"`

			// MachineType The type of the machine.
			MachineType string `json:"machineType"`

			// Name The name of the machine.
			Name string `json:"name"`

			// NetworkId The ID of the network the machine is on.
			NetworkId *string `json:"networkId"`

			// Os The operating system of the machine.
			Os string `json:"os"`

			// PrivateIp The private IP address of the machine.
			PrivateIp *string `json:"privateIp"`

			// PublicIp The public IP address of the machine.
			PublicIp *string `json:"publicIp"`

			// PublicIpType The public IP type.
			PublicIpType MachinesDelete200DataPublicIpType `json:"publicIpType"`

			// Ram The amount of RAM in bytes.
			Ram int64 `json:"ram"`

			// Region The region of the machine.
			Region      MachinesDelete_200_Data_Region `json:"region"`
			Reservation *struct {
				DtFinished time.Time          `json:"dtFinished"`
				DtStarted  time.Time          `json:"dtStarted"`
				Id         openapi_types.UUID `json:"id"`
				IsActive   bool               `json:"isActive"`
				Name       string             `json:"name"`
			} `json:"reservation"`

			// RestorePointEnabled Whether a restore point is enabled.
			RestorePointEnabled bool `json:"restorePointEnabled"`

			// RestorePointFrequency The frequency of restore points.
			RestorePointFrequency *MachinesDelete200DataRestorePointFrequency `json:"restorePointFrequency"`

			// RestorePointSnapshotId The ID of the snapshot to use as a restore point.
			RestorePointSnapshotId *string `json:"restorePointSnapshotId"`

			// State The state of the machine.
			State MachinesDelete200DataState `json:"state"`

			// StorageRate The storage rate of the machine.
			StorageRate float32 `json:"storageRate"`

			// StorageTotal The total amount of storage.
			StorageTotal int64 `json:"storageTotal"`

			// StorageUsed The amount of storage used.
			StorageUsed int64 `json:"storageUsed"`

			// UpdatesPending Whether updates are pending.
			UpdatesPending bool `json:"updatesPending"`

			// UsageRate The usage rate of the machine.
			UsageRate float32 `json:"usageRate"`
		} `json:"data"`

		// Event The machine event to poll for the async operation.
		Event struct {
			// DtCreated The date the event was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtFinished The date the event was finished.
			DtFinished *time.Time `json:"dtFinished"`

			// DtStarted The date the event was started.
			DtStarted *time.Time `json:"dtStarted"`

			// Error The error message of the event, if any.
			Error *string `json:"error"`

			// Id The ID of the event.
			Id string `json:"id"`

			// MachineId The ID of the machine the event is for.
			MachineId *string `json:"machineId"`

			// Name The name of the event, e.g. "create".
			Name MachinesDelete200EventName `json:"name"`

			// State The state of the event, e.g. "done".
			State MachinesDelete200EventState `json:"state"`
		} `json:"event"`
	}
	JSONDefault *Error
}
type MachinesDelete200DataAutoSnapshotFrequency string
type MachinesDelete200DataPublicIpType string
type MachinesDelete200DataRegion0 string
type MachinesDelete200DataRegion1 string
type MachinesDelete200DataRegion2 string
type MachinesDelete200DataRegion3 = string
type MachinesDelete_200_Data_Region struct {
	union json.RawMessage
}
type MachinesDelete200DataRestorePointFrequency string
type MachinesDelete200DataState string
type MachinesDelete200EventName string
type MachinesDelete200EventState string

// Status returns HTTPResponse.Status
func (r MachinesDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Accelerators The accelerators of the machine.
		Accelerators *[]struct {
			// Count The number of accelerators of this type.
			Count float32 `json:"count"`

			// Memory The amount of memory the accelerator has, if applicable.
			Memory *int `json:"memory"`

			// Name The name of the accelerator.
			Name string `json:"name"`
		} `json:"accelerators"`

		// AgentType The agent type of the machine.
		AgentType string `json:"agentType"`

		// AutoShutdownEnabled Whether auto shutdown is enabled.
		AutoShutdownEnabled bool `json:"autoShutdownEnabled"`

		// AutoShutdownForce Whether to force shutdown the machine.
		AutoShutdownForce *bool `json:"autoShutdownForce"`

		// AutoShutdownTimeout The shutdown timeout of the machine in hours.
		AutoShutdownTimeout *float32 `json:"autoShutdownTimeout"`

		// AutoSnapshotEnabled Whether auto snapshots are enabled.
		AutoSnapshotEnabled bool `json:"autoSnapshotEnabled"`

		// AutoSnapshotFrequency The frequency of auto snapshots.
		AutoSnapshotFrequency *MachinesGet200AutoSnapshotFrequency `json:"autoSnapshotFrequency"`

		// AutoSnapshotSaveCount The number of auto snapshots to save.
		AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount"`

		// Cpus The number of CPUs.
		Cpus float32 `json:"cpus"`

		// DtCreated The date the machine was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the machine was deleted.
		DtDeleted *time.Time `json:"dtDeleted"`

		// DtModified The date the machine was last modified.
		DtModified time.Time `json:"dtModified"`

		// Id The ID of the machine.
		Id string `json:"id"`

		// MachineType The type of the machine.
		MachineType string `json:"machineType"`

		// Name The name of the machine.
		Name string `json:"name"`

		// NetworkId The ID of the network the machine is on.
		NetworkId *string `json:"networkId"`

		// Os The operating system of the machine.
		Os string `json:"os"`

		// PrivateIp The private IP address of the machine.
		PrivateIp *string `json:"privateIp"`

		// PublicIp The public IP address of the machine.
		PublicIp *string `json:"publicIp"`

		// PublicIpType The public IP type.
		PublicIpType MachinesGet200PublicIpType `json:"publicIpType"`

		// Ram The amount of RAM in bytes.
		Ram int64 `json:"ram"`

		// Region The region of the machine.
		Region      MachinesGet_200_Region `json:"region"`
		Reservation *struct {
			DtFinished time.Time          `json:"dtFinished"`
			DtStarted  time.Time          `json:"dtStarted"`
			Id         openapi_types.UUID `json:"id"`
			IsActive   bool               `json:"isActive"`
			Name       string             `json:"name"`
		} `json:"reservation"`

		// RestorePointEnabled Whether a restore point is enabled.
		RestorePointEnabled bool `json:"restorePointEnabled"`

		// RestorePointFrequency The frequency of restore points.
		RestorePointFrequency *MachinesGet200RestorePointFrequency `json:"restorePointFrequency"`

		// RestorePointSnapshotId The ID of the snapshot to use as a restore point.
		RestorePointSnapshotId *string `json:"restorePointSnapshotId"`

		// State The state of the machine.
		State MachinesGet200State `json:"state"`

		// StorageRate The storage rate of the machine.
		StorageRate float32 `json:"storageRate"`

		// StorageTotal The total amount of storage.
		StorageTotal int64 `json:"storageTotal"`

		// StorageUsed The amount of storage used.
		StorageUsed int64 `json:"storageUsed"`

		// UpdatesPending Whether updates are pending.
		UpdatesPending bool `json:"updatesPending"`

		// UsageRate The usage rate of the machine.
		UsageRate float32 `json:"usageRate"`
	}
	JSONDefault *Error
}
type MachinesGet200AutoSnapshotFrequency string
type MachinesGet200PublicIpType string
type MachinesGet200Region0 string
type MachinesGet200Region1 string
type MachinesGet200Region2 string
type MachinesGet200Region3 = string
type MachinesGet_200_Region struct {
	union json.RawMessage
}
type MachinesGet200RestorePointFrequency string
type MachinesGet200State string

// Status returns HTTPResponse.Status
func (r MachinesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The machine.
		Data struct {
			// Accelerators The accelerators of the machine.
			Accelerators *[]struct {
				// Count The number of accelerators of this type.
				Count float32 `json:"count"`

				// Memory The amount of memory the accelerator has, if applicable.
				Memory *int `json:"memory"`

				// Name The name of the accelerator.
				Name string `json:"name"`
			} `json:"accelerators"`

			// AgentType The agent type of the machine.
			AgentType string `json:"agentType"`

			// AutoShutdownEnabled Whether auto shutdown is enabled.
			AutoShutdownEnabled bool `json:"autoShutdownEnabled"`

			// AutoShutdownForce Whether to force shutdown the machine.
			AutoShutdownForce *bool `json:"autoShutdownForce"`

			// AutoShutdownTimeout The shutdown timeout of the machine in hours.
			AutoShutdownTimeout *float32 `json:"autoShutdownTimeout"`

			// AutoSnapshotEnabled Whether auto snapshots are enabled.
			AutoSnapshotEnabled bool `json:"autoSnapshotEnabled"`

			// AutoSnapshotFrequency The frequency of auto snapshots.
			AutoSnapshotFrequency *MachinesUpdate200DataAutoSnapshotFrequency `json:"autoSnapshotFrequency"`

			// AutoSnapshotSaveCount The number of auto snapshots to save.
			AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount"`

			// Cpus The number of CPUs.
			Cpus float32 `json:"cpus"`

			// DtCreated The date the machine was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the machine was deleted.
			DtDeleted *time.Time `json:"dtDeleted"`

			// DtModified The date the machine was last modified.
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the machine.
			Id string `json:"id"`

			// MachineType The type of the machine.
			MachineType string `json:"machineType"`

			// Name The name of the machine.
			Name string `json:"name"`

			// NetworkId The ID of the network the machine is on.
			NetworkId *string `json:"networkId"`

			// Os The operating system of the machine.
			Os string `json:"os"`

			// PrivateIp The private IP address of the machine.
			PrivateIp *string `json:"privateIp"`

			// PublicIp The public IP address of the machine.
			PublicIp *string `json:"publicIp"`

			// PublicIpType The public IP type.
			PublicIpType MachinesUpdate200DataPublicIpType `json:"publicIpType"`

			// Ram The amount of RAM in bytes.
			Ram int64 `json:"ram"`

			// Region The region of the machine.
			Region      MachinesUpdate_200_Data_Region `json:"region"`
			Reservation *struct {
				DtFinished time.Time          `json:"dtFinished"`
				DtStarted  time.Time          `json:"dtStarted"`
				Id         openapi_types.UUID `json:"id"`
				IsActive   bool               `json:"isActive"`
				Name       string             `json:"name"`
			} `json:"reservation"`

			// RestorePointEnabled Whether a restore point is enabled.
			RestorePointEnabled bool `json:"restorePointEnabled"`

			// RestorePointFrequency The frequency of restore points.
			RestorePointFrequency *MachinesUpdate200DataRestorePointFrequency `json:"restorePointFrequency"`

			// RestorePointSnapshotId The ID of the snapshot to use as a restore point.
			RestorePointSnapshotId *string `json:"restorePointSnapshotId"`

			// State The state of the machine.
			State MachinesUpdate200DataState `json:"state"`

			// StorageRate The storage rate of the machine.
			StorageRate float32 `json:"storageRate"`

			// StorageTotal The total amount of storage.
			StorageTotal int64 `json:"storageTotal"`

			// StorageUsed The amount of storage used.
			StorageUsed int64 `json:"storageUsed"`

			// UpdatesPending Whether updates are pending.
			UpdatesPending bool `json:"updatesPending"`

			// UsageRate The usage rate of the machine.
			UsageRate float32 `json:"usageRate"`
		} `json:"data"`

		// Event The machine event to poll for the async operation.
		Event *struct {
			// DtCreated The date the event was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtFinished The date the event was finished.
			DtFinished *time.Time `json:"dtFinished"`

			// DtStarted The date the event was started.
			DtStarted *time.Time `json:"dtStarted"`

			// Error The error message of the event, if any.
			Error *string `json:"error"`

			// Id The ID of the event.
			Id string `json:"id"`

			// MachineId The ID of the machine the event is for.
			MachineId *string `json:"machineId"`

			// Name The name of the event, e.g. "create".
			Name MachinesUpdate200EventName `json:"name"`

			// State The state of the event, e.g. "done".
			State MachinesUpdate200EventState `json:"state"`
		} `json:"event,omitempty"`
	}
	JSONDefault *Error
}
type MachinesUpdate200DataAutoSnapshotFrequency string
type MachinesUpdate200DataPublicIpType string
type MachinesUpdate200DataRegion0 string
type MachinesUpdate200DataRegion1 string
type MachinesUpdate200DataRegion2 string
type MachinesUpdate200DataRegion3 = string
type MachinesUpdate_200_Data_Region struct {
	union json.RawMessage
}
type MachinesUpdate200DataRestorePointFrequency string
type MachinesUpdate200DataState string
type MachinesUpdate200EventName string
type MachinesUpdate200EventState string

// Status returns HTTPResponse.Status
func (r MachinesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesListAccessorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// DtDeleted The date the user was removed from the machine as an accessor.
			DtDeleted *time.Time `json:"dtDeleted"`

			// User The user that can access the machine
			User struct {
				// Email The email address of the user
				Email openapi_types.Email `json:"email"`

				// FirstName The first name of the user
				FirstName *string `json:"firstName"`

				// Id The ID of the user
				Id string `json:"id"`

				// LastName The last name of the user
				LastName *string `json:"lastName"`

				// PublicProfileImageUrl The URL of the team's profile image.
				PublicProfileImageUrl *string `json:"publicProfileImageUrl"`
			} `json:"user"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r MachinesListAccessorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesListAccessorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesAddAccessorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtDeleted The date the user was removed from the machine as an accessor.
		DtDeleted *time.Time `json:"dtDeleted"`

		// User The user that can access the machine
		User struct {
			// Email The email address of the user
			Email openapi_types.Email `json:"email"`

			// FirstName The first name of the user
			FirstName *string `json:"firstName"`

			// Id The ID of the user
			Id string `json:"id"`

			// LastName The last name of the user
			LastName *string `json:"lastName"`

			// PublicProfileImageUrl The URL of the team's profile image.
			PublicProfileImageUrl *string `json:"publicProfileImageUrl"`
		} `json:"user"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r MachinesAddAccessorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesAddAccessorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesRemoveAccessorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtDeleted The date the user was removed from the machine as an accessor.
		DtDeleted *time.Time `json:"dtDeleted"`

		// User The user that can access the machine
		User struct {
			// Email The email address of the user
			Email openapi_types.Email `json:"email"`

			// FirstName The first name of the user
			FirstName *string `json:"firstName"`

			// Id The ID of the user
			Id string `json:"id"`

			// LastName The last name of the user
			LastName *string `json:"lastName"`

			// PublicProfileImageUrl The URL of the team's profile image.
			PublicProfileImageUrl *string `json:"publicProfileImageUrl"`
		} `json:"user"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r MachinesRemoveAccessorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesRemoveAccessorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesGetAccessorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtDeleted The date the user was removed from the machine as an accessor.
		DtDeleted *time.Time `json:"dtDeleted"`

		// User The user that can access the machine
		User struct {
			// Email The email address of the user
			Email openapi_types.Email `json:"email"`

			// FirstName The first name of the user
			FirstName *string `json:"firstName"`

			// Id The ID of the user
			Id string `json:"id"`

			// LastName The last name of the user
			LastName *string `json:"lastName"`

			// PublicProfileImageUrl The URL of the team's profile image.
			PublicProfileImageUrl *string `json:"publicProfileImageUrl"`
		} `json:"user"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r MachinesGetAccessorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesGetAccessorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesGetDesktopResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Vnc Settings for Linux desktop machines.
		Vnc *struct {
			// Hostname The VNC hostname.
			Hostname string `json:"hostname"`

			// Password The VNC password.
			Password string `json:"password"`

			// Port The port VNC is listening on.
			Port int `json:"port"`
		} `json:"vnc,omitempty"`

		// Windows Settings for Windows desktop machines.
		Windows *struct {
			// Hostname The Windows hostname.
			Hostname string `json:"hostname"`

			// Port The port Windows is listening on.
			Port int `json:"port"`

			// PublicIp The public IP of the machine.
			PublicIp *string `json:"publicIp,omitempty"`
		} `json:"windows,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r MachinesGetDesktopResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesGetDesktopResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesRestartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The machine.
		Data struct {
			// Accelerators The accelerators of the machine.
			Accelerators *[]struct {
				// Count The number of accelerators of this type.
				Count float32 `json:"count"`

				// Memory The amount of memory the accelerator has, if applicable.
				Memory *int `json:"memory"`

				// Name The name of the accelerator.
				Name string `json:"name"`
			} `json:"accelerators"`

			// AgentType The agent type of the machine.
			AgentType string `json:"agentType"`

			// AutoShutdownEnabled Whether auto shutdown is enabled.
			AutoShutdownEnabled bool `json:"autoShutdownEnabled"`

			// AutoShutdownForce Whether to force shutdown the machine.
			AutoShutdownForce *bool `json:"autoShutdownForce"`

			// AutoShutdownTimeout The shutdown timeout of the machine in hours.
			AutoShutdownTimeout *float32 `json:"autoShutdownTimeout"`

			// AutoSnapshotEnabled Whether auto snapshots are enabled.
			AutoSnapshotEnabled bool `json:"autoSnapshotEnabled"`

			// AutoSnapshotFrequency The frequency of auto snapshots.
			AutoSnapshotFrequency *MachinesRestart200DataAutoSnapshotFrequency `json:"autoSnapshotFrequency"`

			// AutoSnapshotSaveCount The number of auto snapshots to save.
			AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount"`

			// Cpus The number of CPUs.
			Cpus float32 `json:"cpus"`

			// DtCreated The date the machine was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the machine was deleted.
			DtDeleted *time.Time `json:"dtDeleted"`

			// DtModified The date the machine was last modified.
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the machine.
			Id string `json:"id"`

			// MachineType The type of the machine.
			MachineType string `json:"machineType"`

			// Name The name of the machine.
			Name string `json:"name"`

			// NetworkId The ID of the network the machine is on.
			NetworkId *string `json:"networkId"`

			// Os The operating system of the machine.
			Os string `json:"os"`

			// PrivateIp The private IP address of the machine.
			PrivateIp *string `json:"privateIp"`

			// PublicIp The public IP address of the machine.
			PublicIp *string `json:"publicIp"`

			// PublicIpType The public IP type.
			PublicIpType MachinesRestart200DataPublicIpType `json:"publicIpType"`

			// Ram The amount of RAM in bytes.
			Ram int64 `json:"ram"`

			// Region The region of the machine.
			Region      MachinesRestart_200_Data_Region `json:"region"`
			Reservation *struct {
				DtFinished time.Time          `json:"dtFinished"`
				DtStarted  time.Time          `json:"dtStarted"`
				Id         openapi_types.UUID `json:"id"`
				IsActive   bool               `json:"isActive"`
				Name       string             `json:"name"`
			} `json:"reservation"`

			// RestorePointEnabled Whether a restore point is enabled.
			RestorePointEnabled bool `json:"restorePointEnabled"`

			// RestorePointFrequency The frequency of restore points.
			RestorePointFrequency *MachinesRestart200DataRestorePointFrequency `json:"restorePointFrequency"`

			// RestorePointSnapshotId The ID of the snapshot to use as a restore point.
			RestorePointSnapshotId *string `json:"restorePointSnapshotId"`

			// State The state of the machine.
			State MachinesRestart200DataState `json:"state"`

			// StorageRate The storage rate of the machine.
			StorageRate float32 `json:"storageRate"`

			// StorageTotal The total amount of storage.
			StorageTotal int64 `json:"storageTotal"`

			// StorageUsed The amount of storage used.
			StorageUsed int64 `json:"storageUsed"`

			// UpdatesPending Whether updates are pending.
			UpdatesPending bool `json:"updatesPending"`

			// UsageRate The usage rate of the machine.
			UsageRate float32 `json:"usageRate"`
		} `json:"data"`

		// Event The machine event to poll for the async operation.
		Event struct {
			// DtCreated The date the event was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtFinished The date the event was finished.
			DtFinished *time.Time `json:"dtFinished"`

			// DtStarted The date the event was started.
			DtStarted *time.Time `json:"dtStarted"`

			// Error The error message of the event, if any.
			Error *string `json:"error"`

			// Id The ID of the event.
			Id string `json:"id"`

			// MachineId The ID of the machine the event is for.
			MachineId *string `json:"machineId"`

			// Name The name of the event, e.g. "create".
			Name MachinesRestart200EventName `json:"name"`

			// State The state of the event, e.g. "done".
			State MachinesRestart200EventState `json:"state"`
		} `json:"event"`
	}
	JSONDefault *Error
}
type MachinesRestart200DataAutoSnapshotFrequency string
type MachinesRestart200DataPublicIpType string
type MachinesRestart200DataRegion0 string
type MachinesRestart200DataRegion1 string
type MachinesRestart200DataRegion2 string
type MachinesRestart200DataRegion3 = string
type MachinesRestart_200_Data_Region struct {
	union json.RawMessage
}
type MachinesRestart200DataRestorePointFrequency string
type MachinesRestart200DataState string
type MachinesRestart200EventName string
type MachinesRestart200EventState string

// Status returns HTTPResponse.Status
func (r MachinesRestartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesRestartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The machine.
		Data struct {
			// Accelerators The accelerators of the machine.
			Accelerators *[]struct {
				// Count The number of accelerators of this type.
				Count float32 `json:"count"`

				// Memory The amount of memory the accelerator has, if applicable.
				Memory *int `json:"memory"`

				// Name The name of the accelerator.
				Name string `json:"name"`
			} `json:"accelerators"`

			// AgentType The agent type of the machine.
			AgentType string `json:"agentType"`

			// AutoShutdownEnabled Whether auto shutdown is enabled.
			AutoShutdownEnabled bool `json:"autoShutdownEnabled"`

			// AutoShutdownForce Whether to force shutdown the machine.
			AutoShutdownForce *bool `json:"autoShutdownForce"`

			// AutoShutdownTimeout The shutdown timeout of the machine in hours.
			AutoShutdownTimeout *float32 `json:"autoShutdownTimeout"`

			// AutoSnapshotEnabled Whether auto snapshots are enabled.
			AutoSnapshotEnabled bool `json:"autoSnapshotEnabled"`

			// AutoSnapshotFrequency The frequency of auto snapshots.
			AutoSnapshotFrequency *MachinesStart200DataAutoSnapshotFrequency `json:"autoSnapshotFrequency"`

			// AutoSnapshotSaveCount The number of auto snapshots to save.
			AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount"`

			// Cpus The number of CPUs.
			Cpus float32 `json:"cpus"`

			// DtCreated The date the machine was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the machine was deleted.
			DtDeleted *time.Time `json:"dtDeleted"`

			// DtModified The date the machine was last modified.
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the machine.
			Id string `json:"id"`

			// MachineType The type of the machine.
			MachineType string `json:"machineType"`

			// Name The name of the machine.
			Name string `json:"name"`

			// NetworkId The ID of the network the machine is on.
			NetworkId *string `json:"networkId"`

			// Os The operating system of the machine.
			Os string `json:"os"`

			// PrivateIp The private IP address of the machine.
			PrivateIp *string `json:"privateIp"`

			// PublicIp The public IP address of the machine.
			PublicIp *string `json:"publicIp"`

			// PublicIpType The public IP type.
			PublicIpType MachinesStart200DataPublicIpType `json:"publicIpType"`

			// Ram The amount of RAM in bytes.
			Ram int64 `json:"ram"`

			// Region The region of the machine.
			Region      MachinesStart_200_Data_Region `json:"region"`
			Reservation *struct {
				DtFinished time.Time          `json:"dtFinished"`
				DtStarted  time.Time          `json:"dtStarted"`
				Id         openapi_types.UUID `json:"id"`
				IsActive   bool               `json:"isActive"`
				Name       string             `json:"name"`
			} `json:"reservation"`

			// RestorePointEnabled Whether a restore point is enabled.
			RestorePointEnabled bool `json:"restorePointEnabled"`

			// RestorePointFrequency The frequency of restore points.
			RestorePointFrequency *MachinesStart200DataRestorePointFrequency `json:"restorePointFrequency"`

			// RestorePointSnapshotId The ID of the snapshot to use as a restore point.
			RestorePointSnapshotId *string `json:"restorePointSnapshotId"`

			// State The state of the machine.
			State MachinesStart200DataState `json:"state"`

			// StorageRate The storage rate of the machine.
			StorageRate float32 `json:"storageRate"`

			// StorageTotal The total amount of storage.
			StorageTotal int64 `json:"storageTotal"`

			// StorageUsed The amount of storage used.
			StorageUsed int64 `json:"storageUsed"`

			// UpdatesPending Whether updates are pending.
			UpdatesPending bool `json:"updatesPending"`

			// UsageRate The usage rate of the machine.
			UsageRate float32 `json:"usageRate"`
		} `json:"data"`

		// Event The machine event to poll for the async operation.
		Event struct {
			// DtCreated The date the event was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtFinished The date the event was finished.
			DtFinished *time.Time `json:"dtFinished"`

			// DtStarted The date the event was started.
			DtStarted *time.Time `json:"dtStarted"`

			// Error The error message of the event, if any.
			Error *string `json:"error"`

			// Id The ID of the event.
			Id string `json:"id"`

			// MachineId The ID of the machine the event is for.
			MachineId *string `json:"machineId"`

			// Name The name of the event, e.g. "create".
			Name MachinesStart200EventName `json:"name"`

			// State The state of the event, e.g. "done".
			State MachinesStart200EventState `json:"state"`
		} `json:"event"`
	}
	JSONDefault *Error
}
type MachinesStart200DataAutoSnapshotFrequency string
type MachinesStart200DataPublicIpType string
type MachinesStart200DataRegion0 string
type MachinesStart200DataRegion1 string
type MachinesStart200DataRegion2 string
type MachinesStart200DataRegion3 = string
type MachinesStart_200_Data_Region struct {
	union json.RawMessage
}
type MachinesStart200DataRestorePointFrequency string
type MachinesStart200DataState string
type MachinesStart200EventName string
type MachinesStart200EventState string

// Status returns HTTPResponse.Status
func (r MachinesStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesStopResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The machine.
		Data struct {
			// Accelerators The accelerators of the machine.
			Accelerators *[]struct {
				// Count The number of accelerators of this type.
				Count float32 `json:"count"`

				// Memory The amount of memory the accelerator has, if applicable.
				Memory *int `json:"memory"`

				// Name The name of the accelerator.
				Name string `json:"name"`
			} `json:"accelerators"`

			// AgentType The agent type of the machine.
			AgentType string `json:"agentType"`

			// AutoShutdownEnabled Whether auto shutdown is enabled.
			AutoShutdownEnabled bool `json:"autoShutdownEnabled"`

			// AutoShutdownForce Whether to force shutdown the machine.
			AutoShutdownForce *bool `json:"autoShutdownForce"`

			// AutoShutdownTimeout The shutdown timeout of the machine in hours.
			AutoShutdownTimeout *float32 `json:"autoShutdownTimeout"`

			// AutoSnapshotEnabled Whether auto snapshots are enabled.
			AutoSnapshotEnabled bool `json:"autoSnapshotEnabled"`

			// AutoSnapshotFrequency The frequency of auto snapshots.
			AutoSnapshotFrequency *MachinesStop200DataAutoSnapshotFrequency `json:"autoSnapshotFrequency"`

			// AutoSnapshotSaveCount The number of auto snapshots to save.
			AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount"`

			// Cpus The number of CPUs.
			Cpus float32 `json:"cpus"`

			// DtCreated The date the machine was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the machine was deleted.
			DtDeleted *time.Time `json:"dtDeleted"`

			// DtModified The date the machine was last modified.
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the machine.
			Id string `json:"id"`

			// MachineType The type of the machine.
			MachineType string `json:"machineType"`

			// Name The name of the machine.
			Name string `json:"name"`

			// NetworkId The ID of the network the machine is on.
			NetworkId *string `json:"networkId"`

			// Os The operating system of the machine.
			Os string `json:"os"`

			// PrivateIp The private IP address of the machine.
			PrivateIp *string `json:"privateIp"`

			// PublicIp The public IP address of the machine.
			PublicIp *string `json:"publicIp"`

			// PublicIpType The public IP type.
			PublicIpType MachinesStop200DataPublicIpType `json:"publicIpType"`

			// Ram The amount of RAM in bytes.
			Ram int64 `json:"ram"`

			// Region The region of the machine.
			Region      MachinesStop_200_Data_Region `json:"region"`
			Reservation *struct {
				DtFinished time.Time          `json:"dtFinished"`
				DtStarted  time.Time          `json:"dtStarted"`
				Id         openapi_types.UUID `json:"id"`
				IsActive   bool               `json:"isActive"`
				Name       string             `json:"name"`
			} `json:"reservation"`

			// RestorePointEnabled Whether a restore point is enabled.
			RestorePointEnabled bool `json:"restorePointEnabled"`

			// RestorePointFrequency The frequency of restore points.
			RestorePointFrequency *MachinesStop200DataRestorePointFrequency `json:"restorePointFrequency"`

			// RestorePointSnapshotId The ID of the snapshot to use as a restore point.
			RestorePointSnapshotId *string `json:"restorePointSnapshotId"`

			// State The state of the machine.
			State MachinesStop200DataState `json:"state"`

			// StorageRate The storage rate of the machine.
			StorageRate float32 `json:"storageRate"`

			// StorageTotal The total amount of storage.
			StorageTotal int64 `json:"storageTotal"`

			// StorageUsed The amount of storage used.
			StorageUsed int64 `json:"storageUsed"`

			// UpdatesPending Whether updates are pending.
			UpdatesPending bool `json:"updatesPending"`

			// UsageRate The usage rate of the machine.
			UsageRate float32 `json:"usageRate"`
		} `json:"data"`

		// Event The machine event to poll for the async operation.
		Event struct {
			// DtCreated The date the event was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtFinished The date the event was finished.
			DtFinished *time.Time `json:"dtFinished"`

			// DtStarted The date the event was started.
			DtStarted *time.Time `json:"dtStarted"`

			// Error The error message of the event, if any.
			Error *string `json:"error"`

			// Id The ID of the event.
			Id string `json:"id"`

			// MachineId The ID of the machine the event is for.
			MachineId *string `json:"machineId"`

			// Name The name of the event, e.g. "create".
			Name MachinesStop200EventName `json:"name"`

			// State The state of the event, e.g. "done".
			State MachinesStop200EventState `json:"state"`
		} `json:"event"`
	}
	JSONDefault *Error
}
type MachinesStop200DataAutoSnapshotFrequency string
type MachinesStop200DataPublicIpType string
type MachinesStop200DataRegion0 string
type MachinesStop200DataRegion1 string
type MachinesStop200DataRegion2 string
type MachinesStop200DataRegion3 = string
type MachinesStop_200_Data_Region struct {
	union json.RawMessage
}
type MachinesStop200DataRestorePointFrequency string
type MachinesStop200DataState string
type MachinesStop200EventName string
type MachinesStop200EventState string

// Status returns HTTPResponse.Status
func (r MachinesStopResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesStopResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// Description The description of the dataset
			Description *string `json:"description"`

			// DtCreated The date the dataset was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the dataset was last modified
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the dataset
			Id string `json:"id"`

			// IsPublic Whether the dataset is public
			IsPublic bool `json:"isPublic"`

			// Name The name of the dataset
			Name string `json:"name"`

			// ProjectId The ID of the project
			ProjectId *string `json:"projectId"`

			// StorageProviderId The ID of the storage provider
			StorageProviderId *string `json:"storageProviderId"`

			// TeamId The ID of the team that owns the dataset
			TeamId string `json:"teamId"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ModelsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Description The description of the dataset
		Description *string `json:"description"`

		// DtCreated The date the dataset was created
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the dataset was last modified
		DtModified time.Time `json:"dtModified"`

		// Id The ID of the dataset
		Id string `json:"id"`

		// IsPublic Whether the dataset is public
		IsPublic bool `json:"isPublic"`

		// Name The name of the dataset
		Name string `json:"name"`

		// ProjectId The ID of the project
		ProjectId *string `json:"projectId"`

		// StorageProviderId The ID of the storage provider
		StorageProviderId *string `json:"storageProviderId"`

		// TeamId The ID of the team that owns the dataset
		TeamId string `json:"teamId"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ModelsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The ID of the model
		Id string `json:"id"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ModelsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Description The description of the dataset
		Description *string `json:"description"`

		// DtCreated The date the dataset was created
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the dataset was last modified
		DtModified time.Time `json:"dtModified"`

		// Id The ID of the dataset
		Id string `json:"id"`

		// IsPublic Whether the dataset is public
		IsPublic bool `json:"isPublic"`

		// Name The name of the dataset
		Name string `json:"name"`

		// ProjectId The ID of the project
		ProjectId *string `json:"projectId"`

		// StorageProviderId The ID of the storage provider
		StorageProviderId *string `json:"storageProviderId"`

		// TeamId The ID of the team that owns the dataset
		TeamId string `json:"teamId"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ModelsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OsTemplatesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// AgentType The type of agent installed on the template.
			AgentType string `json:"agentType"`

			// AvailableMachineTypes The machine types the template is available on.
			AvailableMachineTypes []struct {
				// IsAvailable Whether the template is available on this machine type.
				IsAvailable bool `json:"isAvailable"`

				// MachineTypeLabel The label of the machine type.
				MachineTypeLabel string `json:"machineTypeLabel"`
			} `json:"availableMachineTypes"`

			// DefaultSizeGb The default size of the template in gigabytes.
			DefaultSizeGb *OsTemplatesList_200_Items_DefaultSizeGb `json:"defaultSizeGb"`

			// DtCreated The date the template was created.
			DtCreated time.Time `json:"dtCreated"`

			// Id The ID of the template.
			Id string `json:"id"`

			// Name The name of the template.
			Name string `json:"name"`

			// OperatingSystemLabel The operating system installed on the template.
			OperatingSystemLabel string `json:"operatingSystemLabel"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}
type OsTemplatesList200ItemsDefaultSizeGb0 float32
type OsTemplatesList200ItemsDefaultSizeGb1 float32
type OsTemplatesList200ItemsDefaultSizeGb2 float32
type OsTemplatesList200ItemsDefaultSizeGb3 float32
type OsTemplatesList200ItemsDefaultSizeGb4 float32
type OsTemplatesList200ItemsDefaultSizeGb5 float32
type OsTemplatesList200ItemsDefaultSizeGb6 float32
type OsTemplatesList200ItemsDefaultSizeGb7 float32
type OsTemplatesList200ItemsDefaultSizeGb8 float32
type OsTemplatesList200ItemsDefaultSizeGb9 float32
type OsTemplatesList200ItemsDefaultSizeGb10 = float32
type OsTemplatesList_200_Items_DefaultSizeGb struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r OsTemplatesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OsTemplatesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrivateNetworksListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// DtCreated The date the private network was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the private network was deleted.
			DtDeleted *PrivateNetworksList_200_Items_DtDeleted `json:"dtDeleted"`

			// Id The ID of the private network.
			Id string `json:"id"`

			// Name The name of the private network.
			Name string `json:"name"`

			// Netmask The subnet mask of the private network.
			Netmask string `json:"netmask"`

			// Network The network prefix of the private network.
			Network string `json:"network"`

			// Region The region the private network is in.
			Region PrivateNetworksList_200_Items_Region `json:"region"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}
type PrivateNetworksList200ItemsDtDeleted0 = interface{}
type PrivateNetworksList200ItemsDtDeleted1 = time.Time
type PrivateNetworksList_200_Items_DtDeleted struct {
	union json.RawMessage
}
type PrivateNetworksList200ItemsRegion0 string
type PrivateNetworksList200ItemsRegion1 string
type PrivateNetworksList200ItemsRegion2 string
type PrivateNetworksList200ItemsRegion3 = string
type PrivateNetworksList_200_Items_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PrivateNetworksListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrivateNetworksListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrivateNetworksCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the private network was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the private network was deleted.
		DtDeleted *PrivateNetworksCreate_200_DtDeleted `json:"dtDeleted"`

		// Id The ID of the private network.
		Id string `json:"id"`

		// Name The name of the private network.
		Name string `json:"name"`

		// Netmask The subnet mask of the private network.
		Netmask string `json:"netmask"`

		// Network The network prefix of the private network.
		Network string `json:"network"`

		// Region The region the private network is in.
		Region PrivateNetworksCreate_200_Region `json:"region"`
	}
	JSONDefault *Error
}
type PrivateNetworksCreate200DtDeleted0 = interface{}
type PrivateNetworksCreate200DtDeleted1 = time.Time
type PrivateNetworksCreate_200_DtDeleted struct {
	union json.RawMessage
}
type PrivateNetworksCreate200Region0 string
type PrivateNetworksCreate200Region1 string
type PrivateNetworksCreate200Region2 string
type PrivateNetworksCreate200Region3 = string
type PrivateNetworksCreate_200_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PrivateNetworksCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrivateNetworksCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrivateNetworksDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The ID of the private network to delete.
		Id string `json:"id"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PrivateNetworksDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrivateNetworksDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrivateNetworksGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the private network was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the private network was deleted.
		DtDeleted *PrivateNetworksGet_200_DtDeleted `json:"dtDeleted"`

		// Id The ID of the private network.
		Id string `json:"id"`

		// Name The name of the private network.
		Name string `json:"name"`

		// Netmask The subnet mask of the private network.
		Netmask string `json:"netmask"`

		// Network The network prefix of the private network.
		Network string `json:"network"`

		// Region The region the private network is in.
		Region PrivateNetworksGet_200_Region `json:"region"`
	}
	JSONDefault *Error
}
type PrivateNetworksGet200DtDeleted0 = interface{}
type PrivateNetworksGet200DtDeleted1 = time.Time
type PrivateNetworksGet_200_DtDeleted struct {
	union json.RawMessage
}
type PrivateNetworksGet200Region0 string
type PrivateNetworksGet200Region1 string
type PrivateNetworksGet200Region2 string
type PrivateNetworksGet200Region3 = string
type PrivateNetworksGet_200_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PrivateNetworksGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrivateNetworksGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrivateNetworksUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the private network was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the private network was deleted.
		DtDeleted *PrivateNetworksUpdate_200_DtDeleted `json:"dtDeleted"`

		// Id The ID of the private network.
		Id string `json:"id"`

		// Name The name of the private network.
		Name string `json:"name"`

		// Netmask The subnet mask of the private network.
		Netmask string `json:"netmask"`

		// Network The network prefix of the private network.
		Network string `json:"network"`

		// Region The region the private network is in.
		Region PrivateNetworksUpdate_200_Region `json:"region"`
	}
	JSONDefault *Error
}
type PrivateNetworksUpdate200DtDeleted0 = interface{}
type PrivateNetworksUpdate200DtDeleted1 = time.Time
type PrivateNetworksUpdate_200_DtDeleted struct {
	union json.RawMessage
}
type PrivateNetworksUpdate200Region0 string
type PrivateNetworksUpdate200Region1 string
type PrivateNetworksUpdate200Region2 string
type PrivateNetworksUpdate200Region3 = string
type PrivateNetworksUpdate_200_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PrivateNetworksUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrivateNetworksUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// DtCreated The date the project was created
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the project was deleted
			DtDeleted *time.Time `json:"dtDeleted"`

			// Id The ID of the project
			Id string `json:"id"`

			// Name The name of the project
			Name string `json:"name"`

			// RepoName The name of the GitHub repository if this is is a GitHub-connected project.
			RepoName *string `json:"repoName"`

			// RepoNodeId The node ID of the GitHub repository if this is is a GitHub-connected project.
			RepoNodeId *string `json:"repoNodeId"`

			// RepoUrl The URL of the GitHub repository if this is is a GitHub-connected project.
			RepoUrl *string `json:"repoUrl"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the project was created
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the project was deleted
		DtDeleted *time.Time `json:"dtDeleted"`

		// Id The ID of the project
		Id string `json:"id"`

		// Name The name of the project
		Name string `json:"name"`

		// RepoName The name of the GitHub repository if this is is a GitHub-connected project.
		RepoName *string `json:"repoName"`

		// RepoNodeId The node ID of the GitHub repository if this is is a GitHub-connected project.
		RepoNodeId *string `json:"repoNodeId"`

		// RepoUrl The URL of the GitHub repository if this is is a GitHub-connected project.
		RepoUrl *string `json:"repoUrl"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the project was created
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the project was deleted
		DtDeleted *time.Time `json:"dtDeleted"`

		// Id The ID of the project
		Id string `json:"id"`

		// Name The name of the project
		Name string `json:"name"`

		// RepoName The name of the GitHub repository if this is is a GitHub-connected project.
		RepoName *string `json:"repoName"`

		// RepoNodeId The node ID of the GitHub repository if this is is a GitHub-connected project.
		RepoNodeId *string `json:"repoNodeId"`

		// RepoUrl The URL of the GitHub repository if this is is a GitHub-connected project.
		RepoUrl *string `json:"repoUrl"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the project was created
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the project was deleted
		DtDeleted *time.Time `json:"dtDeleted"`

		// Id The ID of the project
		Id string `json:"id"`

		// Name The name of the project
		Name string `json:"name"`

		// RepoName The name of the GitHub repository if this is is a GitHub-connected project.
		RepoName *string `json:"repoName"`

		// RepoNodeId The node ID of the GitHub repository if this is is a GitHub-connected project.
		RepoNodeId *string `json:"repoNodeId"`

		// RepoUrl The URL of the GitHub repository if this is is a GitHub-connected project.
		RepoUrl *string `json:"repoUrl"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the project was created
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the project was deleted
		DtDeleted *time.Time `json:"dtDeleted"`

		// Id The ID of the project
		Id string `json:"id"`

		// Name The name of the project
		Name string `json:"name"`

		// RepoName The name of the GitHub repository if this is is a GitHub-connected project.
		RepoName *string `json:"repoName"`

		// RepoNodeId The node ID of the GitHub repository if this is is a GitHub-connected project.
		RepoNodeId *string `json:"repoNodeId"`

		// RepoUrl The URL of the GitHub repository if this is is a GitHub-connected project.
		RepoUrl *string `json:"repoUrl"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectActivityListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// Action The action that was performed
			Action ProjectActivityList_200_Items_Action `json:"action"`

			// Actor The actor that performed the action. Either a use or system.
			Actor *struct {
				// AvatarUrl The avatar URL of the actor
				AvatarUrl *string `json:"avatarUrl"`

				// Email The email of the actor
				Email *string `json:"email"`

				// FullName The full name of the actor (e.g. "John Doe")
				FullName *string `json:"fullName"`
			} `json:"actor"`

			// Data The data associated with the activity item
			Data *struct {
				From float32 `json:"from"`
				To   float32 `json:"to"`
			} `json:"data"`

			// Deployment The deployment associated with the activity item
			Deployment *struct {
				// DtDeleted The date the deployment was deleted
				DtDeleted *time.Time `json:"dtDeleted"`

				// Id The ID of the deployment
				Id string `json:"id"`

				// Name The name of the deployment
				Name string `json:"name"`
			} `json:"deployment"`

			// DtCreated The date the activity item was created
			DtCreated time.Time `json:"dtCreated"`

			// Id ID of the activity item
			Id openapi_types.UUID `json:"id"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}
type ProjectActivityList200ItemsAction0 string
type ProjectActivityList200ItemsAction1 string
type ProjectActivityList200ItemsAction2 string
type ProjectActivityList200ItemsAction3 string
type ProjectActivityList200ItemsAction4 string
type ProjectActivityList200ItemsAction5 string
type ProjectActivityList200ItemsAction6 string
type ProjectActivityList200ItemsAction7 string
type ProjectActivityList_200_Items_Action struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r ProjectActivityListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectActivityListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectCollaboratorsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// DtCreated The date the collaborate was added to the project
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the collaborator was removed from the project
			DtDeleted *time.Time `json:"dtDeleted"`

			// User The user that can access the project
			User struct {
				// Email The email address of the user
				Email openapi_types.Email `json:"email"`

				// FirstName The first name of the user
				FirstName *string `json:"firstName"`

				// Id The ID of the user
				Id string `json:"id"`

				// LastName The last name of the user
				LastName *string `json:"lastName"`

				// PublicProfileImageUrl The URL of the team's profile image.
				PublicProfileImageUrl *string `json:"publicProfileImageUrl"`
			} `json:"user"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectCollaboratorsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectCollaboratorsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectCollaboratorsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the collaborate was added to the project
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the collaborator was removed from the project
		DtDeleted *time.Time `json:"dtDeleted"`

		// User The user that can access the project
		User struct {
			// Email The email address of the user
			Email openapi_types.Email `json:"email"`

			// FirstName The first name of the user
			FirstName *string `json:"firstName"`

			// Id The ID of the user
			Id string `json:"id"`

			// LastName The last name of the user
			LastName *string `json:"lastName"`

			// PublicProfileImageUrl The URL of the team's profile image.
			PublicProfileImageUrl *string `json:"publicProfileImageUrl"`
		} `json:"user"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectCollaboratorsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectCollaboratorsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectCollaboratorsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// UserId The ID of the user removed from the project.
		UserId string `json:"userId"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectCollaboratorsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectCollaboratorsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectDeploymentsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// BasicAuthKey The endpoint security key for the deployment
			BasicAuthKey *string `json:"basicAuthKey"`

			// DtCreated The date the deployment was created
			DtCreated time.Time `json:"dtCreated"`

			// Endpoint The unique endpoint for the deployment
			Endpoint string `json:"endpoint"`

			// Id The ID of the deployment
			Id string `json:"id"`

			// LatestSpec The latest deployment configuration. If invalid, null is returned.
			LatestSpec *struct {
				// Data The data for the deployment spec
				Data *ProjectDeploymentsList_200_Items_LatestSpec_Data `json:"data"`

				// DeploymentId The ID of the deployment the spec belongs to
				DeploymentId string `json:"deploymentId"`

				// DtHealthy The date the deployment was marked "healthy"
				DtHealthy *time.Time `json:"dtHealthy"`

				// Error The fatal configuration error. Only present if the cluster was unable to apply the entire deployment configuration. This is not the same as an instance error.
				Error *string `json:"error"`

				// ExternalApplied The date the deployment configuration was applied to the cluster
				ExternalApplied *time.Time `json:"externalApplied"`

				// Id The ID of the deployment spec
				Id string `json:"id"`

				// Metadata Metadata about the source of the configuration
				Metadata *struct {
					GitHeaders *struct {
						XGitActor string                                                                   `json:"x-git-actor"`
						XGitHost  ProjectDeploymentsList_200_Items_LatestSpec_Metadata_GitHeaders_XGitHost `json:"x-git-host"`
						XGitOwner string                                                                   `json:"x-git-owner"`
						XGitRef   string                                                                   `json:"x-git-ref"`
						XGitRepo  string                                                                   `json:"x-git-repo"`
						XGitSha   string                                                                   `json:"x-git-sha"`
					} `json:"gitHeaders,omitempty"`
				} `json:"metadata"`

				// UserId The ID of the user the deployment belongs to
				UserId string `json:"userId"`
			} `json:"latestSpec"`

			// LatestSpecHash The last version hash for the deployment
			LatestSpecHash *string `json:"latestSpecHash"`

			// Name The name of the deployment
			Name string `json:"name"`

			// ProjectId The ID of the project the deployment belongs to
			ProjectId string `json:"projectId"`

			// TeamId The ID of the team the deployment belongs to
			TeamId string `json:"teamId"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}
type ProjectDeploymentsList200ItemsLatestSpecData0 struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData00 struct {
	ApiVersion        ProjectDeploymentsList200ItemsLatestSpecData00ApiVersion `json:"apiVersion"`
	Command           *[]string                                                `json:"command,omitempty"`
	ContainerRegistry *string                                                  `json:"containerRegistry,omitempty"`
	Enabled           *bool                                                    `json:"enabled,omitempty"`
	Env               *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"env,omitempty"`
	HealthChecks *struct {
		Liveness  *ProjectDeploymentsList_200_Items_LatestSpec_Data_0_0_HealthChecks_Liveness  `json:"liveness,omitempty"`
		Readiness *ProjectDeploymentsList_200_Items_LatestSpec_Data_0_0_HealthChecks_Readiness `json:"readiness,omitempty"`
		Startup   *ProjectDeploymentsList_200_Items_LatestSpec_Data_0_0_HealthChecks_Startup   `json:"startup,omitempty"`
	} `json:"healthChecks,omitempty"`
	Image  string `json:"image"`
	Models *[]struct {
		Id   string  `json:"id"`
		Path *string `json:"path,omitempty"`
	} `json:"models,omitempty"`
	Name         string                                                       `json:"name"`
	Port         *float32                                                     `json:"port,omitempty"`
	Region       *ProjectDeploymentsList_200_Items_LatestSpec_Data_0_0_Region `json:"region,omitempty"`
	Repositories *struct {
		Dataset      string  `json:"dataset"`
		MountPath    *string `json:"mountPath,omitempty"`
		Repositories []struct {
			Name     string  `json:"name"`
			Password *string `json:"password,omitempty"`
			Ref      *string `json:"ref,omitempty"`
			Url      string  `json:"url"`
			Username *string `json:"username,omitempty"`
		} `json:"repositories"`
	} `json:"repositories,omitempty"`
	Resources struct {
		Autoscaling *struct {
			Enabled     *bool                                                                                     `json:"enabled,omitempty"`
			MaxReplicas float32                                                                                   `json:"maxReplicas"`
			Metrics     []ProjectDeploymentsList_200_Items_LatestSpec_Data_0_0_Resources_Autoscaling_Metrics_Item `json:"metrics"`
		} `json:"autoscaling,omitempty"`
		InstanceType string   `json:"instanceType"`
		Replicas     *float32 `json:"replicas,omitempty"`
	} `json:"resources"`
}
type ProjectDeploymentsList200ItemsLatestSpecData00ApiVersion string
type ProjectDeploymentsList200ItemsLatestSpecData00HealthChecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList200ItemsLatestSpecData00HealthChecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList_200_Items_LatestSpec_Data_0_0_HealthChecks_Liveness struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData00HealthChecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList200ItemsLatestSpecData00HealthChecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList_200_Items_LatestSpec_Data_0_0_HealthChecks_Readiness struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData00HealthChecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList200ItemsLatestSpecData00HealthChecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList_200_Items_LatestSpec_Data_0_0_HealthChecks_Startup struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData00Region0 string
type ProjectDeploymentsList200ItemsLatestSpecData00Region1 string
type ProjectDeploymentsList200ItemsLatestSpecData00Region2 string
type ProjectDeploymentsList200ItemsLatestSpecData00Region3 = string
type ProjectDeploymentsList_200_Items_LatestSpec_Data_0_0_Region struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics0 struct {
	Metric  ProjectDeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics0Metric  `json:"metric"`
	Summary ProjectDeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics0Summary `json:"summary"`
	Value   float32                                                                           `json:"value"`
}
type ProjectDeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics0Metric string
type ProjectDeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics0Summary string
type ProjectDeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics1 struct {
	Metric  ProjectDeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics1Metric  `json:"metric"`
	Summary ProjectDeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics1Summary `json:"summary"`
	Value   int                                                                               `json:"value"`
}
type ProjectDeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics1Metric string
type ProjectDeploymentsList200ItemsLatestSpecData00ResourcesAutoscalingMetrics1Summary string
type ProjectDeploymentsList_200_Items_LatestSpec_Data_0_0_Resources_Autoscaling_Metrics_Item struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData01 struct {
	ApiVersion        ProjectDeploymentsList200ItemsLatestSpecData01ApiVersion `json:"apiVersion"`
	BasicAuthKey      *string                                                  `json:"basicAuthKey,omitempty"`
	Command           *[]string                                                `json:"command,omitempty"`
	ContainerRegistry *string                                                  `json:"containerRegistry,omitempty"`
	Enabled           *bool                                                    `json:"enabled,omitempty"`
	Env               *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"env,omitempty"`
	HealthChecks *struct {
		Liveness  *ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_HealthChecks_Liveness  `json:"liveness,omitempty"`
		Readiness *ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_HealthChecks_Readiness `json:"readiness,omitempty"`
		Startup   *ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_HealthChecks_Startup   `json:"startup,omitempty"`
	} `json:"healthChecks,omitempty"`
	Healthchecks *struct {
		Liveness  *ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_Healthchecks_Liveness  `json:"liveness,omitempty"`
		Readiness *ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_Healthchecks_Readiness `json:"readiness,omitempty"`
		Startup   *ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_Healthchecks_Startup   `json:"startup,omitempty"`
	} `json:"healthchecks,omitempty"`
	Image        string                                                                    `json:"image"`
	Integrations *[]ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_Integrations_Item `json:"integrations,omitempty"`
	Name         string                                                                    `json:"name"`
	Region       *ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_Region              `json:"region,omitempty"`
	Resources    struct {
		Autoscaling *struct {
			Enabled     *bool                                                                                     `json:"enabled,omitempty"`
			MaxReplicas float32                                                                                   `json:"maxReplicas"`
			Metrics     []ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_Resources_Autoscaling_Metrics_Item `json:"metrics"`
		} `json:"autoscaling,omitempty"`
		MachineType string    `json:"machineType"`
		Ports       []float32 `json:"ports"`
		Replicas    *float32  `json:"replicas,omitempty"`
	} `json:"resources"`
}
type ProjectDeploymentsList200ItemsLatestSpecData01ApiVersion string
type ProjectDeploymentsList200ItemsLatestSpecData01HealthChecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList200ItemsLatestSpecData01HealthChecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_HealthChecks_Liveness struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData01HealthChecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList200ItemsLatestSpecData01HealthChecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_HealthChecks_Readiness struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData01HealthChecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList200ItemsLatestSpecData01HealthChecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_HealthChecks_Startup struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData01HealthchecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList200ItemsLatestSpecData01HealthchecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_Healthchecks_Liveness struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData01HealthchecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList200ItemsLatestSpecData01HealthchecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_Healthchecks_Readiness struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData01HealthchecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList200ItemsLatestSpecData01HealthchecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_Healthchecks_Startup struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData01Integrations0 struct {
	Id   string                                                          `json:"id"`
	Name string                                                          `json:"name"`
	Path *string                                                         `json:"path,omitempty"`
	Type ProjectDeploymentsList200ItemsLatestSpecData01Integrations0Type `json:"type"`
}
type ProjectDeploymentsList200ItemsLatestSpecData01Integrations0Type string
type ProjectDeploymentsList200ItemsLatestSpecData01Integrations1 struct {
	AccessKeyId     *string                                                                     `json:"accessKeyId,omitempty"`
	Endpoint        *string                                                                     `json:"endpoint,omitempty"`
	Name            string                                                                      `json:"name"`
	Path            *string                                                                     `json:"path,omitempty"`
	Region          *ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_Integrations_1_Region `json:"region,omitempty"`
	SecretAccessKey *string                                                                     `json:"secretAccessKey,omitempty"`
	Type            ProjectDeploymentsList200ItemsLatestSpecData01Integrations1Type             `json:"type"`
	Url             string                                                                      `json:"url"`
}
type ProjectDeploymentsList200ItemsLatestSpecData01Integrations1Region0 string
type ProjectDeploymentsList200ItemsLatestSpecData01Integrations1Region1 string
type ProjectDeploymentsList200ItemsLatestSpecData01Integrations1Region2 string
type ProjectDeploymentsList200ItemsLatestSpecData01Integrations1Region3 = string
type ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_Integrations_1_Region struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData01Integrations1Type string
type ProjectDeploymentsList200ItemsLatestSpecData01Integrations2 struct {
	AccessKeyId     *string                                                         `json:"accessKeyId,omitempty"`
	Endpoint        string                                                          `json:"endpoint"`
	Name            string                                                          `json:"name"`
	Path            *string                                                         `json:"path,omitempty"`
	SecretAccessKey *string                                                         `json:"secretAccessKey,omitempty"`
	Type            ProjectDeploymentsList200ItemsLatestSpecData01Integrations2Type `json:"type"`
}
type ProjectDeploymentsList200ItemsLatestSpecData01Integrations2Type string
type ProjectDeploymentsList200ItemsLatestSpecData01Integrations3 struct {
	Name string                                                          `json:"name"`
	Type ProjectDeploymentsList200ItemsLatestSpecData01Integrations3Type `json:"type"`
}
type ProjectDeploymentsList200ItemsLatestSpecData01Integrations3Type string
type ProjectDeploymentsList200ItemsLatestSpecData01Integrations4 struct {
	Name string                                                          `json:"name"`
	Path *string                                                         `json:"path,omitempty"`
	Type ProjectDeploymentsList200ItemsLatestSpecData01Integrations4Type `json:"type"`
	Url  string                                                          `json:"url"`
}
type ProjectDeploymentsList200ItemsLatestSpecData01Integrations4Type string
type ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_Integrations_Item struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData01Region0 string
type ProjectDeploymentsList200ItemsLatestSpecData01Region1 string
type ProjectDeploymentsList200ItemsLatestSpecData01Region2 string
type ProjectDeploymentsList200ItemsLatestSpecData01Region3 = string
type ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_Region struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics0 struct {
	Metric  ProjectDeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics0Metric  `json:"metric"`
	Summary ProjectDeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics0Summary `json:"summary"`
	Value   float32                                                                           `json:"value"`
}
type ProjectDeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics0Metric string
type ProjectDeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics0Summary string
type ProjectDeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics1 struct {
	Metric  ProjectDeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics1Metric  `json:"metric"`
	Summary ProjectDeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics1Summary `json:"summary"`
	Value   int                                                                               `json:"value"`
}
type ProjectDeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics1Metric string
type ProjectDeploymentsList200ItemsLatestSpecData01ResourcesAutoscalingMetrics1Summary string
type ProjectDeploymentsList_200_Items_LatestSpec_Data_0_1_Resources_Autoscaling_Metrics_Item struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData1 struct {
	ApiVersion        ProjectDeploymentsList_200_Items_LatestSpec_Data_1_ApiVersion `json:"apiVersion"`
	BasicAuthKey      *string                                                       `json:"basicAuthKey,omitempty"`
	Command           *[]string                                                     `json:"command,omitempty"`
	ContainerRegistry *string                                                       `json:"containerRegistry,omitempty"`
	Enabled           *bool                                                         `json:"enabled,omitempty"`
	Env               *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"env,omitempty"`
	HealthChecks *struct {
		Liveness  *ProjectDeploymentsList_200_Items_LatestSpec_Data_1_HealthChecks_Liveness  `json:"liveness,omitempty"`
		Readiness *ProjectDeploymentsList_200_Items_LatestSpec_Data_1_HealthChecks_Readiness `json:"readiness,omitempty"`
		Startup   *ProjectDeploymentsList_200_Items_LatestSpec_Data_1_HealthChecks_Startup   `json:"startup,omitempty"`
	} `json:"healthChecks,omitempty"`
	Healthchecks *struct {
		Liveness  *ProjectDeploymentsList_200_Items_LatestSpec_Data_1_Healthchecks_Liveness  `json:"liveness,omitempty"`
		Readiness *ProjectDeploymentsList_200_Items_LatestSpec_Data_1_Healthchecks_Readiness `json:"readiness,omitempty"`
		Startup   *ProjectDeploymentsList_200_Items_LatestSpec_Data_1_Healthchecks_Startup   `json:"startup,omitempty"`
	} `json:"healthchecks,omitempty"`
	Image        string                                                                  `json:"image"`
	Integrations *[]ProjectDeploymentsList_200_Items_LatestSpec_Data_1_Integrations_Item `json:"integrations,omitempty"`
	Name         string                                                                  `json:"name"`
	Region       *ProjectDeploymentsList_200_Items_LatestSpec_Data_1_Region              `json:"region,omitempty"`
	Resources    struct {
		Autoscaling *struct {
			Enabled     *bool                                                                                   `json:"enabled,omitempty"`
			MaxReplicas float32                                                                                 `json:"maxReplicas"`
			Metrics     []ProjectDeploymentsList_200_Items_LatestSpec_Data_1_Resources_Autoscaling_Metrics_Item `json:"metrics"`
		} `json:"autoscaling,omitempty"`
		MachineType string    `json:"machineType"`
		Ports       []float32 `json:"ports"`
		Replicas    *float32  `json:"replicas,omitempty"`
	} `json:"resources"`
}
type ProjectDeploymentsList200ItemsLatestSpecData1ApiVersion0 string
type ProjectDeploymentsList200ItemsLatestSpecData1ApiVersion1 string
type ProjectDeploymentsList_200_Items_LatestSpec_Data_1_ApiVersion struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData1HealthChecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList200ItemsLatestSpecData1HealthChecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList_200_Items_LatestSpec_Data_1_HealthChecks_Liveness struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData1HealthChecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList200ItemsLatestSpecData1HealthChecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList_200_Items_LatestSpec_Data_1_HealthChecks_Readiness struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData1HealthChecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList200ItemsLatestSpecData1HealthChecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList_200_Items_LatestSpec_Data_1_HealthChecks_Startup struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData1HealthchecksLiveness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList200ItemsLatestSpecData1HealthchecksLiveness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList_200_Items_LatestSpec_Data_1_Healthchecks_Liveness struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData1HealthchecksReadiness0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList200ItemsLatestSpecData1HealthchecksReadiness1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList_200_Items_LatestSpec_Data_1_Healthchecks_Readiness struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData1HealthchecksStartup0 struct {
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`
	Headers          *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Host                *string  `json:"host,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	Path                string   `json:"path"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	Port                *float32 `json:"port,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList200ItemsLatestSpecData1HealthchecksStartup1 struct {
	Exec struct {
		Command []string `json:"command"`
	} `json:"exec"`
	FailureThreshold    *float32 `json:"failureThreshold,omitempty"`
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds       *float32 `json:"periodSeconds,omitempty"`
	TimeoutSeconds      *float32 `json:"timeoutSeconds,omitempty"`
}
type ProjectDeploymentsList_200_Items_LatestSpec_Data_1_Healthchecks_Startup struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData1Integrations0 struct {
	Id   string                                                         `json:"id"`
	Name string                                                         `json:"name"`
	Path *string                                                        `json:"path,omitempty"`
	Type ProjectDeploymentsList200ItemsLatestSpecData1Integrations0Type `json:"type"`
}
type ProjectDeploymentsList200ItemsLatestSpecData1Integrations0Type string
type ProjectDeploymentsList200ItemsLatestSpecData1Integrations1 struct {
	AccessKeyId     *string                                                                   `json:"accessKeyId,omitempty"`
	Endpoint        *string                                                                   `json:"endpoint,omitempty"`
	Name            string                                                                    `json:"name"`
	Path            *string                                                                   `json:"path,omitempty"`
	Region          *ProjectDeploymentsList_200_Items_LatestSpec_Data_1_Integrations_1_Region `json:"region,omitempty"`
	SecretAccessKey *string                                                                   `json:"secretAccessKey,omitempty"`
	Type            ProjectDeploymentsList200ItemsLatestSpecData1Integrations1Type            `json:"type"`
	Url             string                                                                    `json:"url"`
}
type ProjectDeploymentsList200ItemsLatestSpecData1Integrations1Region0 string
type ProjectDeploymentsList200ItemsLatestSpecData1Integrations1Region1 string
type ProjectDeploymentsList200ItemsLatestSpecData1Integrations1Region2 string
type ProjectDeploymentsList200ItemsLatestSpecData1Integrations1Region3 = string
type ProjectDeploymentsList_200_Items_LatestSpec_Data_1_Integrations_1_Region struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData1Integrations1Type string
type ProjectDeploymentsList200ItemsLatestSpecData1Integrations2 struct {
	AccessKeyId     *string                                                        `json:"accessKeyId,omitempty"`
	Endpoint        string                                                         `json:"endpoint"`
	Name            string                                                         `json:"name"`
	Path            *string                                                        `json:"path,omitempty"`
	SecretAccessKey *string                                                        `json:"secretAccessKey,omitempty"`
	Type            ProjectDeploymentsList200ItemsLatestSpecData1Integrations2Type `json:"type"`
}
type ProjectDeploymentsList200ItemsLatestSpecData1Integrations2Type string
type ProjectDeploymentsList200ItemsLatestSpecData1Integrations3 struct {
	Name string                                                         `json:"name"`
	Type ProjectDeploymentsList200ItemsLatestSpecData1Integrations3Type `json:"type"`
}
type ProjectDeploymentsList200ItemsLatestSpecData1Integrations3Type string
type ProjectDeploymentsList200ItemsLatestSpecData1Integrations4 struct {
	Name string                                                         `json:"name"`
	Path *string                                                        `json:"path,omitempty"`
	Type ProjectDeploymentsList200ItemsLatestSpecData1Integrations4Type `json:"type"`
	Url  string                                                         `json:"url"`
}
type ProjectDeploymentsList200ItemsLatestSpecData1Integrations4Type string
type ProjectDeploymentsList_200_Items_LatestSpec_Data_1_Integrations_Item struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData1Region0 string
type ProjectDeploymentsList200ItemsLatestSpecData1Region1 string
type ProjectDeploymentsList200ItemsLatestSpecData1Region2 string
type ProjectDeploymentsList200ItemsLatestSpecData1Region3 = string
type ProjectDeploymentsList_200_Items_LatestSpec_Data_1_Region struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics0 struct {
	Metric  ProjectDeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics0Metric  `json:"metric"`
	Summary ProjectDeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics0Summary `json:"summary"`
	Value   float32                                                                          `json:"value"`
}
type ProjectDeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics0Metric string
type ProjectDeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics0Summary string
type ProjectDeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics1 struct {
	Metric  ProjectDeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics1Metric  `json:"metric"`
	Summary ProjectDeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics1Summary `json:"summary"`
	Value   int                                                                              `json:"value"`
}
type ProjectDeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics1Metric string
type ProjectDeploymentsList200ItemsLatestSpecData1ResourcesAutoscalingMetrics1Summary string
type ProjectDeploymentsList_200_Items_LatestSpec_Data_1_Resources_Autoscaling_Metrics_Item struct {
	union json.RawMessage
}
type ProjectDeploymentsList_200_Items_LatestSpec_Data struct {
	union json.RawMessage
}
type ProjectDeploymentsList200ItemsLatestSpecMetadataGitHeadersXGitHost0 string
type ProjectDeploymentsList200ItemsLatestSpecMetadataGitHeadersXGitHost1 string
type ProjectDeploymentsList_200_Items_LatestSpec_Metadata_GitHeaders_XGitHost struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r ProjectDeploymentsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectDeploymentsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectModelsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// Description The description of the dataset
			Description *string `json:"description"`

			// DtCreated The date the dataset was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the dataset was last modified
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the dataset
			Id string `json:"id"`

			// IsPublic Whether the dataset is public
			IsPublic bool `json:"isPublic"`

			// Name The name of the dataset
			Name string `json:"name"`

			// ProjectId The ID of the project
			ProjectId *string `json:"projectId"`

			// StorageProviderId The ID of the storage provider
			StorageProviderId *string `json:"storageProviderId"`

			// TeamId The ID of the team that owns the dataset
			TeamId string `json:"teamId"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectModelsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectModelsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectModelsRemoveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Description The description of the dataset
		Description *string `json:"description"`

		// DtCreated The date the dataset was created
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the dataset was last modified
		DtModified time.Time `json:"dtModified"`

		// Id The ID of the dataset
		Id string `json:"id"`

		// IsPublic Whether the dataset is public
		IsPublic bool `json:"isPublic"`

		// Name The name of the dataset
		Name string `json:"name"`

		// ProjectId The ID of the project
		ProjectId *string `json:"projectId"`

		// StorageProviderId The ID of the storage provider
		StorageProviderId *string `json:"storageProviderId"`

		// TeamId The ID of the team that owns the dataset
		TeamId string `json:"teamId"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectModelsRemoveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectModelsRemoveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectModelsAddResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Description The description of the dataset
		Description *string `json:"description"`

		// DtCreated The date the dataset was created
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the dataset was last modified
		DtModified time.Time `json:"dtModified"`

		// Id The ID of the dataset
		Id string `json:"id"`

		// IsPublic Whether the dataset is public
		IsPublic bool `json:"isPublic"`

		// Name The name of the dataset
		Name string `json:"name"`

		// ProjectId The ID of the project
		ProjectId *string `json:"projectId"`

		// StorageProviderId The ID of the storage provider
		StorageProviderId *string `json:"storageProviderId"`

		// TeamId The ID of the team that owns the dataset
		TeamId string `json:"teamId"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectModelsAddResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectModelsAddResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectSecretsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// DtCreated The date the secret was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the secret was last modified.
			DtModified            time.Time `json:"dtModified"`
			HasDeploymentAttached bool      `json:"hasDeploymentAttached"`

			// Name The name of the secret, e.g. "DB_PASSWORD".
			Name string `json:"name"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectSecretsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectSecretsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectSecretsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the secret was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the secret was last modified.
		DtModified time.Time `json:"dtModified"`

		// Name The name of the secret, e.g. "DB_PASSWORD".
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectSecretsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectSecretsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectSecretsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Name The name of the secret, e.g. "DB_PASSWORD".
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectSecretsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectSecretsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectSecretsGetProjectSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the secret was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the secret was last modified.
		DtModified            time.Time `json:"dtModified"`
		HasDeploymentAttached bool      `json:"hasDeploymentAttached"`

		// Name The name of the secret, e.g. "DB_PASSWORD".
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectSecretsGetProjectSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectSecretsGetProjectSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectSecretsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the secret was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the secret was last modified.
		DtModified time.Time `json:"dtModified"`

		// Name The name of the secret, e.g. "DB_PASSWORD".
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectSecretsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectSecretsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectTagsRemoveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the notebook was created
		DtCreated time.Time `json:"dtCreated"`

		// Id The ID of the tag
		Id float32 `json:"id"`

		// Name The name of the tag
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectTagsRemoveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectTagsRemoveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectTagsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// DtCreated The date the notebook was created
			DtCreated time.Time `json:"dtCreated"`

			// Id The ID of the tag
			Id float32 `json:"id"`

			// Name The name of the tag
			Name string `json:"name"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectTagsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectTagsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectTagsAddResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the notebook was created
		DtCreated time.Time `json:"dtCreated"`

		// Id The ID of the tag
		Id float32 `json:"id"`

		// Name The name of the tag
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProjectTagsAddResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectTagsAddResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublicIpsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// AssignedMachineId The ID of the machine the public IP is assigned to.
			AssignedMachineId *string `json:"assignedMachineId,omitempty"`

			// DtCreated The date the public IP was claimed.
			DtCreated time.Time `json:"dtCreated"`

			// Ip The IP address of the public IP.
			Ip string `json:"ip"`

			// Region The region of the public IP.
			Region PublicIpsList_200_Items_Region `json:"region"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}
type PublicIpsList200ItemsRegion0 string
type PublicIpsList200ItemsRegion1 string
type PublicIpsList200ItemsRegion2 string
type PublicIpsList200ItemsRegion3 = string
type PublicIpsList_200_Items_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PublicIpsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublicIpsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublicIpsClaimResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AssignedMachineId The ID of the machine the public IP is assigned to.
		AssignedMachineId *string `json:"assignedMachineId,omitempty"`

		// DtCreated The date the public IP was claimed.
		DtCreated time.Time `json:"dtCreated"`

		// Ip The IP address of the public IP.
		Ip string `json:"ip"`

		// Region The region of the public IP.
		Region PublicIpsClaim_200_Region `json:"region"`
	}
	JSONDefault *Error
}
type PublicIpsClaim200Region0 string
type PublicIpsClaim200Region1 string
type PublicIpsClaim200Region2 string
type PublicIpsClaim200Region3 = string
type PublicIpsClaim_200_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PublicIpsClaimResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublicIpsClaimResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublicIpsReleaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ip string `json:"ip"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PublicIpsReleaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublicIpsReleaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublicIpsAssignResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AssignedMachineId The ID of the machine the public IP is assigned to.
		AssignedMachineId *string `json:"assignedMachineId,omitempty"`

		// DtCreated The date the public IP was claimed.
		DtCreated time.Time `json:"dtCreated"`

		// Ip The IP address of the public IP.
		Ip string `json:"ip"`

		// Region The region of the public IP.
		Region PublicIpsAssign_200_Region `json:"region"`
	}
	JSONDefault *Error
}
type PublicIpsAssign200Region0 string
type PublicIpsAssign200Region1 string
type PublicIpsAssign200Region2 string
type PublicIpsAssign200Region3 = string
type PublicIpsAssign_200_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PublicIpsAssignResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublicIpsAssignResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SharedDrivesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// DtCreated The date the shared drive was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the shared drive was deleted.
			DtDeleted *SharedDrivesList_200_Items_DtDeleted `json:"dtDeleted"`

			// Id The ID of the shared drive.
			Id string `json:"id"`

			// MountPoint The mount point of the shared drive.
			MountPoint string `json:"mountPoint"`

			// Name The name of the shared drive.
			Name string `json:"name"`

			// NetworkId The ID of the network the shared drive is in.
			NetworkId string `json:"networkId"`

			// Password The password of the shared drive.
			Password string `json:"password"`

			// Region The region the shared drive is in.
			Region SharedDrivesList_200_Items_Region `json:"region"`

			// Size The size of the shared drive.
			Size int64 `json:"size"`

			// Username The username of the shared drive.
			Username string `json:"username"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}
type SharedDrivesList200ItemsDtDeleted0 = interface{}
type SharedDrivesList200ItemsDtDeleted1 = time.Time
type SharedDrivesList_200_Items_DtDeleted struct {
	union json.RawMessage
}
type SharedDrivesList200ItemsRegion0 string
type SharedDrivesList200ItemsRegion1 string
type SharedDrivesList200ItemsRegion2 string
type SharedDrivesList200ItemsRegion3 = string
type SharedDrivesList_200_Items_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r SharedDrivesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SharedDrivesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SharedDrivesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the shared drive was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the shared drive was deleted.
		DtDeleted *SharedDrivesCreate_200_DtDeleted `json:"dtDeleted"`

		// Id The ID of the shared drive.
		Id string `json:"id"`

		// MountPoint The mount point of the shared drive.
		MountPoint string `json:"mountPoint"`

		// Name The name of the shared drive.
		Name string `json:"name"`

		// NetworkId The ID of the network the shared drive is in.
		NetworkId string `json:"networkId"`

		// Password The password of the shared drive.
		Password string `json:"password"`

		// Region The region the shared drive is in.
		Region SharedDrivesCreate_200_Region `json:"region"`

		// Size The size of the shared drive.
		Size int64 `json:"size"`

		// Username The username of the shared drive.
		Username string `json:"username"`
	}
	JSONDefault *Error
}
type SharedDrivesCreate200DtDeleted0 = interface{}
type SharedDrivesCreate200DtDeleted1 = time.Time
type SharedDrivesCreate_200_DtDeleted struct {
	union json.RawMessage
}
type SharedDrivesCreate200Region0 string
type SharedDrivesCreate200Region1 string
type SharedDrivesCreate200Region2 string
type SharedDrivesCreate200Region3 = string
type SharedDrivesCreate_200_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r SharedDrivesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SharedDrivesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SharedDrivesDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The ID of the deleted shared drive.
		Id string `json:"id"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r SharedDrivesDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SharedDrivesDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SharedDrivesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the shared drive was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the shared drive was deleted.
		DtDeleted *SharedDrivesGet_200_DtDeleted `json:"dtDeleted"`

		// Id The ID of the shared drive.
		Id string `json:"id"`

		// MountPoint The mount point of the shared drive.
		MountPoint string `json:"mountPoint"`

		// Name The name of the shared drive.
		Name string `json:"name"`

		// NetworkId The ID of the network the shared drive is in.
		NetworkId string `json:"networkId"`

		// Password The password of the shared drive.
		Password string `json:"password"`

		// Region The region the shared drive is in.
		Region SharedDrivesGet_200_Region `json:"region"`

		// Size The size of the shared drive.
		Size int64 `json:"size"`

		// Username The username of the shared drive.
		Username string `json:"username"`
	}
	JSONDefault *Error
}
type SharedDrivesGet200DtDeleted0 = interface{}
type SharedDrivesGet200DtDeleted1 = time.Time
type SharedDrivesGet_200_DtDeleted struct {
	union json.RawMessage
}
type SharedDrivesGet200Region0 string
type SharedDrivesGet200Region1 string
type SharedDrivesGet200Region2 string
type SharedDrivesGet200Region3 = string
type SharedDrivesGet_200_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r SharedDrivesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SharedDrivesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SharedDrivesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the shared drive was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the shared drive was deleted.
		DtDeleted *SharedDrivesUpdate_200_DtDeleted `json:"dtDeleted"`

		// Id The ID of the shared drive.
		Id string `json:"id"`

		// MountPoint The mount point of the shared drive.
		MountPoint string `json:"mountPoint"`

		// Name The name of the shared drive.
		Name string `json:"name"`

		// NetworkId The ID of the network the shared drive is in.
		NetworkId string `json:"networkId"`

		// Password The password of the shared drive.
		Password string `json:"password"`

		// Region The region the shared drive is in.
		Region SharedDrivesUpdate_200_Region `json:"region"`

		// Size The size of the shared drive.
		Size int64 `json:"size"`

		// Username The username of the shared drive.
		Username string `json:"username"`
	}
	JSONDefault *Error
}
type SharedDrivesUpdate200DtDeleted0 = interface{}
type SharedDrivesUpdate200DtDeleted1 = time.Time
type SharedDrivesUpdate_200_DtDeleted struct {
	union json.RawMessage
}
type SharedDrivesUpdate200Region0 string
type SharedDrivesUpdate200Region1 string
type SharedDrivesUpdate200Region2 string
type SharedDrivesUpdate200Region3 = string
type SharedDrivesUpdate_200_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r SharedDrivesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SharedDrivesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnapshotsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// Id The ID of the snapshot.
			Id string `json:"id"`

			// IsAutoSnapshot Whether the snapshot was made automatically.
			IsAutoSnapshot bool `json:"isAutoSnapshot"`

			// MachineId The ID of the machine the snapshot is for.
			MachineId string `json:"machineId"`

			// Name The name of the snapshot.
			Name string `json:"name"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r SnapshotsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnapshotsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnapshotsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The snapshot.
		Data struct {
			// Id The ID of the snapshot.
			Id string `json:"id"`

			// IsAutoSnapshot Whether the snapshot was made automatically.
			IsAutoSnapshot bool `json:"isAutoSnapshot"`

			// MachineId The ID of the machine the snapshot is for.
			MachineId string `json:"machineId"`

			// Name The name of the snapshot.
			Name string `json:"name"`
		} `json:"data"`

		// Event The machine event to poll for the async operation.
		Event struct {
			// DtCreated The date the event was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtFinished The date the event was finished.
			DtFinished *time.Time `json:"dtFinished"`

			// DtStarted The date the event was started.
			DtStarted *time.Time `json:"dtStarted"`

			// Error The error message of the event, if any.
			Error *string `json:"error"`

			// Id The ID of the event.
			Id string `json:"id"`

			// MachineId The ID of the machine the event is for.
			MachineId *string `json:"machineId"`

			// Name The name of the event, e.g. "create".
			Name SnapshotsCreate200EventName `json:"name"`

			// State The state of the event, e.g. "done".
			State SnapshotsCreate200EventState `json:"state"`
		} `json:"event"`
	}
	JSONDefault *Error
}
type SnapshotsCreate200EventName string
type SnapshotsCreate200EventState string

// Status returns HTTPResponse.Status
func (r SnapshotsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnapshotsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnapshotsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The snapshot.
		Data struct {
			// Id The ID of the snapshot.
			Id string `json:"id"`

			// IsAutoSnapshot Whether the snapshot was made automatically.
			IsAutoSnapshot bool `json:"isAutoSnapshot"`

			// MachineId The ID of the machine the snapshot is for.
			MachineId string `json:"machineId"`

			// Name The name of the snapshot.
			Name string `json:"name"`
		} `json:"data"`

		// Event The machine event to poll for the async operation.
		Event struct {
			// DtCreated The date the event was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtFinished The date the event was finished.
			DtFinished *time.Time `json:"dtFinished"`

			// DtStarted The date the event was started.
			DtStarted *time.Time `json:"dtStarted"`

			// Error The error message of the event, if any.
			Error *string `json:"error"`

			// Id The ID of the event.
			Id string `json:"id"`

			// MachineId The ID of the machine the event is for.
			MachineId *string `json:"machineId"`

			// Name The name of the event, e.g. "create".
			Name SnapshotsDelete200EventName `json:"name"`

			// State The state of the event, e.g. "done".
			State SnapshotsDelete200EventState `json:"state"`
		} `json:"event"`
	}
	JSONDefault *Error
}
type SnapshotsDelete200EventName string
type SnapshotsDelete200EventState string

// Status returns HTTPResponse.Status
func (r SnapshotsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnapshotsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnapshotsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The ID of the snapshot.
		Id string `json:"id"`

		// IsAutoSnapshot Whether the snapshot was made automatically.
		IsAutoSnapshot bool `json:"isAutoSnapshot"`

		// MachineId The ID of the machine the snapshot is for.
		MachineId string `json:"machineId"`

		// Name The name of the snapshot.
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r SnapshotsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnapshotsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnapshotsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The ID of the snapshot.
		Id string `json:"id"`

		// IsAutoSnapshot Whether the snapshot was made automatically.
		IsAutoSnapshot bool `json:"isAutoSnapshot"`

		// MachineId The ID of the machine the snapshot is for.
		MachineId string `json:"machineId"`

		// Name The name of the snapshot.
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r SnapshotsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnapshotsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnapshotsRestoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The snapshot.
		Data struct {
			// Id The ID of the snapshot.
			Id string `json:"id"`

			// IsAutoSnapshot Whether the snapshot was made automatically.
			IsAutoSnapshot bool `json:"isAutoSnapshot"`

			// MachineId The ID of the machine the snapshot is for.
			MachineId string `json:"machineId"`

			// Name The name of the snapshot.
			Name string `json:"name"`
		} `json:"data"`

		// Event The machine event to poll for the async operation.
		Event struct {
			// DtCreated The date the event was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtFinished The date the event was finished.
			DtFinished *time.Time `json:"dtFinished"`

			// DtStarted The date the event was started.
			DtStarted *time.Time `json:"dtStarted"`

			// Error The error message of the event, if any.
			Error *string `json:"error"`

			// Id The ID of the event.
			Id string `json:"id"`

			// MachineId The ID of the machine the event is for.
			MachineId *string `json:"machineId"`

			// Name The name of the event, e.g. "create".
			Name SnapshotsRestore200EventName `json:"name"`

			// State The state of the event, e.g. "done".
			State SnapshotsRestore200EventState `json:"state"`
		} `json:"event"`
	}
	JSONDefault *Error
}
type SnapshotsRestore200EventName string
type SnapshotsRestore200EventState string

// Status returns HTTPResponse.Status
func (r SnapshotsRestoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnapshotsRestoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartupScriptsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// AssignedMachineIds The IDs of the machines the startup script is assigned to.
			AssignedMachineIds []string `json:"assignedMachineIds"`

			// Description The description of the startup script.
			Description *string `json:"description"`

			// DtCreated The date the startup script was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the startup script was deleted.
			DtDeleted *time.Time `json:"dtDeleted"`

			// Id The ID of the startup script.
			Id string `json:"id"`

			// IsEnabled Whether the startup script is enabled.
			IsEnabled bool `json:"isEnabled"`

			// IsRunOnce Whether the startup script is run once on first boot or on every boot.
			IsRunOnce bool `json:"isRunOnce"`

			// Name The name of the startup script.
			Name string `json:"name"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r StartupScriptsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartupScriptsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartupScriptsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AssignedMachineIds The IDs of the machines the startup script is assigned to.
		AssignedMachineIds []string `json:"assignedMachineIds"`

		// Description The description of the startup script.
		Description *string `json:"description"`

		// DtCreated The date the startup script was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the startup script was deleted.
		DtDeleted *time.Time `json:"dtDeleted"`

		// Id The ID of the startup script.
		Id string `json:"id"`

		// IsEnabled Whether the startup script is enabled.
		IsEnabled bool `json:"isEnabled"`

		// IsRunOnce Whether the startup script is run once on first boot or on every boot.
		IsRunOnce bool `json:"isRunOnce"`

		// Name The name of the startup script.
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r StartupScriptsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartupScriptsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartupScriptsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AssignedMachineIds The IDs of the machines the startup script is assigned to.
		AssignedMachineIds []string `json:"assignedMachineIds"`

		// Description The description of the startup script.
		Description *string `json:"description"`

		// DtCreated The date the startup script was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the startup script was deleted.
		DtDeleted *time.Time `json:"dtDeleted"`

		// Id The ID of the startup script.
		Id string `json:"id"`

		// IsEnabled Whether the startup script is enabled.
		IsEnabled bool `json:"isEnabled"`

		// IsRunOnce Whether the startup script is run once on first boot or on every boot.
		IsRunOnce bool `json:"isRunOnce"`

		// Name The name of the startup script.
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r StartupScriptsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartupScriptsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartupScriptsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AssignedMachineIds The IDs of the machines the startup script is assigned to.
		AssignedMachineIds []string `json:"assignedMachineIds"`

		// Description The description of the startup script.
		Description *string `json:"description"`

		// DtCreated The date the startup script was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the startup script was deleted.
		DtDeleted *time.Time `json:"dtDeleted"`

		// Id The ID of the startup script.
		Id string `json:"id"`

		// IsEnabled Whether the startup script is enabled.
		IsEnabled bool `json:"isEnabled"`

		// IsRunOnce Whether the startup script is run once on first boot or on every boot.
		IsRunOnce bool `json:"isRunOnce"`

		// Name The name of the startup script.
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r StartupScriptsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartupScriptsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartupScriptsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AssignedMachineIds The IDs of the machines the startup script is assigned to.
		AssignedMachineIds []string `json:"assignedMachineIds"`

		// Description The description of the startup script.
		Description *string `json:"description"`

		// DtCreated The date the startup script was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the startup script was deleted.
		DtDeleted *time.Time `json:"dtDeleted"`

		// Id The ID of the startup script.
		Id string `json:"id"`

		// IsEnabled Whether the startup script is enabled.
		IsEnabled bool `json:"isEnabled"`

		// IsRunOnce Whether the startup script is run once on first boot or on every boot.
		IsRunOnce bool `json:"isRunOnce"`

		// Name The name of the startup script.
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r StartupScriptsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartupScriptsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartupScriptsAssignResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AssignedMachineIds The IDs of the machines the startup script is assigned to.
		AssignedMachineIds []string `json:"assignedMachineIds"`

		// Description The description of the startup script.
		Description *string `json:"description"`

		// DtCreated The date the startup script was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the startup script was deleted.
		DtDeleted *time.Time `json:"dtDeleted"`

		// Id The ID of the startup script.
		Id string `json:"id"`

		// IsEnabled Whether the startup script is enabled.
		IsEnabled bool `json:"isEnabled"`

		// IsRunOnce Whether the startup script is run once on first boot or on every boot.
		IsRunOnce bool `json:"isRunOnce"`

		// Name The name of the startup script.
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r StartupScriptsAssignResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartupScriptsAssignResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartupScriptsUnassignResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AssignedMachineIds The IDs of the machines the startup script is assigned to.
		AssignedMachineIds []string `json:"assignedMachineIds"`

		// Description The description of the startup script.
		Description *string `json:"description"`

		// DtCreated The date the startup script was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtDeleted The date the startup script was deleted.
		DtDeleted *time.Time `json:"dtDeleted"`

		// Id The ID of the startup script.
		Id string `json:"id"`

		// IsEnabled Whether the startup script is enabled.
		IsEnabled bool `json:"isEnabled"`

		// IsRunOnce Whether the startup script is run once on first boot or on every boot.
		IsRunOnce bool `json:"isRunOnce"`

		// Name The name of the startup script.
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r StartupScriptsUnassignResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartupScriptsUnassignResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StorageProvidersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// Id The ID of the storage provider
			Id string `json:"id"`

			// IsManaged Whether the storage provider is managed by Paperspace
			IsManaged bool `json:"isManaged"`

			// IsTeamDefault Whether the storage provider is the team's default provider
			IsTeamDefault *bool `json:"isTeamDefault"`

			// Name The name of the storage provider
			Name string `json:"name"`

			// S3Config The storage provider configuration
			S3Config struct {
				AccessKey        string                                          `json:"accessKey"`
				Bucket           string                                          `json:"bucket"`
				Endpoint         *string                                         `json:"endpoint"`
				Region           *StorageProvidersList_200_Items_S3Config_Region `json:"region"`
				RetainData       *bool                                           `json:"retainData"`
				SecretAccessKey  string                                          `json:"secretAccessKey"`
				SignatureVersion *string                                         `json:"signatureVersion"`
			} `json:"s3Config"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}
type StorageProvidersList200ItemsS3ConfigRegion0 string
type StorageProvidersList200ItemsS3ConfigRegion1 string
type StorageProvidersList200ItemsS3ConfigRegion2 string
type StorageProvidersList200ItemsS3ConfigRegion3 = string
type StorageProvidersList_200_Items_S3Config_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r StorageProvidersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StorageProvidersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StorageProvidersCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The ID of the storage provider
		Id string `json:"id"`

		// IsManaged Whether the storage provider is managed by Paperspace
		IsManaged bool `json:"isManaged"`

		// IsTeamDefault Whether the storage provider is the team's default provider
		IsTeamDefault *bool `json:"isTeamDefault"`

		// Name The name of the storage provider
		Name string `json:"name"`

		// S3Config The storage provider configuration
		S3Config struct {
			AccessKey        string                                      `json:"accessKey"`
			Bucket           string                                      `json:"bucket"`
			Endpoint         *string                                     `json:"endpoint"`
			Region           *StorageProvidersCreate_200_S3Config_Region `json:"region"`
			RetainData       *bool                                       `json:"retainData"`
			SecretAccessKey  string                                      `json:"secretAccessKey"`
			SignatureVersion *string                                     `json:"signatureVersion"`
		} `json:"s3Config"`
	}
	JSONDefault *Error
}
type StorageProvidersCreate200S3ConfigRegion0 string
type StorageProvidersCreate200S3ConfigRegion1 string
type StorageProvidersCreate200S3ConfigRegion2 string
type StorageProvidersCreate200S3ConfigRegion3 = string
type StorageProvidersCreate_200_S3Config_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r StorageProvidersCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StorageProvidersCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StorageUtilizationGetPublicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DatasetUsage Storage used by datasets in bytes
		DatasetUsage string `json:"datasetUsage"`

		// ModelUsage Storage used by models in bytes
		ModelUsage string `json:"modelUsage"`

		// NotebookWorkspaceUsage Storage used by notebooks files in bytes
		NotebookWorkspaceUsage string `json:"notebookWorkspaceUsage"`

		// RemainingFreeStorage The amount of free storage left before you reach your plan's limit in bytes
		RemainingFreeStorage string `json:"remainingFreeStorage"`

		// SharedStorageUsage Persistent storage used by the notebook shared storage directory in bytes
		SharedStorageUsage string `json:"sharedStorageUsage"`

		// TotalFreeStorage The amount of free storage that comes with your current plan in bytes
		TotalFreeStorage string `json:"totalFreeStorage"`

		// TotalUsage Total storage used by your team in bytes
		TotalUsage string `json:"totalUsage"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r StorageUtilizationGetPublicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StorageUtilizationGetPublicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StorageProvidersDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The ID of the storage provider
		Id string `json:"id"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r StorageProvidersDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StorageProvidersDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StorageProvidersGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The ID of the storage provider
		Id string `json:"id"`

		// IsManaged Whether the storage provider is managed by Paperspace
		IsManaged bool `json:"isManaged"`

		// IsTeamDefault Whether the storage provider is the team's default provider
		IsTeamDefault *bool `json:"isTeamDefault"`

		// Name The name of the storage provider
		Name string `json:"name"`

		// S3Config The storage provider configuration
		S3Config struct {
			AccessKey        string                                   `json:"accessKey"`
			Bucket           string                                   `json:"bucket"`
			Endpoint         *string                                  `json:"endpoint"`
			Region           *StorageProvidersGet_200_S3Config_Region `json:"region"`
			RetainData       *bool                                    `json:"retainData"`
			SecretAccessKey  string                                   `json:"secretAccessKey"`
			SignatureVersion *string                                  `json:"signatureVersion"`
		} `json:"s3Config"`
	}
	JSONDefault *Error
}
type StorageProvidersGet200S3ConfigRegion0 string
type StorageProvidersGet200S3ConfigRegion1 string
type StorageProvidersGet200S3ConfigRegion2 string
type StorageProvidersGet200S3ConfigRegion3 = string
type StorageProvidersGet_200_S3Config_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r StorageProvidersGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StorageProvidersGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StorageProvidersUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The ID of the storage provider
		Id string `json:"id"`

		// IsManaged Whether the storage provider is managed by Paperspace
		IsManaged bool `json:"isManaged"`

		// IsTeamDefault Whether the storage provider is the team's default provider
		IsTeamDefault *bool `json:"isTeamDefault"`

		// Name The name of the storage provider
		Name string `json:"name"`

		// S3Config The storage provider configuration
		S3Config struct {
			AccessKey        string                                      `json:"accessKey"`
			Bucket           string                                      `json:"bucket"`
			Endpoint         *string                                     `json:"endpoint"`
			Region           *StorageProvidersUpdate_200_S3Config_Region `json:"region"`
			RetainData       *bool                                       `json:"retainData"`
			SecretAccessKey  string                                      `json:"secretAccessKey"`
			SignatureVersion *string                                     `json:"signatureVersion"`
		} `json:"s3Config"`
	}
	JSONDefault *Error
}
type StorageProvidersUpdate200S3ConfigRegion0 string
type StorageProvidersUpdate200S3ConfigRegion1 string
type StorageProvidersUpdate200S3ConfigRegion2 string
type StorageProvidersUpdate200S3ConfigRegion3 = string
type StorageProvidersUpdate_200_S3Config_Region struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r StorageProvidersUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StorageProvidersUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamSecretsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// DtCreated The date the secret was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the secret was last modified.
			DtModified            time.Time `json:"dtModified"`
			HasDeploymentAttached bool      `json:"hasDeploymentAttached"`

			// Name The name of the secret, e.g. "DB_PASSWORD".
			Name string `json:"name"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r TeamSecretsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamSecretsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamSecretsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the secret was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the secret was last modified.
		DtModified time.Time `json:"dtModified"`

		// Name The name of the secret, e.g. "DB_PASSWORD".
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r TeamSecretsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamSecretsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamSecretsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Name The name of the secret, e.g. "DB_PASSWORD".
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r TeamSecretsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamSecretsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamSecretsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the secret was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the secret was last modified.
		DtModified            time.Time `json:"dtModified"`
		HasDeploymentAttached bool      `json:"hasDeploymentAttached"`

		// Name The name of the secret, e.g. "DB_PASSWORD".
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r TeamSecretsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamSecretsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamSecretsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtCreated The date the secret was created.
		DtCreated time.Time `json:"dtCreated"`

		// DtModified The date the secret was last modified.
		DtModified time.Time `json:"dtModified"`

		// Name The name of the secret, e.g. "DB_PASSWORD".
		Name string `json:"name"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r TeamSecretsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamSecretsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamMembershipsListByTeamIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasMore Whether there are more pages of results available.
		HasMore bool `json:"hasMore"`

		// Items The items on this page.
		Items []struct {
			// DtConfirmed The date the user confirmed their membership
			DtConfirmed *time.Time `json:"dtConfirmed"`

			// IsAdmin Whether the user is an admin of the team
			IsAdmin bool `json:"isAdmin"`

			// IsOwner Whether the user is the owner of the team
			IsOwner bool `json:"isOwner"`
			User    struct {
				// Email The email address of the user
				Email string `json:"email"`

				// FirstName The first name of the user
				FirstName *string `json:"firstName"`

				// Id The ID of the user
				Id string `json:"id"`

				// LastActive The date the user was last active.
				LastActive *time.Time `json:"lastActive"`

				// LastName The last name of the user
				LastName *string `json:"lastName"`

				// PublicProfileImageUrl The URL of the team's profile image.
				PublicProfileImageUrl *string `json:"publicProfileImageUrl"`
			} `json:"user"`
		} `json:"items"`

		// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
		NextPage *string `json:"nextPage,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r TeamMembershipsListByTeamIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamMembershipsListByTeamIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamMembershipsRemoveUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtConfirmed The date the user confirmed their membership
		DtConfirmed *time.Time `json:"dtConfirmed"`

		// DtDeleted The date the user was removed from the team
		DtDeleted *time.Time `json:"dtDeleted"`

		// IsAdmin Whether the user is an admin of the team
		IsAdmin bool `json:"isAdmin"`

		// IsOwner Whether the user is the owner of the team
		IsOwner bool `json:"isOwner"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r TeamMembershipsRemoveUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamMembershipsRemoveUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamMembershipsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DtConfirmed The date the user confirmed their membership
		DtConfirmed *time.Time `json:"dtConfirmed"`

		// DtDeleted The date the user was removed from the team
		DtDeleted *time.Time `json:"dtDeleted"`

		// IsAdmin Whether the user is an admin of the team
		IsAdmin bool `json:"isAdmin"`

		// IsOwner Whether the user is the owner of the team
		IsOwner bool `json:"isOwner"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r TeamMembershipsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamMembershipsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AuthSessionWithResponse request returning *AuthSessionResponse
func (c *ClientWithResponses) AuthSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthSessionResponse, error) {
	rsp, err := c.AuthSession(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthSessionResponse(rsp)
}

// ContainerRegistriesListWithResponse request returning *ContainerRegistriesListResponse
func (c *ClientWithResponses) ContainerRegistriesListWithResponse(ctx context.Context, params *ContainerRegistriesListParams, reqEditors ...RequestEditorFn) (*ContainerRegistriesListResponse, error) {
	rsp, err := c.ContainerRegistriesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContainerRegistriesListResponse(rsp)
}

// ContainerRegistriesCreateWithBodyWithResponse request with arbitrary body returning *ContainerRegistriesCreateResponse
func (c *ClientWithResponses) ContainerRegistriesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ContainerRegistriesCreateResponse, error) {
	rsp, err := c.ContainerRegistriesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContainerRegistriesCreateResponse(rsp)
}

func (c *ClientWithResponses) ContainerRegistriesCreateWithResponse(ctx context.Context, body ContainerRegistriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ContainerRegistriesCreateResponse, error) {
	rsp, err := c.ContainerRegistriesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContainerRegistriesCreateResponse(rsp)
}

// ContainerRegistriesDeleteWithResponse request returning *ContainerRegistriesDeleteResponse
func (c *ClientWithResponses) ContainerRegistriesDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ContainerRegistriesDeleteResponse, error) {
	rsp, err := c.ContainerRegistriesDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContainerRegistriesDeleteResponse(rsp)
}

// ContainerRegistriesGetWithResponse request returning *ContainerRegistriesGetResponse
func (c *ClientWithResponses) ContainerRegistriesGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ContainerRegistriesGetResponse, error) {
	rsp, err := c.ContainerRegistriesGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContainerRegistriesGetResponse(rsp)
}

// ContainerRegistriesUpdateWithBodyWithResponse request with arbitrary body returning *ContainerRegistriesUpdateResponse
func (c *ClientWithResponses) ContainerRegistriesUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ContainerRegistriesUpdateResponse, error) {
	rsp, err := c.ContainerRegistriesUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContainerRegistriesUpdateResponse(rsp)
}

func (c *ClientWithResponses) ContainerRegistriesUpdateWithResponse(ctx context.Context, id string, body ContainerRegistriesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ContainerRegistriesUpdateResponse, error) {
	rsp, err := c.ContainerRegistriesUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContainerRegistriesUpdateResponse(rsp)
}

// ContainerRegistriesTestConnectionWithResponse request returning *ContainerRegistriesTestConnectionResponse
func (c *ClientWithResponses) ContainerRegistriesTestConnectionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ContainerRegistriesTestConnectionResponse, error) {
	rsp, err := c.ContainerRegistriesTestConnection(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContainerRegistriesTestConnectionResponse(rsp)
}

// CustomTemplatesListWithResponse request returning *CustomTemplatesListResponse
func (c *ClientWithResponses) CustomTemplatesListWithResponse(ctx context.Context, params *CustomTemplatesListParams, reqEditors ...RequestEditorFn) (*CustomTemplatesListResponse, error) {
	rsp, err := c.CustomTemplatesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomTemplatesListResponse(rsp)
}

// CustomTemplatesCreateWithBodyWithResponse request with arbitrary body returning *CustomTemplatesCreateResponse
func (c *ClientWithResponses) CustomTemplatesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomTemplatesCreateResponse, error) {
	rsp, err := c.CustomTemplatesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomTemplatesCreateResponse(rsp)
}

func (c *ClientWithResponses) CustomTemplatesCreateWithResponse(ctx context.Context, body CustomTemplatesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomTemplatesCreateResponse, error) {
	rsp, err := c.CustomTemplatesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomTemplatesCreateResponse(rsp)
}

// CustomTemplatesDeleteWithResponse request returning *CustomTemplatesDeleteResponse
func (c *ClientWithResponses) CustomTemplatesDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CustomTemplatesDeleteResponse, error) {
	rsp, err := c.CustomTemplatesDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomTemplatesDeleteResponse(rsp)
}

// CustomTemplatesGetWithResponse request returning *CustomTemplatesGetResponse
func (c *ClientWithResponses) CustomTemplatesGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CustomTemplatesGetResponse, error) {
	rsp, err := c.CustomTemplatesGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomTemplatesGetResponse(rsp)
}

// CustomTemplatesUpdateWithBodyWithResponse request with arbitrary body returning *CustomTemplatesUpdateResponse
func (c *ClientWithResponses) CustomTemplatesUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomTemplatesUpdateResponse, error) {
	rsp, err := c.CustomTemplatesUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomTemplatesUpdateResponse(rsp)
}

func (c *ClientWithResponses) CustomTemplatesUpdateWithResponse(ctx context.Context, id string, body CustomTemplatesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomTemplatesUpdateResponse, error) {
	rsp, err := c.CustomTemplatesUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomTemplatesUpdateResponse(rsp)
}

// DatasetsListWithResponse request returning *DatasetsListResponse
func (c *ClientWithResponses) DatasetsListWithResponse(ctx context.Context, params *DatasetsListParams, reqEditors ...RequestEditorFn) (*DatasetsListResponse, error) {
	rsp, err := c.DatasetsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsListResponse(rsp)
}

// DatasetsCreateWithBodyWithResponse request with arbitrary body returning *DatasetsCreateResponse
func (c *ClientWithResponses) DatasetsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetsCreateResponse, error) {
	rsp, err := c.DatasetsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsCreateResponse(rsp)
}

func (c *ClientWithResponses) DatasetsCreateWithResponse(ctx context.Context, body DatasetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetsCreateResponse, error) {
	rsp, err := c.DatasetsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsCreateResponse(rsp)
}

// DatasetVersionsListWithResponse request returning *DatasetVersionsListResponse
func (c *ClientWithResponses) DatasetVersionsListWithResponse(ctx context.Context, datasetId string, params *DatasetVersionsListParams, reqEditors ...RequestEditorFn) (*DatasetVersionsListResponse, error) {
	rsp, err := c.DatasetVersionsList(ctx, datasetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetVersionsListResponse(rsp)
}

// DatasetVersionsCreateWithBodyWithResponse request with arbitrary body returning *DatasetVersionsCreateResponse
func (c *ClientWithResponses) DatasetVersionsCreateWithBodyWithResponse(ctx context.Context, datasetId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetVersionsCreateResponse, error) {
	rsp, err := c.DatasetVersionsCreateWithBody(ctx, datasetId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetVersionsCreateResponse(rsp)
}

func (c *ClientWithResponses) DatasetVersionsCreateWithResponse(ctx context.Context, datasetId string, body DatasetVersionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetVersionsCreateResponse, error) {
	rsp, err := c.DatasetVersionsCreate(ctx, datasetId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetVersionsCreateResponse(rsp)
}

// DatasetVersionsDeleteWithResponse request returning *DatasetVersionsDeleteResponse
func (c *ClientWithResponses) DatasetVersionsDeleteWithResponse(ctx context.Context, datasetId string, version string, reqEditors ...RequestEditorFn) (*DatasetVersionsDeleteResponse, error) {
	rsp, err := c.DatasetVersionsDelete(ctx, datasetId, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetVersionsDeleteResponse(rsp)
}

// DatasetVersionsGetWithResponse request returning *DatasetVersionsGetResponse
func (c *ClientWithResponses) DatasetVersionsGetWithResponse(ctx context.Context, datasetId string, version string, reqEditors ...RequestEditorFn) (*DatasetVersionsGetResponse, error) {
	rsp, err := c.DatasetVersionsGet(ctx, datasetId, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetVersionsGetResponse(rsp)
}

// DatasetVersionsUpdateWithBodyWithResponse request with arbitrary body returning *DatasetVersionsUpdateResponse
func (c *ClientWithResponses) DatasetVersionsUpdateWithBodyWithResponse(ctx context.Context, datasetId string, version string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetVersionsUpdateResponse, error) {
	rsp, err := c.DatasetVersionsUpdateWithBody(ctx, datasetId, version, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetVersionsUpdateResponse(rsp)
}

func (c *ClientWithResponses) DatasetVersionsUpdateWithResponse(ctx context.Context, datasetId string, version string, body DatasetVersionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetVersionsUpdateResponse, error) {
	rsp, err := c.DatasetVersionsUpdate(ctx, datasetId, version, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetVersionsUpdateResponse(rsp)
}

// DatasetsDeleteWithResponse request returning *DatasetsDeleteResponse
func (c *ClientWithResponses) DatasetsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DatasetsDeleteResponse, error) {
	rsp, err := c.DatasetsDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsDeleteResponse(rsp)
}

// DatasetsGetWithResponse request returning *DatasetsGetResponse
func (c *ClientWithResponses) DatasetsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DatasetsGetResponse, error) {
	rsp, err := c.DatasetsGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsGetResponse(rsp)
}

// DatasetsUpdateWithBodyWithResponse request with arbitrary body returning *DatasetsUpdateResponse
func (c *ClientWithResponses) DatasetsUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetsUpdateResponse, error) {
	rsp, err := c.DatasetsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsUpdateResponse(rsp)
}

func (c *ClientWithResponses) DatasetsUpdateWithResponse(ctx context.Context, id string, body DatasetsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetsUpdateResponse, error) {
	rsp, err := c.DatasetsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsUpdateResponse(rsp)
}

// DeploymentsListWithResponse request returning *DeploymentsListResponse
func (c *ClientWithResponses) DeploymentsListWithResponse(ctx context.Context, params *DeploymentsListParams, reqEditors ...RequestEditorFn) (*DeploymentsListResponse, error) {
	rsp, err := c.DeploymentsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeploymentsListResponse(rsp)
}

// DeploymentsUpsertWithBodyWithResponse request with arbitrary body returning *DeploymentsUpsertResponse
func (c *ClientWithResponses) DeploymentsUpsertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeploymentsUpsertResponse, error) {
	rsp, err := c.DeploymentsUpsertWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeploymentsUpsertResponse(rsp)
}

func (c *ClientWithResponses) DeploymentsUpsertWithResponse(ctx context.Context, body DeploymentsUpsertJSONRequestBody, reqEditors ...RequestEditorFn) (*DeploymentsUpsertResponse, error) {
	rsp, err := c.DeploymentsUpsert(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeploymentsUpsertResponse(rsp)
}

// DeploymentsDeleteWithResponse request returning *DeploymentsDeleteResponse
func (c *ClientWithResponses) DeploymentsDeleteWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeploymentsDeleteResponse, error) {
	rsp, err := c.DeploymentsDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeploymentsDeleteResponse(rsp)
}

// DeploymentsGetWithResponse request returning *DeploymentsGetResponse
func (c *ClientWithResponses) DeploymentsGetWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeploymentsGetResponse, error) {
	rsp, err := c.DeploymentsGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeploymentsGetResponse(rsp)
}

// DeploymentHistoryListWithResponse request returning *DeploymentHistoryListResponse
func (c *ClientWithResponses) DeploymentHistoryListWithResponse(ctx context.Context, id openapi_types.UUID, params *DeploymentHistoryListParams, reqEditors ...RequestEditorFn) (*DeploymentHistoryListResponse, error) {
	rsp, err := c.DeploymentHistoryList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeploymentHistoryListResponse(rsp)
}

// DeploymentLogsListWithResponse request returning *DeploymentLogsListResponse
func (c *ClientWithResponses) DeploymentLogsListWithResponse(ctx context.Context, id openapi_types.UUID, params *DeploymentLogsListParams, reqEditors ...RequestEditorFn) (*DeploymentLogsListResponse, error) {
	rsp, err := c.DeploymentLogsList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeploymentLogsListResponse(rsp)
}

// DeploymentMetricsGetWithResponse request returning *DeploymentMetricsGetResponse
func (c *ClientWithResponses) DeploymentMetricsGetWithResponse(ctx context.Context, id openapi_types.UUID, params *DeploymentMetricsGetParams, reqEditors ...RequestEditorFn) (*DeploymentMetricsGetResponse, error) {
	rsp, err := c.DeploymentMetricsGet(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeploymentMetricsGetResponse(rsp)
}

// DeploymentRunsGetWithResponse request returning *DeploymentRunsGetResponse
func (c *ClientWithResponses) DeploymentRunsGetWithResponse(ctx context.Context, id openapi_types.UUID, params *DeploymentRunsGetParams, reqEditors ...RequestEditorFn) (*DeploymentRunsGetResponse, error) {
	rsp, err := c.DeploymentRunsGet(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeploymentRunsGetResponse(rsp)
}

// MachineAvailabilityListWithResponse request returning *MachineAvailabilityListResponse
func (c *ClientWithResponses) MachineAvailabilityListWithResponse(ctx context.Context, params *MachineAvailabilityListParams, reqEditors ...RequestEditorFn) (*MachineAvailabilityListResponse, error) {
	rsp, err := c.MachineAvailabilityList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachineAvailabilityListResponse(rsp)
}

// MachineEventsListWithResponse request returning *MachineEventsListResponse
func (c *ClientWithResponses) MachineEventsListWithResponse(ctx context.Context, params *MachineEventsListParams, reqEditors ...RequestEditorFn) (*MachineEventsListResponse, error) {
	rsp, err := c.MachineEventsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachineEventsListResponse(rsp)
}

// MachineEventsGetWithResponse request returning *MachineEventsGetResponse
func (c *ClientWithResponses) MachineEventsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*MachineEventsGetResponse, error) {
	rsp, err := c.MachineEventsGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachineEventsGetResponse(rsp)
}

// MachinesListWithResponse request returning *MachinesListResponse
func (c *ClientWithResponses) MachinesListWithResponse(ctx context.Context, params *MachinesListParams, reqEditors ...RequestEditorFn) (*MachinesListResponse, error) {
	rsp, err := c.MachinesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesListResponse(rsp)
}

// MachinesCreateWithBodyWithResponse request with arbitrary body returning *MachinesCreateResponse
func (c *ClientWithResponses) MachinesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesCreateResponse, error) {
	rsp, err := c.MachinesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesCreateResponse(rsp)
}

func (c *ClientWithResponses) MachinesCreateWithResponse(ctx context.Context, body MachinesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesCreateResponse, error) {
	rsp, err := c.MachinesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesCreateResponse(rsp)
}

// MachinesDeleteWithResponse request returning *MachinesDeleteResponse
func (c *ClientWithResponses) MachinesDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*MachinesDeleteResponse, error) {
	rsp, err := c.MachinesDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesDeleteResponse(rsp)
}

// MachinesGetWithResponse request returning *MachinesGetResponse
func (c *ClientWithResponses) MachinesGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*MachinesGetResponse, error) {
	rsp, err := c.MachinesGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesGetResponse(rsp)
}

// MachinesUpdateWithBodyWithResponse request with arbitrary body returning *MachinesUpdateResponse
func (c *ClientWithResponses) MachinesUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesUpdateResponse, error) {
	rsp, err := c.MachinesUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesUpdateResponse(rsp)
}

func (c *ClientWithResponses) MachinesUpdateWithResponse(ctx context.Context, id string, body MachinesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesUpdateResponse, error) {
	rsp, err := c.MachinesUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesUpdateResponse(rsp)
}

// MachinesListAccessorsWithResponse request returning *MachinesListAccessorsResponse
func (c *ClientWithResponses) MachinesListAccessorsWithResponse(ctx context.Context, id string, params *MachinesListAccessorsParams, reqEditors ...RequestEditorFn) (*MachinesListAccessorsResponse, error) {
	rsp, err := c.MachinesListAccessors(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesListAccessorsResponse(rsp)
}

// MachinesAddAccessorWithBodyWithResponse request with arbitrary body returning *MachinesAddAccessorResponse
func (c *ClientWithResponses) MachinesAddAccessorWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesAddAccessorResponse, error) {
	rsp, err := c.MachinesAddAccessorWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesAddAccessorResponse(rsp)
}

func (c *ClientWithResponses) MachinesAddAccessorWithResponse(ctx context.Context, id string, body MachinesAddAccessorJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesAddAccessorResponse, error) {
	rsp, err := c.MachinesAddAccessor(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesAddAccessorResponse(rsp)
}

// MachinesRemoveAccessorWithResponse request returning *MachinesRemoveAccessorResponse
func (c *ClientWithResponses) MachinesRemoveAccessorWithResponse(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*MachinesRemoveAccessorResponse, error) {
	rsp, err := c.MachinesRemoveAccessor(ctx, id, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesRemoveAccessorResponse(rsp)
}

// MachinesGetAccessorWithResponse request returning *MachinesGetAccessorResponse
func (c *ClientWithResponses) MachinesGetAccessorWithResponse(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*MachinesGetAccessorResponse, error) {
	rsp, err := c.MachinesGetAccessor(ctx, id, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesGetAccessorResponse(rsp)
}

// MachinesGetDesktopWithResponse request returning *MachinesGetDesktopResponse
func (c *ClientWithResponses) MachinesGetDesktopWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*MachinesGetDesktopResponse, error) {
	rsp, err := c.MachinesGetDesktop(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesGetDesktopResponse(rsp)
}

// MachinesRestartWithResponse request returning *MachinesRestartResponse
func (c *ClientWithResponses) MachinesRestartWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*MachinesRestartResponse, error) {
	rsp, err := c.MachinesRestart(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesRestartResponse(rsp)
}

// MachinesStartWithResponse request returning *MachinesStartResponse
func (c *ClientWithResponses) MachinesStartWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*MachinesStartResponse, error) {
	rsp, err := c.MachinesStart(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesStartResponse(rsp)
}

// MachinesStopWithResponse request returning *MachinesStopResponse
func (c *ClientWithResponses) MachinesStopWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*MachinesStopResponse, error) {
	rsp, err := c.MachinesStop(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesStopResponse(rsp)
}

// ModelsListWithResponse request returning *ModelsListResponse
func (c *ClientWithResponses) ModelsListWithResponse(ctx context.Context, params *ModelsListParams, reqEditors ...RequestEditorFn) (*ModelsListResponse, error) {
	rsp, err := c.ModelsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsListResponse(rsp)
}

// ModelsCreateWithBodyWithResponse request with arbitrary body returning *ModelsCreateResponse
func (c *ClientWithResponses) ModelsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModelsCreateResponse, error) {
	rsp, err := c.ModelsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsCreateResponse(rsp)
}

func (c *ClientWithResponses) ModelsCreateWithResponse(ctx context.Context, body ModelsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ModelsCreateResponse, error) {
	rsp, err := c.ModelsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsCreateResponse(rsp)
}

// ModelsDeleteWithResponse request returning *ModelsDeleteResponse
func (c *ClientWithResponses) ModelsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ModelsDeleteResponse, error) {
	rsp, err := c.ModelsDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsDeleteResponse(rsp)
}

// ModelsGetWithResponse request returning *ModelsGetResponse
func (c *ClientWithResponses) ModelsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ModelsGetResponse, error) {
	rsp, err := c.ModelsGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsGetResponse(rsp)
}

// OsTemplatesListWithResponse request returning *OsTemplatesListResponse
func (c *ClientWithResponses) OsTemplatesListWithResponse(ctx context.Context, params *OsTemplatesListParams, reqEditors ...RequestEditorFn) (*OsTemplatesListResponse, error) {
	rsp, err := c.OsTemplatesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOsTemplatesListResponse(rsp)
}

// PrivateNetworksListWithResponse request returning *PrivateNetworksListResponse
func (c *ClientWithResponses) PrivateNetworksListWithResponse(ctx context.Context, params *PrivateNetworksListParams, reqEditors ...RequestEditorFn) (*PrivateNetworksListResponse, error) {
	rsp, err := c.PrivateNetworksList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrivateNetworksListResponse(rsp)
}

// PrivateNetworksCreateWithBodyWithResponse request with arbitrary body returning *PrivateNetworksCreateResponse
func (c *ClientWithResponses) PrivateNetworksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrivateNetworksCreateResponse, error) {
	rsp, err := c.PrivateNetworksCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrivateNetworksCreateResponse(rsp)
}

func (c *ClientWithResponses) PrivateNetworksCreateWithResponse(ctx context.Context, body PrivateNetworksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PrivateNetworksCreateResponse, error) {
	rsp, err := c.PrivateNetworksCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrivateNetworksCreateResponse(rsp)
}

// PrivateNetworksDeleteWithResponse request returning *PrivateNetworksDeleteResponse
func (c *ClientWithResponses) PrivateNetworksDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PrivateNetworksDeleteResponse, error) {
	rsp, err := c.PrivateNetworksDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrivateNetworksDeleteResponse(rsp)
}

// PrivateNetworksGetWithResponse request returning *PrivateNetworksGetResponse
func (c *ClientWithResponses) PrivateNetworksGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PrivateNetworksGetResponse, error) {
	rsp, err := c.PrivateNetworksGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrivateNetworksGetResponse(rsp)
}

// PrivateNetworksUpdateWithBodyWithResponse request with arbitrary body returning *PrivateNetworksUpdateResponse
func (c *ClientWithResponses) PrivateNetworksUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrivateNetworksUpdateResponse, error) {
	rsp, err := c.PrivateNetworksUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrivateNetworksUpdateResponse(rsp)
}

func (c *ClientWithResponses) PrivateNetworksUpdateWithResponse(ctx context.Context, id string, body PrivateNetworksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PrivateNetworksUpdateResponse, error) {
	rsp, err := c.PrivateNetworksUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrivateNetworksUpdateResponse(rsp)
}

// ProjectsListWithResponse request returning *ProjectsListResponse
func (c *ClientWithResponses) ProjectsListWithResponse(ctx context.Context, params *ProjectsListParams, reqEditors ...RequestEditorFn) (*ProjectsListResponse, error) {
	rsp, err := c.ProjectsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsListResponse(rsp)
}

// ProjectsCreateWithBodyWithResponse request with arbitrary body returning *ProjectsCreateResponse
func (c *ClientWithResponses) ProjectsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsCreateResponse, error) {
	rsp, err := c.ProjectsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsCreateResponse(rsp)
}

func (c *ClientWithResponses) ProjectsCreateWithResponse(ctx context.Context, body ProjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsCreateResponse, error) {
	rsp, err := c.ProjectsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsCreateResponse(rsp)
}

// ProjectsDeleteWithResponse request returning *ProjectsDeleteResponse
func (c *ClientWithResponses) ProjectsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ProjectsDeleteResponse, error) {
	rsp, err := c.ProjectsDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsDeleteResponse(rsp)
}

// ProjectsGetWithResponse request returning *ProjectsGetResponse
func (c *ClientWithResponses) ProjectsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ProjectsGetResponse, error) {
	rsp, err := c.ProjectsGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsGetResponse(rsp)
}

// ProjectsUpdateWithBodyWithResponse request with arbitrary body returning *ProjectsUpdateResponse
func (c *ClientWithResponses) ProjectsUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsUpdateResponse, error) {
	rsp, err := c.ProjectsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ProjectsUpdateWithResponse(ctx context.Context, id string, body ProjectsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsUpdateResponse, error) {
	rsp, err := c.ProjectsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsUpdateResponse(rsp)
}

// ProjectActivityListWithResponse request returning *ProjectActivityListResponse
func (c *ClientWithResponses) ProjectActivityListWithResponse(ctx context.Context, id string, params *ProjectActivityListParams, reqEditors ...RequestEditorFn) (*ProjectActivityListResponse, error) {
	rsp, err := c.ProjectActivityList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectActivityListResponse(rsp)
}

// ProjectCollaboratorsListWithResponse request returning *ProjectCollaboratorsListResponse
func (c *ClientWithResponses) ProjectCollaboratorsListWithResponse(ctx context.Context, id string, params *ProjectCollaboratorsListParams, reqEditors ...RequestEditorFn) (*ProjectCollaboratorsListResponse, error) {
	rsp, err := c.ProjectCollaboratorsList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectCollaboratorsListResponse(rsp)
}

// ProjectCollaboratorsCreateWithBodyWithResponse request with arbitrary body returning *ProjectCollaboratorsCreateResponse
func (c *ClientWithResponses) ProjectCollaboratorsCreateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectCollaboratorsCreateResponse, error) {
	rsp, err := c.ProjectCollaboratorsCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectCollaboratorsCreateResponse(rsp)
}

func (c *ClientWithResponses) ProjectCollaboratorsCreateWithResponse(ctx context.Context, id string, body ProjectCollaboratorsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectCollaboratorsCreateResponse, error) {
	rsp, err := c.ProjectCollaboratorsCreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectCollaboratorsCreateResponse(rsp)
}

// ProjectCollaboratorsDeleteWithResponse request returning *ProjectCollaboratorsDeleteResponse
func (c *ClientWithResponses) ProjectCollaboratorsDeleteWithResponse(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*ProjectCollaboratorsDeleteResponse, error) {
	rsp, err := c.ProjectCollaboratorsDelete(ctx, id, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectCollaboratorsDeleteResponse(rsp)
}

// ProjectDeploymentsListWithResponse request returning *ProjectDeploymentsListResponse
func (c *ClientWithResponses) ProjectDeploymentsListWithResponse(ctx context.Context, id string, params *ProjectDeploymentsListParams, reqEditors ...RequestEditorFn) (*ProjectDeploymentsListResponse, error) {
	rsp, err := c.ProjectDeploymentsList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectDeploymentsListResponse(rsp)
}

// ProjectModelsListWithResponse request returning *ProjectModelsListResponse
func (c *ClientWithResponses) ProjectModelsListWithResponse(ctx context.Context, id string, params *ProjectModelsListParams, reqEditors ...RequestEditorFn) (*ProjectModelsListResponse, error) {
	rsp, err := c.ProjectModelsList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectModelsListResponse(rsp)
}

// ProjectModelsRemoveWithResponse request returning *ProjectModelsRemoveResponse
func (c *ClientWithResponses) ProjectModelsRemoveWithResponse(ctx context.Context, id string, modelId string, reqEditors ...RequestEditorFn) (*ProjectModelsRemoveResponse, error) {
	rsp, err := c.ProjectModelsRemove(ctx, id, modelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectModelsRemoveResponse(rsp)
}

// ProjectModelsAddWithResponse request returning *ProjectModelsAddResponse
func (c *ClientWithResponses) ProjectModelsAddWithResponse(ctx context.Context, id string, modelId string, reqEditors ...RequestEditorFn) (*ProjectModelsAddResponse, error) {
	rsp, err := c.ProjectModelsAdd(ctx, id, modelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectModelsAddResponse(rsp)
}

// ProjectSecretsListWithResponse request returning *ProjectSecretsListResponse
func (c *ClientWithResponses) ProjectSecretsListWithResponse(ctx context.Context, id string, params *ProjectSecretsListParams, reqEditors ...RequestEditorFn) (*ProjectSecretsListResponse, error) {
	rsp, err := c.ProjectSecretsList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectSecretsListResponse(rsp)
}

// ProjectSecretsCreateWithBodyWithResponse request with arbitrary body returning *ProjectSecretsCreateResponse
func (c *ClientWithResponses) ProjectSecretsCreateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectSecretsCreateResponse, error) {
	rsp, err := c.ProjectSecretsCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectSecretsCreateResponse(rsp)
}

func (c *ClientWithResponses) ProjectSecretsCreateWithResponse(ctx context.Context, id string, body ProjectSecretsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectSecretsCreateResponse, error) {
	rsp, err := c.ProjectSecretsCreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectSecretsCreateResponse(rsp)
}

// ProjectSecretsDeleteWithResponse request returning *ProjectSecretsDeleteResponse
func (c *ClientWithResponses) ProjectSecretsDeleteWithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*ProjectSecretsDeleteResponse, error) {
	rsp, err := c.ProjectSecretsDelete(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectSecretsDeleteResponse(rsp)
}

// ProjectSecretsGetProjectSecretWithResponse request returning *ProjectSecretsGetProjectSecretResponse
func (c *ClientWithResponses) ProjectSecretsGetProjectSecretWithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*ProjectSecretsGetProjectSecretResponse, error) {
	rsp, err := c.ProjectSecretsGetProjectSecret(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectSecretsGetProjectSecretResponse(rsp)
}

// ProjectSecretsUpdateWithBodyWithResponse request with arbitrary body returning *ProjectSecretsUpdateResponse
func (c *ClientWithResponses) ProjectSecretsUpdateWithBodyWithResponse(ctx context.Context, id string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectSecretsUpdateResponse, error) {
	rsp, err := c.ProjectSecretsUpdateWithBody(ctx, id, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectSecretsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ProjectSecretsUpdateWithResponse(ctx context.Context, id string, name string, body ProjectSecretsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectSecretsUpdateResponse, error) {
	rsp, err := c.ProjectSecretsUpdate(ctx, id, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectSecretsUpdateResponse(rsp)
}

// ProjectTagsRemoveWithResponse request returning *ProjectTagsRemoveResponse
func (c *ClientWithResponses) ProjectTagsRemoveWithResponse(ctx context.Context, id string, params *ProjectTagsRemoveParams, reqEditors ...RequestEditorFn) (*ProjectTagsRemoveResponse, error) {
	rsp, err := c.ProjectTagsRemove(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectTagsRemoveResponse(rsp)
}

// ProjectTagsListWithResponse request returning *ProjectTagsListResponse
func (c *ClientWithResponses) ProjectTagsListWithResponse(ctx context.Context, id string, params *ProjectTagsListParams, reqEditors ...RequestEditorFn) (*ProjectTagsListResponse, error) {
	rsp, err := c.ProjectTagsList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectTagsListResponse(rsp)
}

// ProjectTagsAddWithBodyWithResponse request with arbitrary body returning *ProjectTagsAddResponse
func (c *ClientWithResponses) ProjectTagsAddWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectTagsAddResponse, error) {
	rsp, err := c.ProjectTagsAddWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectTagsAddResponse(rsp)
}

func (c *ClientWithResponses) ProjectTagsAddWithResponse(ctx context.Context, id string, body ProjectTagsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectTagsAddResponse, error) {
	rsp, err := c.ProjectTagsAdd(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectTagsAddResponse(rsp)
}

// PublicIpsListWithResponse request returning *PublicIpsListResponse
func (c *ClientWithResponses) PublicIpsListWithResponse(ctx context.Context, params *PublicIpsListParams, reqEditors ...RequestEditorFn) (*PublicIpsListResponse, error) {
	rsp, err := c.PublicIpsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublicIpsListResponse(rsp)
}

// PublicIpsClaimWithBodyWithResponse request with arbitrary body returning *PublicIpsClaimResponse
func (c *ClientWithResponses) PublicIpsClaimWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublicIpsClaimResponse, error) {
	rsp, err := c.PublicIpsClaimWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublicIpsClaimResponse(rsp)
}

func (c *ClientWithResponses) PublicIpsClaimWithResponse(ctx context.Context, body PublicIpsClaimJSONRequestBody, reqEditors ...RequestEditorFn) (*PublicIpsClaimResponse, error) {
	rsp, err := c.PublicIpsClaim(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublicIpsClaimResponse(rsp)
}

// PublicIpsReleaseWithResponse request returning *PublicIpsReleaseResponse
func (c *ClientWithResponses) PublicIpsReleaseWithResponse(ctx context.Context, ip string, reqEditors ...RequestEditorFn) (*PublicIpsReleaseResponse, error) {
	rsp, err := c.PublicIpsRelease(ctx, ip, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublicIpsReleaseResponse(rsp)
}

// PublicIpsAssignWithBodyWithResponse request with arbitrary body returning *PublicIpsAssignResponse
func (c *ClientWithResponses) PublicIpsAssignWithBodyWithResponse(ctx context.Context, ip string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublicIpsAssignResponse, error) {
	rsp, err := c.PublicIpsAssignWithBody(ctx, ip, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublicIpsAssignResponse(rsp)
}

func (c *ClientWithResponses) PublicIpsAssignWithResponse(ctx context.Context, ip string, body PublicIpsAssignJSONRequestBody, reqEditors ...RequestEditorFn) (*PublicIpsAssignResponse, error) {
	rsp, err := c.PublicIpsAssign(ctx, ip, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublicIpsAssignResponse(rsp)
}

// SharedDrivesListWithResponse request returning *SharedDrivesListResponse
func (c *ClientWithResponses) SharedDrivesListWithResponse(ctx context.Context, params *SharedDrivesListParams, reqEditors ...RequestEditorFn) (*SharedDrivesListResponse, error) {
	rsp, err := c.SharedDrivesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSharedDrivesListResponse(rsp)
}

// SharedDrivesCreateWithBodyWithResponse request with arbitrary body returning *SharedDrivesCreateResponse
func (c *ClientWithResponses) SharedDrivesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SharedDrivesCreateResponse, error) {
	rsp, err := c.SharedDrivesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSharedDrivesCreateResponse(rsp)
}

func (c *ClientWithResponses) SharedDrivesCreateWithResponse(ctx context.Context, body SharedDrivesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SharedDrivesCreateResponse, error) {
	rsp, err := c.SharedDrivesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSharedDrivesCreateResponse(rsp)
}

// SharedDrivesDeleteWithResponse request returning *SharedDrivesDeleteResponse
func (c *ClientWithResponses) SharedDrivesDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SharedDrivesDeleteResponse, error) {
	rsp, err := c.SharedDrivesDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSharedDrivesDeleteResponse(rsp)
}

// SharedDrivesGetWithResponse request returning *SharedDrivesGetResponse
func (c *ClientWithResponses) SharedDrivesGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SharedDrivesGetResponse, error) {
	rsp, err := c.SharedDrivesGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSharedDrivesGetResponse(rsp)
}

// SharedDrivesUpdateWithBodyWithResponse request with arbitrary body returning *SharedDrivesUpdateResponse
func (c *ClientWithResponses) SharedDrivesUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SharedDrivesUpdateResponse, error) {
	rsp, err := c.SharedDrivesUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSharedDrivesUpdateResponse(rsp)
}

func (c *ClientWithResponses) SharedDrivesUpdateWithResponse(ctx context.Context, id string, body SharedDrivesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SharedDrivesUpdateResponse, error) {
	rsp, err := c.SharedDrivesUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSharedDrivesUpdateResponse(rsp)
}

// SnapshotsListWithResponse request returning *SnapshotsListResponse
func (c *ClientWithResponses) SnapshotsListWithResponse(ctx context.Context, params *SnapshotsListParams, reqEditors ...RequestEditorFn) (*SnapshotsListResponse, error) {
	rsp, err := c.SnapshotsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapshotsListResponse(rsp)
}

// SnapshotsCreateWithBodyWithResponse request with arbitrary body returning *SnapshotsCreateResponse
func (c *ClientWithResponses) SnapshotsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapshotsCreateResponse, error) {
	rsp, err := c.SnapshotsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapshotsCreateResponse(rsp)
}

func (c *ClientWithResponses) SnapshotsCreateWithResponse(ctx context.Context, body SnapshotsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapshotsCreateResponse, error) {
	rsp, err := c.SnapshotsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapshotsCreateResponse(rsp)
}

// SnapshotsDeleteWithResponse request returning *SnapshotsDeleteResponse
func (c *ClientWithResponses) SnapshotsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SnapshotsDeleteResponse, error) {
	rsp, err := c.SnapshotsDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapshotsDeleteResponse(rsp)
}

// SnapshotsGetWithResponse request returning *SnapshotsGetResponse
func (c *ClientWithResponses) SnapshotsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SnapshotsGetResponse, error) {
	rsp, err := c.SnapshotsGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapshotsGetResponse(rsp)
}

// SnapshotsUpdateWithBodyWithResponse request with arbitrary body returning *SnapshotsUpdateResponse
func (c *ClientWithResponses) SnapshotsUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapshotsUpdateResponse, error) {
	rsp, err := c.SnapshotsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapshotsUpdateResponse(rsp)
}

func (c *ClientWithResponses) SnapshotsUpdateWithResponse(ctx context.Context, id string, body SnapshotsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapshotsUpdateResponse, error) {
	rsp, err := c.SnapshotsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapshotsUpdateResponse(rsp)
}

// SnapshotsRestoreWithBodyWithResponse request with arbitrary body returning *SnapshotsRestoreResponse
func (c *ClientWithResponses) SnapshotsRestoreWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnapshotsRestoreResponse, error) {
	rsp, err := c.SnapshotsRestoreWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapshotsRestoreResponse(rsp)
}

func (c *ClientWithResponses) SnapshotsRestoreWithResponse(ctx context.Context, id string, body SnapshotsRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*SnapshotsRestoreResponse, error) {
	rsp, err := c.SnapshotsRestore(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnapshotsRestoreResponse(rsp)
}

// StartupScriptsListWithResponse request returning *StartupScriptsListResponse
func (c *ClientWithResponses) StartupScriptsListWithResponse(ctx context.Context, params *StartupScriptsListParams, reqEditors ...RequestEditorFn) (*StartupScriptsListResponse, error) {
	rsp, err := c.StartupScriptsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartupScriptsListResponse(rsp)
}

// StartupScriptsCreateWithBodyWithResponse request with arbitrary body returning *StartupScriptsCreateResponse
func (c *ClientWithResponses) StartupScriptsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartupScriptsCreateResponse, error) {
	rsp, err := c.StartupScriptsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartupScriptsCreateResponse(rsp)
}

func (c *ClientWithResponses) StartupScriptsCreateWithResponse(ctx context.Context, body StartupScriptsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*StartupScriptsCreateResponse, error) {
	rsp, err := c.StartupScriptsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartupScriptsCreateResponse(rsp)
}

// StartupScriptsDeleteWithResponse request returning *StartupScriptsDeleteResponse
func (c *ClientWithResponses) StartupScriptsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*StartupScriptsDeleteResponse, error) {
	rsp, err := c.StartupScriptsDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartupScriptsDeleteResponse(rsp)
}

// StartupScriptsGetWithResponse request returning *StartupScriptsGetResponse
func (c *ClientWithResponses) StartupScriptsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*StartupScriptsGetResponse, error) {
	rsp, err := c.StartupScriptsGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartupScriptsGetResponse(rsp)
}

// StartupScriptsUpdateWithBodyWithResponse request with arbitrary body returning *StartupScriptsUpdateResponse
func (c *ClientWithResponses) StartupScriptsUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartupScriptsUpdateResponse, error) {
	rsp, err := c.StartupScriptsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartupScriptsUpdateResponse(rsp)
}

func (c *ClientWithResponses) StartupScriptsUpdateWithResponse(ctx context.Context, id string, body StartupScriptsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*StartupScriptsUpdateResponse, error) {
	rsp, err := c.StartupScriptsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartupScriptsUpdateResponse(rsp)
}

// StartupScriptsAssignWithBodyWithResponse request with arbitrary body returning *StartupScriptsAssignResponse
func (c *ClientWithResponses) StartupScriptsAssignWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartupScriptsAssignResponse, error) {
	rsp, err := c.StartupScriptsAssignWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartupScriptsAssignResponse(rsp)
}

func (c *ClientWithResponses) StartupScriptsAssignWithResponse(ctx context.Context, id string, body StartupScriptsAssignJSONRequestBody, reqEditors ...RequestEditorFn) (*StartupScriptsAssignResponse, error) {
	rsp, err := c.StartupScriptsAssign(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartupScriptsAssignResponse(rsp)
}

// StartupScriptsUnassignWithBodyWithResponse request with arbitrary body returning *StartupScriptsUnassignResponse
func (c *ClientWithResponses) StartupScriptsUnassignWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartupScriptsUnassignResponse, error) {
	rsp, err := c.StartupScriptsUnassignWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartupScriptsUnassignResponse(rsp)
}

func (c *ClientWithResponses) StartupScriptsUnassignWithResponse(ctx context.Context, id string, body StartupScriptsUnassignJSONRequestBody, reqEditors ...RequestEditorFn) (*StartupScriptsUnassignResponse, error) {
	rsp, err := c.StartupScriptsUnassign(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartupScriptsUnassignResponse(rsp)
}

// StorageProvidersListWithResponse request returning *StorageProvidersListResponse
func (c *ClientWithResponses) StorageProvidersListWithResponse(ctx context.Context, params *StorageProvidersListParams, reqEditors ...RequestEditorFn) (*StorageProvidersListResponse, error) {
	rsp, err := c.StorageProvidersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorageProvidersListResponse(rsp)
}

// StorageProvidersCreateWithBodyWithResponse request with arbitrary body returning *StorageProvidersCreateResponse
func (c *ClientWithResponses) StorageProvidersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StorageProvidersCreateResponse, error) {
	rsp, err := c.StorageProvidersCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorageProvidersCreateResponse(rsp)
}

func (c *ClientWithResponses) StorageProvidersCreateWithResponse(ctx context.Context, body StorageProvidersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*StorageProvidersCreateResponse, error) {
	rsp, err := c.StorageProvidersCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorageProvidersCreateResponse(rsp)
}

// StorageUtilizationGetPublicWithResponse request returning *StorageUtilizationGetPublicResponse
func (c *ClientWithResponses) StorageUtilizationGetPublicWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StorageUtilizationGetPublicResponse, error) {
	rsp, err := c.StorageUtilizationGetPublic(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorageUtilizationGetPublicResponse(rsp)
}

// StorageProvidersDeleteWithResponse request returning *StorageProvidersDeleteResponse
func (c *ClientWithResponses) StorageProvidersDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*StorageProvidersDeleteResponse, error) {
	rsp, err := c.StorageProvidersDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorageProvidersDeleteResponse(rsp)
}

// StorageProvidersGetWithResponse request returning *StorageProvidersGetResponse
func (c *ClientWithResponses) StorageProvidersGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*StorageProvidersGetResponse, error) {
	rsp, err := c.StorageProvidersGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorageProvidersGetResponse(rsp)
}

// StorageProvidersUpdateWithBodyWithResponse request with arbitrary body returning *StorageProvidersUpdateResponse
func (c *ClientWithResponses) StorageProvidersUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StorageProvidersUpdateResponse, error) {
	rsp, err := c.StorageProvidersUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorageProvidersUpdateResponse(rsp)
}

func (c *ClientWithResponses) StorageProvidersUpdateWithResponse(ctx context.Context, id string, body StorageProvidersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*StorageProvidersUpdateResponse, error) {
	rsp, err := c.StorageProvidersUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorageProvidersUpdateResponse(rsp)
}

// TeamSecretsListWithResponse request returning *TeamSecretsListResponse
func (c *ClientWithResponses) TeamSecretsListWithResponse(ctx context.Context, id string, params *TeamSecretsListParams, reqEditors ...RequestEditorFn) (*TeamSecretsListResponse, error) {
	rsp, err := c.TeamSecretsList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamSecretsListResponse(rsp)
}

// TeamSecretsCreateWithBodyWithResponse request with arbitrary body returning *TeamSecretsCreateResponse
func (c *ClientWithResponses) TeamSecretsCreateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamSecretsCreateResponse, error) {
	rsp, err := c.TeamSecretsCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamSecretsCreateResponse(rsp)
}

func (c *ClientWithResponses) TeamSecretsCreateWithResponse(ctx context.Context, id string, body TeamSecretsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamSecretsCreateResponse, error) {
	rsp, err := c.TeamSecretsCreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamSecretsCreateResponse(rsp)
}

// TeamSecretsDeleteWithResponse request returning *TeamSecretsDeleteResponse
func (c *ClientWithResponses) TeamSecretsDeleteWithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*TeamSecretsDeleteResponse, error) {
	rsp, err := c.TeamSecretsDelete(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamSecretsDeleteResponse(rsp)
}

// TeamSecretsGetWithResponse request returning *TeamSecretsGetResponse
func (c *ClientWithResponses) TeamSecretsGetWithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*TeamSecretsGetResponse, error) {
	rsp, err := c.TeamSecretsGet(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamSecretsGetResponse(rsp)
}

// TeamSecretsUpdateWithBodyWithResponse request with arbitrary body returning *TeamSecretsUpdateResponse
func (c *ClientWithResponses) TeamSecretsUpdateWithBodyWithResponse(ctx context.Context, id string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamSecretsUpdateResponse, error) {
	rsp, err := c.TeamSecretsUpdateWithBody(ctx, id, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamSecretsUpdateResponse(rsp)
}

func (c *ClientWithResponses) TeamSecretsUpdateWithResponse(ctx context.Context, id string, name string, body TeamSecretsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamSecretsUpdateResponse, error) {
	rsp, err := c.TeamSecretsUpdate(ctx, id, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamSecretsUpdateResponse(rsp)
}

// TeamMembershipsListByTeamIdWithResponse request returning *TeamMembershipsListByTeamIdResponse
func (c *ClientWithResponses) TeamMembershipsListByTeamIdWithResponse(ctx context.Context, teamId string, params *TeamMembershipsListByTeamIdParams, reqEditors ...RequestEditorFn) (*TeamMembershipsListByTeamIdResponse, error) {
	rsp, err := c.TeamMembershipsListByTeamId(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamMembershipsListByTeamIdResponse(rsp)
}

// TeamMembershipsRemoveUserWithResponse request returning *TeamMembershipsRemoveUserResponse
func (c *ClientWithResponses) TeamMembershipsRemoveUserWithResponse(ctx context.Context, teamId string, userId string, reqEditors ...RequestEditorFn) (*TeamMembershipsRemoveUserResponse, error) {
	rsp, err := c.TeamMembershipsRemoveUser(ctx, teamId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamMembershipsRemoveUserResponse(rsp)
}

// TeamMembershipsUpdateWithBodyWithResponse request with arbitrary body returning *TeamMembershipsUpdateResponse
func (c *ClientWithResponses) TeamMembershipsUpdateWithBodyWithResponse(ctx context.Context, teamId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamMembershipsUpdateResponse, error) {
	rsp, err := c.TeamMembershipsUpdateWithBody(ctx, teamId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamMembershipsUpdateResponse(rsp)
}

func (c *ClientWithResponses) TeamMembershipsUpdateWithResponse(ctx context.Context, teamId string, userId string, body TeamMembershipsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamMembershipsUpdateResponse, error) {
	rsp, err := c.TeamMembershipsUpdate(ctx, teamId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamMembershipsUpdateResponse(rsp)
}

// ParseAuthSessionResponse parses an HTTP response from a AuthSessionWithResponse call
func ParseAuthSessionResponse(rsp *http.Response) (*AuthSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Team struct {
				// AnalyticsId An internal, numeric ID for the team
				AnalyticsId float32 `json:"analyticsId"`

				// Id A unique ID for the team
				Id string `json:"id"`

				// IsPrivate Whether the team is private or not
				IsPrivate bool `json:"isPrivate"`

				// MaxMachines The maximum number of machines
				MaxMachines float32 `json:"maxMachines"`

				// Namespace The namespace for the team
				Namespace string `json:"namespace"`
			} `json:"team"`
			User struct {
				// AnalyticsId An internal, numeric ID for the user
				AnalyticsId float32 `json:"analyticsId"`

				// DtConfirmed The date the account was confirmed
				DtConfirmed *time.Time `json:"dtConfirmed"`

				// DtCreated The date the user was created
				DtCreated time.Time `json:"dtCreated"`

				// Email The user's email address
				Email string `json:"email"`

				// FirstName The user's first name
				FirstName *string `json:"firstName"`

				// Id A unique ID for the user
				Id string `json:"id"`

				// IsPasswordAuthEnabled Whether the user has a password set
				IsPasswordAuthEnabled bool `json:"isPasswordAuthEnabled"`

				// IsPhoneVerified Whether the user's phone number has been verified
				IsPhoneVerified bool `json:"isPhoneVerified"`

				// IsQrCodeBasedMfaConfirmed Whether the user has a QR code based MFA confirmed
				IsQrCodeBasedMfaConfirmed bool `json:"isQrCodeBasedMfaConfirmed"`

				// IsQrCodeBasedMfaEnabled Whether the user has a QR code based MFA enabled
				IsQrCodeBasedMfaEnabled bool `json:"isQrCodeBasedMfaEnabled"`

				// LastName The user's last name
				LastName *string `json:"lastName"`

				// Metadata Metadata about the user
				Metadata struct {
					// CoreSurvey Core survey question-answer pairs
					CoreSurvey *map[string]string `json:"coreSurvey"`

					// GradientSurvey Gradient survey question-answer pairs
					GradientSurvey *map[string]string `json:"gradientSurvey"`

					// GraphcoreTermsAccepted Whether the user has accepted the Graphcore terms of service
					GraphcoreTermsAccepted *bool `json:"graphcoreTermsAccepted,omitempty"`

					// Tags Tags for the user
					Tags *string `json:"tags"`
				} `json:"metadata"`

				// Preferences The user's preferences
				Preferences *struct {
					DefaultProduct *string                             `json:"defaultProduct"`
					DefaultTeamId  *string                             `json:"defaultTeamId"`
					DisableHotkeys *bool                               `json:"disableHotkeys"`
					FontSize       *float32                            `json:"fontSize"`
					Theme          *AuthSession200UserPreferencesTheme `json:"theme"`
				} `json:"preferences"`

				// TeamMemberships The teams this user is a member of
				TeamMemberships []struct {
					// IsAdmin Whether the user is an admin of the team
					IsAdmin bool `json:"isAdmin"`

					// IsOwner Whether the user is the owner of the team
					IsOwner bool `json:"isOwner"`

					// Team The team the user is a member of
					Team struct {
						// DtCreated The date the team was created
						DtCreated time.Time `json:"dtCreated"`

						// Id The ID of the team
						Id string `json:"id"`

						// IsUserTeam Whether the team is the user's team
						IsUserTeam bool `json:"isUserTeam"`

						// Name The name of the team
						Name string `json:"name"`

						// Namespace The namespace of the team
						Namespace string `json:"namespace"`

						// PublicProfileImageUrl The URL of the team's profile image.
						PublicProfileImageUrl *string `json:"publicProfileImageUrl"`
					} `json:"team"`
				} `json:"teamMemberships"`
			} `json:"user"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseContainerRegistriesListResponse parses an HTTP response from a ContainerRegistriesListWithResponse call
func ParseContainerRegistriesListResponse(rsp *http.Response) (*ContainerRegistriesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ContainerRegistriesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// DtCreated The date the container registry was created
				DtCreated time.Time `json:"dtCreated"`

				// DtModified The date the container registry was last modified
				DtModified time.Time `json:"dtModified"`

				// Id The id of the container registry.
				Id string `json:"id"`

				// Kind The kind of container registry
				Kind ContainerRegistriesList200ItemsKind `json:"kind"`

				// Name The name of the container registry.
				Name string `json:"name"`

				// Namespace The namespace of the container registry. See https://docs.digitalocean.com/products/container-registry/.
				Namespace string `json:"namespace"`

				// Url The URL of the container registry. See https://docs.digitalocean.com/products/container-registry/.
				Url string `json:"url"`

				// Username A username for the container registry. See https://docs.digitalocean.com/products/container-registry/.
				Username string `json:"username"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseContainerRegistriesCreateResponse parses an HTTP response from a ContainerRegistriesCreateWithResponse call
func ParseContainerRegistriesCreateResponse(rsp *http.Response) (*ContainerRegistriesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ContainerRegistriesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the container registry was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the container registry was last modified
			DtModified time.Time `json:"dtModified"`

			// Id The id of the container registry.
			Id string `json:"id"`

			// Kind The kind of container registry
			Kind ContainerRegistriesCreate200Kind `json:"kind"`

			// Name The name of the container registry.
			Name string `json:"name"`

			// Namespace The namespace of the container registry. See https://docs.digitalocean.com/products/container-registry/.
			Namespace string `json:"namespace"`

			// Url The URL of the container registry. See https://docs.digitalocean.com/products/container-registry/.
			Url string `json:"url"`

			// Username A username for the container registry. See https://docs.digitalocean.com/products/container-registry/.
			Username string `json:"username"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseContainerRegistriesDeleteResponse parses an HTTP response from a ContainerRegistriesDeleteWithResponse call
func ParseContainerRegistriesDeleteResponse(rsp *http.Response) (*ContainerRegistriesDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ContainerRegistriesDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the container registry was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the container registry was last modified
			DtModified time.Time `json:"dtModified"`

			// Id The id of the container registry.
			Id string `json:"id"`

			// Kind The kind of container registry
			Kind ContainerRegistriesDelete200Kind `json:"kind"`

			// Name The name of the container registry.
			Name string `json:"name"`

			// Namespace The namespace of the container registry. See https://docs.digitalocean.com/products/container-registry/.
			Namespace string `json:"namespace"`

			// Url The URL of the container registry. See https://docs.digitalocean.com/products/container-registry/.
			Url string `json:"url"`

			// Username A username for the container registry. See https://docs.digitalocean.com/products/container-registry/.
			Username string `json:"username"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseContainerRegistriesGetResponse parses an HTTP response from a ContainerRegistriesGetWithResponse call
func ParseContainerRegistriesGetResponse(rsp *http.Response) (*ContainerRegistriesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ContainerRegistriesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the container registry was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the container registry was last modified
			DtModified time.Time `json:"dtModified"`

			// Id The id of the container registry.
			Id string `json:"id"`

			// Kind The kind of container registry
			Kind ContainerRegistriesGet200Kind `json:"kind"`

			// Name The name of the container registry.
			Name string `json:"name"`

			// Namespace The namespace of the container registry. See https://docs.digitalocean.com/products/container-registry/.
			Namespace string `json:"namespace"`

			// Url The URL of the container registry. See https://docs.digitalocean.com/products/container-registry/.
			Url string `json:"url"`

			// Username A username for the container registry. See https://docs.digitalocean.com/products/container-registry/.
			Username string `json:"username"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseContainerRegistriesUpdateResponse parses an HTTP response from a ContainerRegistriesUpdateWithResponse call
func ParseContainerRegistriesUpdateResponse(rsp *http.Response) (*ContainerRegistriesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ContainerRegistriesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the container registry was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the container registry was last modified
			DtModified time.Time `json:"dtModified"`

			// Id The id of the container registry.
			Id string `json:"id"`

			// Kind The kind of container registry
			Kind ContainerRegistriesUpdate200Kind `json:"kind"`

			// Name The name of the container registry.
			Name string `json:"name"`

			// Namespace The namespace of the container registry. See https://docs.digitalocean.com/products/container-registry/.
			Namespace string `json:"namespace"`

			// Url The URL of the container registry. See https://docs.digitalocean.com/products/container-registry/.
			Url string `json:"url"`

			// Username A username for the container registry. See https://docs.digitalocean.com/products/container-registry/.
			Username string `json:"username"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseContainerRegistriesTestConnectionResponse parses an HTTP response from a ContainerRegistriesTestConnectionWithResponse call
func ParseContainerRegistriesTestConnectionResponse(rsp *http.Response) (*ContainerRegistriesTestConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ContainerRegistriesTestConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Error The error message, if any
			Error *string `json:"error,omitempty"`

			// Success Whether the connection was successful
			Success bool `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCustomTemplatesListResponse parses an HTTP response from a CustomTemplatesListWithResponse call
func ParseCustomTemplatesListResponse(rsp *http.Response) (*CustomTemplatesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomTemplatesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// AgentType The type of agent installed on the template.
				AgentType string `json:"agentType"`

				// AvailableMachineTypes The machine types the template is available on.
				AvailableMachineTypes []struct {
					// IsAvailable Whether the template is available on this machine type.
					IsAvailable bool `json:"isAvailable"`

					// MachineTypeLabel The label of the machine type.
					MachineTypeLabel string `json:"machineTypeLabel"`
				} `json:"availableMachineTypes"`

				// DefaultSizeGb The default size of the template in gigabytes.
				DefaultSizeGb CustomTemplatesList_200_Items_DefaultSizeGb `json:"defaultSizeGb"`

				// DtCreated The date the template was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtDeleted The date the shared drive was deleted.
				DtDeleted *CustomTemplatesList_200_Items_DtDeleted `json:"dtDeleted"`

				// Id The ID of the template.
				Id string `json:"id"`

				// Name The name of the template.
				Name string `json:"name"`

				// OperatingSystemLabel The operating system installed on the template.
				OperatingSystemLabel string `json:"operatingSystemLabel"`

				// ParentMachineId The ID of the parent machine.
				ParentMachineId string `json:"parentMachineId"`

				// Region The region the template is in.
				Region CustomTemplatesList_200_Items_Region `json:"region"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCustomTemplatesCreateResponse parses an HTTP response from a CustomTemplatesCreateWithResponse call
func ParseCustomTemplatesCreateResponse(rsp *http.Response) (*CustomTemplatesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomTemplatesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The template.
			Data struct {
				// AgentType The type of agent installed on the template.
				AgentType string `json:"agentType"`

				// AvailableMachineTypes The machine types the template is available on.
				AvailableMachineTypes []struct {
					// IsAvailable Whether the template is available on this machine type.
					IsAvailable bool `json:"isAvailable"`

					// MachineTypeLabel The label of the machine type.
					MachineTypeLabel string `json:"machineTypeLabel"`
				} `json:"availableMachineTypes"`

				// DefaultSizeGb The default size of the template in gigabytes.
				DefaultSizeGb CustomTemplatesCreate_200_Data_DefaultSizeGb `json:"defaultSizeGb"`

				// DtCreated The date the template was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtDeleted The date the shared drive was deleted.
				DtDeleted *CustomTemplatesCreate_200_Data_DtDeleted `json:"dtDeleted"`

				// Id The ID of the template.
				Id string `json:"id"`

				// Name The name of the template.
				Name string `json:"name"`

				// OperatingSystemLabel The operating system installed on the template.
				OperatingSystemLabel string `json:"operatingSystemLabel"`

				// ParentMachineId The ID of the parent machine.
				ParentMachineId string `json:"parentMachineId"`

				// Region The region the template is in.
				Region CustomTemplatesCreate_200_Data_Region `json:"region"`
			} `json:"data"`

			// Event The machine event to poll for the async operation.
			Event struct {
				// DtCreated The date the event was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtFinished The date the event was finished.
				DtFinished *time.Time `json:"dtFinished"`

				// DtStarted The date the event was started.
				DtStarted *time.Time `json:"dtStarted"`

				// Error The error message of the event, if any.
				Error *string `json:"error"`

				// Id The ID of the event.
				Id string `json:"id"`

				// MachineId The ID of the machine the event is for.
				MachineId *string `json:"machineId"`

				// Name The name of the event, e.g. "create".
				Name CustomTemplatesCreate200EventName `json:"name"`

				// State The state of the event, e.g. "done".
				State CustomTemplatesCreate200EventState `json:"state"`
			} `json:"event"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCustomTemplatesDeleteResponse parses an HTTP response from a CustomTemplatesDeleteWithResponse call
func ParseCustomTemplatesDeleteResponse(rsp *http.Response) (*CustomTemplatesDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomTemplatesDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AgentType The type of agent installed on the template.
			AgentType string `json:"agentType"`

			// AvailableMachineTypes The machine types the template is available on.
			AvailableMachineTypes []struct {
				// IsAvailable Whether the template is available on this machine type.
				IsAvailable bool `json:"isAvailable"`

				// MachineTypeLabel The label of the machine type.
				MachineTypeLabel string `json:"machineTypeLabel"`
			} `json:"availableMachineTypes"`

			// DefaultSizeGb The default size of the template in gigabytes.
			DefaultSizeGb CustomTemplatesDelete_200_DefaultSizeGb `json:"defaultSizeGb"`

			// DtCreated The date the template was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the shared drive was deleted.
			DtDeleted *CustomTemplatesDelete_200_DtDeleted `json:"dtDeleted"`

			// Id The ID of the template.
			Id string `json:"id"`

			// Name The name of the template.
			Name string `json:"name"`

			// OperatingSystemLabel The operating system installed on the template.
			OperatingSystemLabel string `json:"operatingSystemLabel"`

			// ParentMachineId The ID of the parent machine.
			ParentMachineId string `json:"parentMachineId"`

			// Region The region the template is in.
			Region CustomTemplatesDelete_200_Region `json:"region"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCustomTemplatesGetResponse parses an HTTP response from a CustomTemplatesGetWithResponse call
func ParseCustomTemplatesGetResponse(rsp *http.Response) (*CustomTemplatesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomTemplatesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AgentType The type of agent installed on the template.
			AgentType string `json:"agentType"`

			// AvailableMachineTypes The machine types the template is available on.
			AvailableMachineTypes []struct {
				// IsAvailable Whether the template is available on this machine type.
				IsAvailable bool `json:"isAvailable"`

				// MachineTypeLabel The label of the machine type.
				MachineTypeLabel string `json:"machineTypeLabel"`
			} `json:"availableMachineTypes"`

			// DefaultSizeGb The default size of the template in gigabytes.
			DefaultSizeGb CustomTemplatesGet_200_DefaultSizeGb `json:"defaultSizeGb"`

			// DtCreated The date the template was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the shared drive was deleted.
			DtDeleted *CustomTemplatesGet_200_DtDeleted `json:"dtDeleted"`

			// Id The ID of the template.
			Id string `json:"id"`

			// Name The name of the template.
			Name string `json:"name"`

			// OperatingSystemLabel The operating system installed on the template.
			OperatingSystemLabel string `json:"operatingSystemLabel"`

			// ParentMachineId The ID of the parent machine.
			ParentMachineId string `json:"parentMachineId"`

			// Region The region the template is in.
			Region CustomTemplatesGet_200_Region `json:"region"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCustomTemplatesUpdateResponse parses an HTTP response from a CustomTemplatesUpdateWithResponse call
func ParseCustomTemplatesUpdateResponse(rsp *http.Response) (*CustomTemplatesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomTemplatesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AgentType The type of agent installed on the template.
			AgentType string `json:"agentType"`

			// AvailableMachineTypes The machine types the template is available on.
			AvailableMachineTypes []struct {
				// IsAvailable Whether the template is available on this machine type.
				IsAvailable bool `json:"isAvailable"`

				// MachineTypeLabel The label of the machine type.
				MachineTypeLabel string `json:"machineTypeLabel"`
			} `json:"availableMachineTypes"`

			// DefaultSizeGb The default size of the template in gigabytes.
			DefaultSizeGb CustomTemplatesUpdate_200_DefaultSizeGb `json:"defaultSizeGb"`

			// DtCreated The date the template was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the shared drive was deleted.
			DtDeleted *CustomTemplatesUpdate_200_DtDeleted `json:"dtDeleted"`

			// Id The ID of the template.
			Id string `json:"id"`

			// Name The name of the template.
			Name string `json:"name"`

			// OperatingSystemLabel The operating system installed on the template.
			OperatingSystemLabel string `json:"operatingSystemLabel"`

			// ParentMachineId The ID of the parent machine.
			ParentMachineId string `json:"parentMachineId"`

			// Region The region the template is in.
			Region CustomTemplatesUpdate_200_Region `json:"region"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDatasetsListResponse parses an HTTP response from a DatasetsListWithResponse call
func ParseDatasetsListResponse(rsp *http.Response) (*DatasetsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// Description The description of the dataset
				Description *string `json:"description"`

				// DtCreated The date the dataset was created
				DtCreated time.Time `json:"dtCreated"`

				// DtModified The date the dataset was last modified
				DtModified time.Time `json:"dtModified"`

				// Id The ID of the dataset
				Id string `json:"id"`

				// IsPublic Whether the dataset is public
				IsPublic bool `json:"isPublic"`

				// Name The name of the dataset
				Name *string `json:"name"`

				// StorageProviderId The ID of the storage provider
				StorageProviderId *string `json:"storageProviderId"`

				// TeamId The ID of the team that owns the dataset
				TeamId string `json:"teamId"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDatasetsCreateResponse parses an HTTP response from a DatasetsCreateWithResponse call
func ParseDatasetsCreateResponse(rsp *http.Response) (*DatasetsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Description The description of the dataset
			Description *string `json:"description"`

			// DtCreated The date the dataset was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the dataset was last modified
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the dataset
			Id string `json:"id"`

			// IsPublic Whether the dataset is public
			IsPublic bool `json:"isPublic"`

			// Name The name of the dataset
			Name *string `json:"name"`

			// StorageProviderId The ID of the storage provider
			StorageProviderId *string `json:"storageProviderId"`

			// TeamId The ID of the team that owns the dataset
			TeamId string `json:"teamId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDatasetVersionsListResponse parses an HTTP response from a DatasetVersionsListWithResponse call
func ParseDatasetVersionsListResponse(rsp *http.Response) (*DatasetVersionsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetVersionsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// DatasetId The ID of the dataset
				DatasetId string `json:"datasetId"`

				// DtCreated The date the version was created
				DtCreated time.Time `json:"dtCreated"`

				// DtModified The date the version was last modified
				DtModified time.Time `json:"dtModified"`

				// IsCommitted Whether the version is committed
				IsCommitted bool `json:"isCommitted"`

				// Message The description of the dataset version
				Message *string `json:"message"`

				// Metadata Metadata for the version.
				Metadata *map[string]interface{} `json:"metadata"`

				// Tags The tags for the version
				Tags []string `json:"tags"`

				// Url The URL of the version
				Url *string `json:"url"`

				// UsageBytes The size of the dataset at this version in bytes
				UsageBytes *string `json:"usageBytes"`

				// UserId The ID of the user that created the version
				UserId *string `json:"userId"`

				// Version The version of the dataset
				Version string `json:"version"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDatasetVersionsCreateResponse parses an HTTP response from a DatasetVersionsCreateWithResponse call
func ParseDatasetVersionsCreateResponse(rsp *http.Response) (*DatasetVersionsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetVersionsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DatasetId The ID of the dataset
			DatasetId string `json:"datasetId"`

			// DtCreated The date the version was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the version was last modified
			DtModified time.Time `json:"dtModified"`

			// IsCommitted Whether the version is committed
			IsCommitted bool `json:"isCommitted"`

			// Message The description of the dataset version
			Message *string `json:"message"`

			// Metadata Metadata for the version.
			Metadata *map[string]interface{} `json:"metadata"`

			// Tags The tags for the version
			Tags []string `json:"tags"`

			// Url The URL of the version
			Url *string `json:"url"`

			// UsageBytes The size of the dataset at this version in bytes
			UsageBytes *string `json:"usageBytes"`

			// UserId The ID of the user that created the version
			UserId *string `json:"userId"`

			// Version The version of the dataset
			Version string `json:"version"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDatasetVersionsDeleteResponse parses an HTTP response from a DatasetVersionsDeleteWithResponse call
func ParseDatasetVersionsDeleteResponse(rsp *http.Response) (*DatasetVersionsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetVersionsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DatasetId The ID of the dataset
			DatasetId string `json:"datasetId"`

			// Version The version of the dataset
			Version string `json:"version"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDatasetVersionsGetResponse parses an HTTP response from a DatasetVersionsGetWithResponse call
func ParseDatasetVersionsGetResponse(rsp *http.Response) (*DatasetVersionsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetVersionsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DatasetId The ID of the dataset
			DatasetId string `json:"datasetId"`

			// DtCreated The date the version was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the version was last modified
			DtModified time.Time `json:"dtModified"`

			// IsCommitted Whether the version is committed
			IsCommitted bool `json:"isCommitted"`

			// Message The description of the dataset version
			Message *string `json:"message"`

			// Metadata Metadata for the version.
			Metadata *map[string]interface{} `json:"metadata"`

			// Tags The tags for the version
			Tags []string `json:"tags"`

			// Url The URL of the version
			Url *string `json:"url"`

			// UsageBytes The size of the dataset at this version in bytes
			UsageBytes *string `json:"usageBytes"`

			// UserId The ID of the user that created the version
			UserId *string `json:"userId"`

			// Version The version of the dataset
			Version string `json:"version"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDatasetVersionsUpdateResponse parses an HTTP response from a DatasetVersionsUpdateWithResponse call
func ParseDatasetVersionsUpdateResponse(rsp *http.Response) (*DatasetVersionsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetVersionsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DatasetId The ID of the dataset
			DatasetId string `json:"datasetId"`

			// DtCreated The date the version was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the version was last modified
			DtModified time.Time `json:"dtModified"`

			// IsCommitted Whether the version is committed
			IsCommitted bool `json:"isCommitted"`

			// Message The description of the dataset version
			Message *string `json:"message"`

			// Metadata Metadata for the version.
			Metadata *map[string]interface{} `json:"metadata"`

			// Tags The tags for the version
			Tags []string `json:"tags"`

			// Url The URL of the version
			Url *string `json:"url"`

			// UsageBytes The size of the dataset at this version in bytes
			UsageBytes *string `json:"usageBytes"`

			// UserId The ID of the user that created the version
			UserId *string `json:"userId"`

			// Version The version of the dataset
			Version string `json:"version"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDatasetsDeleteResponse parses an HTTP response from a DatasetsDeleteWithResponse call
func ParseDatasetsDeleteResponse(rsp *http.Response) (*DatasetsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The ID of the dataset
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDatasetsGetResponse parses an HTTP response from a DatasetsGetWithResponse call
func ParseDatasetsGetResponse(rsp *http.Response) (*DatasetsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Description The description of the dataset
			Description *string `json:"description"`

			// DtCreated The date the dataset was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the dataset was last modified
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the dataset
			Id string `json:"id"`

			// IsPublic Whether the dataset is public
			IsPublic bool `json:"isPublic"`

			// Name The name of the dataset
			Name *string `json:"name"`

			// StorageProviderId The ID of the storage provider
			StorageProviderId *string `json:"storageProviderId"`

			// TeamId The ID of the team that owns the dataset
			TeamId string `json:"teamId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDatasetsUpdateResponse parses an HTTP response from a DatasetsUpdateWithResponse call
func ParseDatasetsUpdateResponse(rsp *http.Response) (*DatasetsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Description The description of the dataset
			Description *string `json:"description"`

			// DtCreated The date the dataset was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the dataset was last modified
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the dataset
			Id string `json:"id"`

			// IsPublic Whether the dataset is public
			IsPublic bool `json:"isPublic"`

			// Name The name of the dataset
			Name *string `json:"name"`

			// StorageProviderId The ID of the storage provider
			StorageProviderId *string `json:"storageProviderId"`

			// TeamId The ID of the team that owns the dataset
			TeamId string `json:"teamId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeploymentsListResponse parses an HTTP response from a DeploymentsListWithResponse call
func ParseDeploymentsListResponse(rsp *http.Response) (*DeploymentsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeploymentsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// BasicAuthKey The endpoint security key for the deployment
				BasicAuthKey *string `json:"basicAuthKey"`

				// DtCreated The date the deployment was created
				DtCreated time.Time `json:"dtCreated"`

				// Endpoint The unique endpoint for the deployment
				Endpoint string `json:"endpoint"`

				// Id The ID of the deployment
				Id string `json:"id"`

				// LatestSpec The latest deployment configuration. If invalid, null is returned.
				LatestSpec *struct {
					// Data The data for the deployment spec
					Data *DeploymentsList_200_Items_LatestSpec_Data `json:"data"`

					// DeploymentId The ID of the deployment the spec belongs to
					DeploymentId string `json:"deploymentId"`

					// DtHealthy The date the deployment was marked "healthy"
					DtHealthy *time.Time `json:"dtHealthy"`

					// Error The fatal configuration error. Only present if the cluster was unable to apply the entire deployment configuration. This is not the same as an instance error.
					Error *string `json:"error"`

					// ExternalApplied The date the deployment configuration was applied to the cluster
					ExternalApplied *time.Time `json:"externalApplied"`

					// Id The ID of the deployment spec
					Id string `json:"id"`

					// Metadata Metadata about the source of the configuration
					Metadata *struct {
						GitHeaders *struct {
							XGitActor string                                                            `json:"x-git-actor"`
							XGitHost  DeploymentsList_200_Items_LatestSpec_Metadata_GitHeaders_XGitHost `json:"x-git-host"`
							XGitOwner string                                                            `json:"x-git-owner"`
							XGitRef   string                                                            `json:"x-git-ref"`
							XGitRepo  string                                                            `json:"x-git-repo"`
							XGitSha   string                                                            `json:"x-git-sha"`
						} `json:"gitHeaders,omitempty"`
					} `json:"metadata"`

					// UserId The ID of the user the deployment belongs to
					UserId string `json:"userId"`
				} `json:"latestSpec"`

				// LatestSpecHash The last version hash for the deployment
				LatestSpecHash *string `json:"latestSpecHash"`

				// Name The name of the deployment
				Name string `json:"name"`

				// ProjectId The ID of the project the deployment belongs to
				ProjectId string `json:"projectId"`

				// TeamId The ID of the team the deployment belongs to
				TeamId string `json:"teamId"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeploymentsUpsertResponse parses an HTTP response from a DeploymentsUpsertWithResponse call
func ParseDeploymentsUpsertResponse(rsp *http.Response) (*DeploymentsUpsertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeploymentsUpsertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DeploymentId The ID of the deployment
			DeploymentId string `json:"deploymentId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeploymentsDeleteResponse parses an HTTP response from a DeploymentsDeleteWithResponse call
func ParseDeploymentsDeleteResponse(rsp *http.Response) (*DeploymentsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeploymentsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The ID of the deleted deployment
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeploymentsGetResponse parses an HTTP response from a DeploymentsGetWithResponse call
func ParseDeploymentsGetResponse(rsp *http.Response) (*DeploymentsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeploymentsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BasicAuthKey The endpoint security key for the deployment
			BasicAuthKey *string `json:"basicAuthKey"`

			// DtCreated The date the deployment was created
			DtCreated time.Time `json:"dtCreated"`

			// Endpoint The unique endpoint for the deployment
			Endpoint string `json:"endpoint"`

			// Id The ID of the deployment
			Id string `json:"id"`

			// LatestSpec The latest deployment configuration. If invalid, null is returned.
			LatestSpec *struct {
				// Data The data for the deployment spec
				Data *DeploymentsGet_200_LatestSpec_Data `json:"data"`

				// DeploymentId The ID of the deployment the spec belongs to
				DeploymentId string `json:"deploymentId"`

				// DtHealthy The date the deployment was marked "healthy"
				DtHealthy *time.Time `json:"dtHealthy"`

				// Error The fatal configuration error. Only present if the cluster was unable to apply the entire deployment configuration. This is not the same as an instance error.
				Error *string `json:"error"`

				// ExternalApplied The date the deployment configuration was applied to the cluster
				ExternalApplied *time.Time `json:"externalApplied"`

				// Id The ID of the deployment spec
				Id string `json:"id"`

				// Metadata Metadata about the source of the configuration
				Metadata *struct {
					GitHeaders *struct {
						XGitActor string                                                     `json:"x-git-actor"`
						XGitHost  DeploymentsGet_200_LatestSpec_Metadata_GitHeaders_XGitHost `json:"x-git-host"`
						XGitOwner string                                                     `json:"x-git-owner"`
						XGitRef   string                                                     `json:"x-git-ref"`
						XGitRepo  string                                                     `json:"x-git-repo"`
						XGitSha   string                                                     `json:"x-git-sha"`
					} `json:"gitHeaders,omitempty"`
				} `json:"metadata"`

				// UserId The ID of the user the deployment belongs to
				UserId string `json:"userId"`
			} `json:"latestSpec"`

			// LatestSpecHash The last version hash for the deployment
			LatestSpecHash *string `json:"latestSpecHash"`

			// Name The name of the deployment
			Name string `json:"name"`

			// ProjectId The ID of the project the deployment belongs to
			ProjectId string `json:"projectId"`

			// TeamId The ID of the team the deployment belongs to
			TeamId string `json:"teamId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeploymentHistoryListResponse parses an HTTP response from a DeploymentHistoryListWithResponse call
func ParseDeploymentHistoryListResponse(rsp *http.Response) (*DeploymentHistoryListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeploymentHistoryListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// Data The data for the deployment spec
				Data *DeploymentHistoryList_200_Items_Data `json:"data"`

				// DeploymentId The ID of the deployment the spec belongs to
				DeploymentId string `json:"deploymentId"`

				// DtHealthy The date the deployment was marked "healthy"
				DtHealthy *time.Time `json:"dtHealthy"`

				// Error The fatal configuration error. Only present if the cluster was unable to apply the entire deployment configuration. This is not the same as an instance error.
				Error *string `json:"error"`

				// ExternalApplied The date the deployment configuration was applied to the cluster
				ExternalApplied *time.Time `json:"externalApplied"`

				// Id The ID of the deployment spec
				Id string `json:"id"`

				// Metadata Metadata about the source of the configuration
				Metadata *struct {
					GitHeaders *struct {
						XGitActor string                                                       `json:"x-git-actor"`
						XGitHost  DeploymentHistoryList_200_Items_Metadata_GitHeaders_XGitHost `json:"x-git-host"`
						XGitOwner string                                                       `json:"x-git-owner"`
						XGitRef   string                                                       `json:"x-git-ref"`
						XGitRepo  string                                                       `json:"x-git-repo"`
						XGitSha   string                                                       `json:"x-git-sha"`
					} `json:"gitHeaders,omitempty"`
				} `json:"metadata"`

				// UserId The ID of the user the deployment belongs to
				UserId      string `json:"userId"`
				WorkflowRun *struct {
					// DtCreated When the workflow run was created
					DtCreated *time.Time `json:"dtCreated"`

					// DtFinished When the workflow run finished
					DtFinished *time.Time `json:"dtFinished"`

					// DtStarted When the workflow run started
					DtStarted *time.Time `json:"dtStarted"`

					// Id The ID of the workflow run
					Id openapi_types.UUID `json:"id"`

					// Message The message of the workflow run
					Message *string `json:"message"`

					// Phase The phase of the workflow run
					Phase    DeploymentHistoryList200ItemsWorkflowRunPhase `json:"phase"`
					Workflow struct {
						// DtCreated When the workflow was created
						DtCreated *time.Time `json:"dtCreated"`

						// Id The ID of the workflow
						Id openapi_types.UUID `json:"id"`

						// Name The name of the workflow
						Name *string `json:"name"`
					} `json:"workflow"`

					// WorkflowId The ID of the workflow
					WorkflowId openapi_types.UUID `json:"workflowId"`
				} `json:"workflowRun"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeploymentLogsListResponse parses an HTTP response from a DeploymentLogsListWithResponse call
func ParseDeploymentLogsListResponse(rsp *http.Response) (*DeploymentLogsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeploymentLogsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// DtCreated The date the log was created.
				DtCreated time.Time `json:"dtCreated"`

				// Id ID of the log item
				Id string `json:"id"`

				// InstanceId The instance ID the log is associated with.
				InstanceId *string `json:"instanceId"`

				// JobId The associated job ID of the log item.
				JobId string `json:"jobId"`

				// Message The message of the log item.
				Message string `json:"message"`

				// Uuid UUID representing the log item
				Uuid *string `json:"uuid"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeploymentMetricsGetResponse parses an HTTP response from a DeploymentMetricsGetWithResponse call
func ParseDeploymentMetricsGetResponse(rsp *http.Response) (*DeploymentMetricsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeploymentMetricsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeploymentRunsGetResponse parses an HTTP response from a DeploymentRunsGetWithResponse call
func ParseDeploymentRunsGetResponse(rsp *http.Response) (*DeploymentRunsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeploymentRunsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// AvailableReplicas The amount of replicas that are available but not ready
			AvailableReplicas *float32 `json:"availableReplicas"`
			Id                string   `json:"id"`

			// Instances The deployment run instances
			Instances []struct {
				// DtCreated The date the instance was created
				DtCreated time.Time `json:"dtCreated"`

				// DtFinished The date the instance was finished
				DtFinished *time.Time `json:"dtFinished"`

				// History The time series state history of the deployment instance
				History []struct {
					// Message The state message from the instance at the point in time
					Message *string `json:"message"`

					// State The state of the instance at the point in time
					State string `json:"state"`

					// Timestamp The timestamp of the state
					Timestamp time.Time `json:"timestamp"`
				} `json:"history"`

				// Id The ID of the deployment instance
				Id string `json:"id"`

				// InstanceId The ID of the deployment instance
				InstanceId string `json:"instanceId"`

				// State The current state of the instance
				State string `json:"state"`

				// StateMessage The latest state message for the instance
				StateMessage *string `json:"stateMessage"`
			} `json:"instances"`

			// ReadyReplicas The amount of replicas that are ready
			ReadyReplicas *float32 `json:"readyReplicas"`

			// Replicas The desired amount of replicas for the deployment run
			Replicas *float32 `json:"replicas"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMachineAvailabilityListResponse parses an HTTP response from a MachineAvailabilityListWithResponse call
func ParseMachineAvailabilityListResponse(rsp *http.Response) (*MachineAvailabilityListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachineAvailabilityListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Available bool `json:"available"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMachineEventsListResponse parses an HTTP response from a MachineEventsListWithResponse call
func ParseMachineEventsListResponse(rsp *http.Response) (*MachineEventsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachineEventsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// DtCreated The date the event was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtFinished The date the event was finished.
				DtFinished *time.Time `json:"dtFinished"`

				// DtStarted The date the event was started.
				DtStarted *time.Time `json:"dtStarted"`

				// Error The error message of the event, if any.
				Error *string `json:"error"`

				// Id The ID of the event.
				Id string `json:"id"`

				// MachineId The ID of the machine the event is for.
				MachineId *string `json:"machineId"`

				// Name The name of the event, e.g. "create".
				Name MachineEventsList200ItemsName `json:"name"`

				// State The state of the event, e.g. "done".
				State MachineEventsList200ItemsState `json:"state"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMachineEventsGetResponse parses an HTTP response from a MachineEventsGetWithResponse call
func ParseMachineEventsGetResponse(rsp *http.Response) (*MachineEventsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachineEventsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the event was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtFinished The date the event was finished.
			DtFinished *time.Time `json:"dtFinished"`

			// DtStarted The date the event was started.
			DtStarted *time.Time `json:"dtStarted"`

			// Error The error message of the event, if any.
			Error *string `json:"error"`

			// Id The ID of the event.
			Id string `json:"id"`

			// MachineId The ID of the machine the event is for.
			MachineId *string `json:"machineId"`

			// Name The name of the event, e.g. "create".
			Name MachineEventsGet200Name `json:"name"`

			// State The state of the event, e.g. "done".
			State MachineEventsGet200State `json:"state"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMachinesListResponse parses an HTTP response from a MachinesListWithResponse call
func ParseMachinesListResponse(rsp *http.Response) (*MachinesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// Accelerators The accelerators of the machine.
				Accelerators *[]struct {
					// Count The number of accelerators of this type.
					Count float32 `json:"count"`

					// Memory The amount of memory the accelerator has, if applicable.
					Memory *int `json:"memory"`

					// Name The name of the accelerator.
					Name string `json:"name"`
				} `json:"accelerators"`

				// AgentType The agent type of the machine.
				AgentType string `json:"agentType"`

				// AutoShutdownEnabled Whether auto shutdown is enabled.
				AutoShutdownEnabled bool `json:"autoShutdownEnabled"`

				// AutoShutdownForce Whether to force shutdown the machine.
				AutoShutdownForce *bool `json:"autoShutdownForce"`

				// AutoShutdownTimeout The shutdown timeout of the machine in hours.
				AutoShutdownTimeout *float32 `json:"autoShutdownTimeout"`

				// AutoSnapshotEnabled Whether auto snapshots are enabled.
				AutoSnapshotEnabled bool `json:"autoSnapshotEnabled"`

				// AutoSnapshotFrequency The frequency of auto snapshots.
				AutoSnapshotFrequency *MachinesList200ItemsAutoSnapshotFrequency `json:"autoSnapshotFrequency"`

				// AutoSnapshotSaveCount The number of auto snapshots to save.
				AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount"`

				// Cpus The number of CPUs.
				Cpus float32 `json:"cpus"`

				// DtCreated The date the machine was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtDeleted The date the machine was deleted.
				DtDeleted *time.Time `json:"dtDeleted"`

				// DtModified The date the machine was last modified.
				DtModified time.Time `json:"dtModified"`

				// Id The ID of the machine.
				Id string `json:"id"`

				// MachineType The type of the machine.
				MachineType string `json:"machineType"`

				// Name The name of the machine.
				Name string `json:"name"`

				// NetworkId The ID of the network the machine is on.
				NetworkId *string `json:"networkId"`

				// Os The operating system of the machine.
				Os string `json:"os"`

				// PrivateIp The private IP address of the machine.
				PrivateIp *string `json:"privateIp"`

				// PublicIp The public IP address of the machine.
				PublicIp *string `json:"publicIp"`

				// PublicIpType The public IP type.
				PublicIpType MachinesList200ItemsPublicIpType `json:"publicIpType"`

				// Ram The amount of RAM in bytes.
				Ram int64 `json:"ram"`

				// Region The region of the machine.
				Region      MachinesList_200_Items_Region `json:"region"`
				Reservation *struct {
					DtFinished time.Time          `json:"dtFinished"`
					DtStarted  time.Time          `json:"dtStarted"`
					Id         openapi_types.UUID `json:"id"`
					IsActive   bool               `json:"isActive"`
					Name       string             `json:"name"`
				} `json:"reservation"`

				// RestorePointEnabled Whether a restore point is enabled.
				RestorePointEnabled bool `json:"restorePointEnabled"`

				// RestorePointFrequency The frequency of restore points.
				RestorePointFrequency *MachinesList200ItemsRestorePointFrequency `json:"restorePointFrequency"`

				// RestorePointSnapshotId The ID of the snapshot to use as a restore point.
				RestorePointSnapshotId *string `json:"restorePointSnapshotId"`

				// State The state of the machine.
				State MachinesList200ItemsState `json:"state"`

				// StorageRate The storage rate of the machine.
				StorageRate float32 `json:"storageRate"`

				// StorageTotal The total amount of storage.
				StorageTotal int64 `json:"storageTotal"`

				// StorageUsed The amount of storage used.
				StorageUsed int64 `json:"storageUsed"`

				// UpdatesPending Whether updates are pending.
				UpdatesPending bool `json:"updatesPending"`

				// UsageRate The usage rate of the machine.
				UsageRate float32 `json:"usageRate"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMachinesCreateResponse parses an HTTP response from a MachinesCreateWithResponse call
func ParseMachinesCreateResponse(rsp *http.Response) (*MachinesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The machine.
			Data struct {
				// Accelerators The accelerators of the machine.
				Accelerators *[]struct {
					// Count The number of accelerators of this type.
					Count float32 `json:"count"`

					// Memory The amount of memory the accelerator has, if applicable.
					Memory *int `json:"memory"`

					// Name The name of the accelerator.
					Name string `json:"name"`
				} `json:"accelerators"`

				// AgentType The agent type of the machine.
				AgentType string `json:"agentType"`

				// AutoShutdownEnabled Whether auto shutdown is enabled.
				AutoShutdownEnabled bool `json:"autoShutdownEnabled"`

				// AutoShutdownForce Whether to force shutdown the machine.
				AutoShutdownForce *bool `json:"autoShutdownForce"`

				// AutoShutdownTimeout The shutdown timeout of the machine in hours.
				AutoShutdownTimeout *float32 `json:"autoShutdownTimeout"`

				// AutoSnapshotEnabled Whether auto snapshots are enabled.
				AutoSnapshotEnabled bool `json:"autoSnapshotEnabled"`

				// AutoSnapshotFrequency The frequency of auto snapshots.
				AutoSnapshotFrequency *MachinesCreate200DataAutoSnapshotFrequency `json:"autoSnapshotFrequency"`

				// AutoSnapshotSaveCount The number of auto snapshots to save.
				AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount"`

				// Cpus The number of CPUs.
				Cpus float32 `json:"cpus"`

				// DtCreated The date the machine was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtDeleted The date the machine was deleted.
				DtDeleted *time.Time `json:"dtDeleted"`

				// DtModified The date the machine was last modified.
				DtModified time.Time `json:"dtModified"`

				// Id The ID of the machine.
				Id string `json:"id"`

				// MachineType The type of the machine.
				MachineType string `json:"machineType"`

				// Name The name of the machine.
				Name string `json:"name"`

				// NetworkId The ID of the network the machine is on.
				NetworkId *string `json:"networkId"`

				// Os The operating system of the machine.
				Os string `json:"os"`

				// PrivateIp The private IP address of the machine.
				PrivateIp *string `json:"privateIp"`

				// PublicIp The public IP address of the machine.
				PublicIp *string `json:"publicIp"`

				// PublicIpType The public IP type.
				PublicIpType MachinesCreate200DataPublicIpType `json:"publicIpType"`

				// Ram The amount of RAM in bytes.
				Ram int64 `json:"ram"`

				// Region The region of the machine.
				Region      MachinesCreate_200_Data_Region `json:"region"`
				Reservation *struct {
					DtFinished time.Time          `json:"dtFinished"`
					DtStarted  time.Time          `json:"dtStarted"`
					Id         openapi_types.UUID `json:"id"`
					IsActive   bool               `json:"isActive"`
					Name       string             `json:"name"`
				} `json:"reservation"`

				// RestorePointEnabled Whether a restore point is enabled.
				RestorePointEnabled bool `json:"restorePointEnabled"`

				// RestorePointFrequency The frequency of restore points.
				RestorePointFrequency *MachinesCreate200DataRestorePointFrequency `json:"restorePointFrequency"`

				// RestorePointSnapshotId The ID of the snapshot to use as a restore point.
				RestorePointSnapshotId *string `json:"restorePointSnapshotId"`

				// State The state of the machine.
				State MachinesCreate200DataState `json:"state"`

				// StorageRate The storage rate of the machine.
				StorageRate float32 `json:"storageRate"`

				// StorageTotal The total amount of storage.
				StorageTotal int64 `json:"storageTotal"`

				// StorageUsed The amount of storage used.
				StorageUsed int64 `json:"storageUsed"`

				// UpdatesPending Whether updates are pending.
				UpdatesPending bool `json:"updatesPending"`

				// UsageRate The usage rate of the machine.
				UsageRate float32 `json:"usageRate"`
			} `json:"data"`

			// Event The machine event to poll for the async operation.
			Event struct {
				// DtCreated The date the event was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtFinished The date the event was finished.
				DtFinished *time.Time `json:"dtFinished"`

				// DtStarted The date the event was started.
				DtStarted *time.Time `json:"dtStarted"`

				// Error The error message of the event, if any.
				Error *string `json:"error"`

				// Id The ID of the event.
				Id string `json:"id"`

				// MachineId The ID of the machine the event is for.
				MachineId *string `json:"machineId"`

				// Name The name of the event, e.g. "create".
				Name MachinesCreate200EventName `json:"name"`

				// State The state of the event, e.g. "done".
				State MachinesCreate200EventState `json:"state"`
			} `json:"event"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMachinesDeleteResponse parses an HTTP response from a MachinesDeleteWithResponse call
func ParseMachinesDeleteResponse(rsp *http.Response) (*MachinesDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The machine.
			Data struct {
				// Accelerators The accelerators of the machine.
				Accelerators *[]struct {
					// Count The number of accelerators of this type.
					Count float32 `json:"count"`

					// Memory The amount of memory the accelerator has, if applicable.
					Memory *int `json:"memory"`

					// Name The name of the accelerator.
					Name string `json:"name"`
				} `json:"accelerators"`

				// AgentType The agent type of the machine.
				AgentType string `json:"agentType"`

				// AutoShutdownEnabled Whether auto shutdown is enabled.
				AutoShutdownEnabled bool `json:"autoShutdownEnabled"`

				// AutoShutdownForce Whether to force shutdown the machine.
				AutoShutdownForce *bool `json:"autoShutdownForce"`

				// AutoShutdownTimeout The shutdown timeout of the machine in hours.
				AutoShutdownTimeout *float32 `json:"autoShutdownTimeout"`

				// AutoSnapshotEnabled Whether auto snapshots are enabled.
				AutoSnapshotEnabled bool `json:"autoSnapshotEnabled"`

				// AutoSnapshotFrequency The frequency of auto snapshots.
				AutoSnapshotFrequency *MachinesDelete200DataAutoSnapshotFrequency `json:"autoSnapshotFrequency"`

				// AutoSnapshotSaveCount The number of auto snapshots to save.
				AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount"`

				// Cpus The number of CPUs.
				Cpus float32 `json:"cpus"`

				// DtCreated The date the machine was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtDeleted The date the machine was deleted.
				DtDeleted *time.Time `json:"dtDeleted"`

				// DtModified The date the machine was last modified.
				DtModified time.Time `json:"dtModified"`

				// Id The ID of the machine.
				Id string `json:"id"`

				// MachineType The type of the machine.
				MachineType string `json:"machineType"`

				// Name The name of the machine.
				Name string `json:"name"`

				// NetworkId The ID of the network the machine is on.
				NetworkId *string `json:"networkId"`

				// Os The operating system of the machine.
				Os string `json:"os"`

				// PrivateIp The private IP address of the machine.
				PrivateIp *string `json:"privateIp"`

				// PublicIp The public IP address of the machine.
				PublicIp *string `json:"publicIp"`

				// PublicIpType The public IP type.
				PublicIpType MachinesDelete200DataPublicIpType `json:"publicIpType"`

				// Ram The amount of RAM in bytes.
				Ram int64 `json:"ram"`

				// Region The region of the machine.
				Region      MachinesDelete_200_Data_Region `json:"region"`
				Reservation *struct {
					DtFinished time.Time          `json:"dtFinished"`
					DtStarted  time.Time          `json:"dtStarted"`
					Id         openapi_types.UUID `json:"id"`
					IsActive   bool               `json:"isActive"`
					Name       string             `json:"name"`
				} `json:"reservation"`

				// RestorePointEnabled Whether a restore point is enabled.
				RestorePointEnabled bool `json:"restorePointEnabled"`

				// RestorePointFrequency The frequency of restore points.
				RestorePointFrequency *MachinesDelete200DataRestorePointFrequency `json:"restorePointFrequency"`

				// RestorePointSnapshotId The ID of the snapshot to use as a restore point.
				RestorePointSnapshotId *string `json:"restorePointSnapshotId"`

				// State The state of the machine.
				State MachinesDelete200DataState `json:"state"`

				// StorageRate The storage rate of the machine.
				StorageRate float32 `json:"storageRate"`

				// StorageTotal The total amount of storage.
				StorageTotal int64 `json:"storageTotal"`

				// StorageUsed The amount of storage used.
				StorageUsed int64 `json:"storageUsed"`

				// UpdatesPending Whether updates are pending.
				UpdatesPending bool `json:"updatesPending"`

				// UsageRate The usage rate of the machine.
				UsageRate float32 `json:"usageRate"`
			} `json:"data"`

			// Event The machine event to poll for the async operation.
			Event struct {
				// DtCreated The date the event was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtFinished The date the event was finished.
				DtFinished *time.Time `json:"dtFinished"`

				// DtStarted The date the event was started.
				DtStarted *time.Time `json:"dtStarted"`

				// Error The error message of the event, if any.
				Error *string `json:"error"`

				// Id The ID of the event.
				Id string `json:"id"`

				// MachineId The ID of the machine the event is for.
				MachineId *string `json:"machineId"`

				// Name The name of the event, e.g. "create".
				Name MachinesDelete200EventName `json:"name"`

				// State The state of the event, e.g. "done".
				State MachinesDelete200EventState `json:"state"`
			} `json:"event"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMachinesGetResponse parses an HTTP response from a MachinesGetWithResponse call
func ParseMachinesGetResponse(rsp *http.Response) (*MachinesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Accelerators The accelerators of the machine.
			Accelerators *[]struct {
				// Count The number of accelerators of this type.
				Count float32 `json:"count"`

				// Memory The amount of memory the accelerator has, if applicable.
				Memory *int `json:"memory"`

				// Name The name of the accelerator.
				Name string `json:"name"`
			} `json:"accelerators"`

			// AgentType The agent type of the machine.
			AgentType string `json:"agentType"`

			// AutoShutdownEnabled Whether auto shutdown is enabled.
			AutoShutdownEnabled bool `json:"autoShutdownEnabled"`

			// AutoShutdownForce Whether to force shutdown the machine.
			AutoShutdownForce *bool `json:"autoShutdownForce"`

			// AutoShutdownTimeout The shutdown timeout of the machine in hours.
			AutoShutdownTimeout *float32 `json:"autoShutdownTimeout"`

			// AutoSnapshotEnabled Whether auto snapshots are enabled.
			AutoSnapshotEnabled bool `json:"autoSnapshotEnabled"`

			// AutoSnapshotFrequency The frequency of auto snapshots.
			AutoSnapshotFrequency *MachinesGet200AutoSnapshotFrequency `json:"autoSnapshotFrequency"`

			// AutoSnapshotSaveCount The number of auto snapshots to save.
			AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount"`

			// Cpus The number of CPUs.
			Cpus float32 `json:"cpus"`

			// DtCreated The date the machine was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the machine was deleted.
			DtDeleted *time.Time `json:"dtDeleted"`

			// DtModified The date the machine was last modified.
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the machine.
			Id string `json:"id"`

			// MachineType The type of the machine.
			MachineType string `json:"machineType"`

			// Name The name of the machine.
			Name string `json:"name"`

			// NetworkId The ID of the network the machine is on.
			NetworkId *string `json:"networkId"`

			// Os The operating system of the machine.
			Os string `json:"os"`

			// PrivateIp The private IP address of the machine.
			PrivateIp *string `json:"privateIp"`

			// PublicIp The public IP address of the machine.
			PublicIp *string `json:"publicIp"`

			// PublicIpType The public IP type.
			PublicIpType MachinesGet200PublicIpType `json:"publicIpType"`

			// Ram The amount of RAM in bytes.
			Ram int64 `json:"ram"`

			// Region The region of the machine.
			Region      MachinesGet_200_Region `json:"region"`
			Reservation *struct {
				DtFinished time.Time          `json:"dtFinished"`
				DtStarted  time.Time          `json:"dtStarted"`
				Id         openapi_types.UUID `json:"id"`
				IsActive   bool               `json:"isActive"`
				Name       string             `json:"name"`
			} `json:"reservation"`

			// RestorePointEnabled Whether a restore point is enabled.
			RestorePointEnabled bool `json:"restorePointEnabled"`

			// RestorePointFrequency The frequency of restore points.
			RestorePointFrequency *MachinesGet200RestorePointFrequency `json:"restorePointFrequency"`

			// RestorePointSnapshotId The ID of the snapshot to use as a restore point.
			RestorePointSnapshotId *string `json:"restorePointSnapshotId"`

			// State The state of the machine.
			State MachinesGet200State `json:"state"`

			// StorageRate The storage rate of the machine.
			StorageRate float32 `json:"storageRate"`

			// StorageTotal The total amount of storage.
			StorageTotal int64 `json:"storageTotal"`

			// StorageUsed The amount of storage used.
			StorageUsed int64 `json:"storageUsed"`

			// UpdatesPending Whether updates are pending.
			UpdatesPending bool `json:"updatesPending"`

			// UsageRate The usage rate of the machine.
			UsageRate float32 `json:"usageRate"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMachinesUpdateResponse parses an HTTP response from a MachinesUpdateWithResponse call
func ParseMachinesUpdateResponse(rsp *http.Response) (*MachinesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The machine.
			Data struct {
				// Accelerators The accelerators of the machine.
				Accelerators *[]struct {
					// Count The number of accelerators of this type.
					Count float32 `json:"count"`

					// Memory The amount of memory the accelerator has, if applicable.
					Memory *int `json:"memory"`

					// Name The name of the accelerator.
					Name string `json:"name"`
				} `json:"accelerators"`

				// AgentType The agent type of the machine.
				AgentType string `json:"agentType"`

				// AutoShutdownEnabled Whether auto shutdown is enabled.
				AutoShutdownEnabled bool `json:"autoShutdownEnabled"`

				// AutoShutdownForce Whether to force shutdown the machine.
				AutoShutdownForce *bool `json:"autoShutdownForce"`

				// AutoShutdownTimeout The shutdown timeout of the machine in hours.
				AutoShutdownTimeout *float32 `json:"autoShutdownTimeout"`

				// AutoSnapshotEnabled Whether auto snapshots are enabled.
				AutoSnapshotEnabled bool `json:"autoSnapshotEnabled"`

				// AutoSnapshotFrequency The frequency of auto snapshots.
				AutoSnapshotFrequency *MachinesUpdate200DataAutoSnapshotFrequency `json:"autoSnapshotFrequency"`

				// AutoSnapshotSaveCount The number of auto snapshots to save.
				AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount"`

				// Cpus The number of CPUs.
				Cpus float32 `json:"cpus"`

				// DtCreated The date the machine was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtDeleted The date the machine was deleted.
				DtDeleted *time.Time `json:"dtDeleted"`

				// DtModified The date the machine was last modified.
				DtModified time.Time `json:"dtModified"`

				// Id The ID of the machine.
				Id string `json:"id"`

				// MachineType The type of the machine.
				MachineType string `json:"machineType"`

				// Name The name of the machine.
				Name string `json:"name"`

				// NetworkId The ID of the network the machine is on.
				NetworkId *string `json:"networkId"`

				// Os The operating system of the machine.
				Os string `json:"os"`

				// PrivateIp The private IP address of the machine.
				PrivateIp *string `json:"privateIp"`

				// PublicIp The public IP address of the machine.
				PublicIp *string `json:"publicIp"`

				// PublicIpType The public IP type.
				PublicIpType MachinesUpdate200DataPublicIpType `json:"publicIpType"`

				// Ram The amount of RAM in bytes.
				Ram int64 `json:"ram"`

				// Region The region of the machine.
				Region      MachinesUpdate_200_Data_Region `json:"region"`
				Reservation *struct {
					DtFinished time.Time          `json:"dtFinished"`
					DtStarted  time.Time          `json:"dtStarted"`
					Id         openapi_types.UUID `json:"id"`
					IsActive   bool               `json:"isActive"`
					Name       string             `json:"name"`
				} `json:"reservation"`

				// RestorePointEnabled Whether a restore point is enabled.
				RestorePointEnabled bool `json:"restorePointEnabled"`

				// RestorePointFrequency The frequency of restore points.
				RestorePointFrequency *MachinesUpdate200DataRestorePointFrequency `json:"restorePointFrequency"`

				// RestorePointSnapshotId The ID of the snapshot to use as a restore point.
				RestorePointSnapshotId *string `json:"restorePointSnapshotId"`

				// State The state of the machine.
				State MachinesUpdate200DataState `json:"state"`

				// StorageRate The storage rate of the machine.
				StorageRate float32 `json:"storageRate"`

				// StorageTotal The total amount of storage.
				StorageTotal int64 `json:"storageTotal"`

				// StorageUsed The amount of storage used.
				StorageUsed int64 `json:"storageUsed"`

				// UpdatesPending Whether updates are pending.
				UpdatesPending bool `json:"updatesPending"`

				// UsageRate The usage rate of the machine.
				UsageRate float32 `json:"usageRate"`
			} `json:"data"`

			// Event The machine event to poll for the async operation.
			Event *struct {
				// DtCreated The date the event was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtFinished The date the event was finished.
				DtFinished *time.Time `json:"dtFinished"`

				// DtStarted The date the event was started.
				DtStarted *time.Time `json:"dtStarted"`

				// Error The error message of the event, if any.
				Error *string `json:"error"`

				// Id The ID of the event.
				Id string `json:"id"`

				// MachineId The ID of the machine the event is for.
				MachineId *string `json:"machineId"`

				// Name The name of the event, e.g. "create".
				Name MachinesUpdate200EventName `json:"name"`

				// State The state of the event, e.g. "done".
				State MachinesUpdate200EventState `json:"state"`
			} `json:"event,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMachinesListAccessorsResponse parses an HTTP response from a MachinesListAccessorsWithResponse call
func ParseMachinesListAccessorsResponse(rsp *http.Response) (*MachinesListAccessorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesListAccessorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// DtDeleted The date the user was removed from the machine as an accessor.
				DtDeleted *time.Time `json:"dtDeleted"`

				// User The user that can access the machine
				User struct {
					// Email The email address of the user
					Email openapi_types.Email `json:"email"`

					// FirstName The first name of the user
					FirstName *string `json:"firstName"`

					// Id The ID of the user
					Id string `json:"id"`

					// LastName The last name of the user
					LastName *string `json:"lastName"`

					// PublicProfileImageUrl The URL of the team's profile image.
					PublicProfileImageUrl *string `json:"publicProfileImageUrl"`
				} `json:"user"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMachinesAddAccessorResponse parses an HTTP response from a MachinesAddAccessorWithResponse call
func ParseMachinesAddAccessorResponse(rsp *http.Response) (*MachinesAddAccessorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesAddAccessorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtDeleted The date the user was removed from the machine as an accessor.
			DtDeleted *time.Time `json:"dtDeleted"`

			// User The user that can access the machine
			User struct {
				// Email The email address of the user
				Email openapi_types.Email `json:"email"`

				// FirstName The first name of the user
				FirstName *string `json:"firstName"`

				// Id The ID of the user
				Id string `json:"id"`

				// LastName The last name of the user
				LastName *string `json:"lastName"`

				// PublicProfileImageUrl The URL of the team's profile image.
				PublicProfileImageUrl *string `json:"publicProfileImageUrl"`
			} `json:"user"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMachinesRemoveAccessorResponse parses an HTTP response from a MachinesRemoveAccessorWithResponse call
func ParseMachinesRemoveAccessorResponse(rsp *http.Response) (*MachinesRemoveAccessorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesRemoveAccessorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtDeleted The date the user was removed from the machine as an accessor.
			DtDeleted *time.Time `json:"dtDeleted"`

			// User The user that can access the machine
			User struct {
				// Email The email address of the user
				Email openapi_types.Email `json:"email"`

				// FirstName The first name of the user
				FirstName *string `json:"firstName"`

				// Id The ID of the user
				Id string `json:"id"`

				// LastName The last name of the user
				LastName *string `json:"lastName"`

				// PublicProfileImageUrl The URL of the team's profile image.
				PublicProfileImageUrl *string `json:"publicProfileImageUrl"`
			} `json:"user"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMachinesGetAccessorResponse parses an HTTP response from a MachinesGetAccessorWithResponse call
func ParseMachinesGetAccessorResponse(rsp *http.Response) (*MachinesGetAccessorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesGetAccessorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtDeleted The date the user was removed from the machine as an accessor.
			DtDeleted *time.Time `json:"dtDeleted"`

			// User The user that can access the machine
			User struct {
				// Email The email address of the user
				Email openapi_types.Email `json:"email"`

				// FirstName The first name of the user
				FirstName *string `json:"firstName"`

				// Id The ID of the user
				Id string `json:"id"`

				// LastName The last name of the user
				LastName *string `json:"lastName"`

				// PublicProfileImageUrl The URL of the team's profile image.
				PublicProfileImageUrl *string `json:"publicProfileImageUrl"`
			} `json:"user"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMachinesGetDesktopResponse parses an HTTP response from a MachinesGetDesktopWithResponse call
func ParseMachinesGetDesktopResponse(rsp *http.Response) (*MachinesGetDesktopResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesGetDesktopResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Vnc Settings for Linux desktop machines.
			Vnc *struct {
				// Hostname The VNC hostname.
				Hostname string `json:"hostname"`

				// Password The VNC password.
				Password string `json:"password"`

				// Port The port VNC is listening on.
				Port int `json:"port"`
			} `json:"vnc,omitempty"`

			// Windows Settings for Windows desktop machines.
			Windows *struct {
				// Hostname The Windows hostname.
				Hostname string `json:"hostname"`

				// Port The port Windows is listening on.
				Port int `json:"port"`

				// PublicIp The public IP of the machine.
				PublicIp *string `json:"publicIp,omitempty"`
			} `json:"windows,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMachinesRestartResponse parses an HTTP response from a MachinesRestartWithResponse call
func ParseMachinesRestartResponse(rsp *http.Response) (*MachinesRestartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesRestartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The machine.
			Data struct {
				// Accelerators The accelerators of the machine.
				Accelerators *[]struct {
					// Count The number of accelerators of this type.
					Count float32 `json:"count"`

					// Memory The amount of memory the accelerator has, if applicable.
					Memory *int `json:"memory"`

					// Name The name of the accelerator.
					Name string `json:"name"`
				} `json:"accelerators"`

				// AgentType The agent type of the machine.
				AgentType string `json:"agentType"`

				// AutoShutdownEnabled Whether auto shutdown is enabled.
				AutoShutdownEnabled bool `json:"autoShutdownEnabled"`

				// AutoShutdownForce Whether to force shutdown the machine.
				AutoShutdownForce *bool `json:"autoShutdownForce"`

				// AutoShutdownTimeout The shutdown timeout of the machine in hours.
				AutoShutdownTimeout *float32 `json:"autoShutdownTimeout"`

				// AutoSnapshotEnabled Whether auto snapshots are enabled.
				AutoSnapshotEnabled bool `json:"autoSnapshotEnabled"`

				// AutoSnapshotFrequency The frequency of auto snapshots.
				AutoSnapshotFrequency *MachinesRestart200DataAutoSnapshotFrequency `json:"autoSnapshotFrequency"`

				// AutoSnapshotSaveCount The number of auto snapshots to save.
				AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount"`

				// Cpus The number of CPUs.
				Cpus float32 `json:"cpus"`

				// DtCreated The date the machine was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtDeleted The date the machine was deleted.
				DtDeleted *time.Time `json:"dtDeleted"`

				// DtModified The date the machine was last modified.
				DtModified time.Time `json:"dtModified"`

				// Id The ID of the machine.
				Id string `json:"id"`

				// MachineType The type of the machine.
				MachineType string `json:"machineType"`

				// Name The name of the machine.
				Name string `json:"name"`

				// NetworkId The ID of the network the machine is on.
				NetworkId *string `json:"networkId"`

				// Os The operating system of the machine.
				Os string `json:"os"`

				// PrivateIp The private IP address of the machine.
				PrivateIp *string `json:"privateIp"`

				// PublicIp The public IP address of the machine.
				PublicIp *string `json:"publicIp"`

				// PublicIpType The public IP type.
				PublicIpType MachinesRestart200DataPublicIpType `json:"publicIpType"`

				// Ram The amount of RAM in bytes.
				Ram int64 `json:"ram"`

				// Region The region of the machine.
				Region      MachinesRestart_200_Data_Region `json:"region"`
				Reservation *struct {
					DtFinished time.Time          `json:"dtFinished"`
					DtStarted  time.Time          `json:"dtStarted"`
					Id         openapi_types.UUID `json:"id"`
					IsActive   bool               `json:"isActive"`
					Name       string             `json:"name"`
				} `json:"reservation"`

				// RestorePointEnabled Whether a restore point is enabled.
				RestorePointEnabled bool `json:"restorePointEnabled"`

				// RestorePointFrequency The frequency of restore points.
				RestorePointFrequency *MachinesRestart200DataRestorePointFrequency `json:"restorePointFrequency"`

				// RestorePointSnapshotId The ID of the snapshot to use as a restore point.
				RestorePointSnapshotId *string `json:"restorePointSnapshotId"`

				// State The state of the machine.
				State MachinesRestart200DataState `json:"state"`

				// StorageRate The storage rate of the machine.
				StorageRate float32 `json:"storageRate"`

				// StorageTotal The total amount of storage.
				StorageTotal int64 `json:"storageTotal"`

				// StorageUsed The amount of storage used.
				StorageUsed int64 `json:"storageUsed"`

				// UpdatesPending Whether updates are pending.
				UpdatesPending bool `json:"updatesPending"`

				// UsageRate The usage rate of the machine.
				UsageRate float32 `json:"usageRate"`
			} `json:"data"`

			// Event The machine event to poll for the async operation.
			Event struct {
				// DtCreated The date the event was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtFinished The date the event was finished.
				DtFinished *time.Time `json:"dtFinished"`

				// DtStarted The date the event was started.
				DtStarted *time.Time `json:"dtStarted"`

				// Error The error message of the event, if any.
				Error *string `json:"error"`

				// Id The ID of the event.
				Id string `json:"id"`

				// MachineId The ID of the machine the event is for.
				MachineId *string `json:"machineId"`

				// Name The name of the event, e.g. "create".
				Name MachinesRestart200EventName `json:"name"`

				// State The state of the event, e.g. "done".
				State MachinesRestart200EventState `json:"state"`
			} `json:"event"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMachinesStartResponse parses an HTTP response from a MachinesStartWithResponse call
func ParseMachinesStartResponse(rsp *http.Response) (*MachinesStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The machine.
			Data struct {
				// Accelerators The accelerators of the machine.
				Accelerators *[]struct {
					// Count The number of accelerators of this type.
					Count float32 `json:"count"`

					// Memory The amount of memory the accelerator has, if applicable.
					Memory *int `json:"memory"`

					// Name The name of the accelerator.
					Name string `json:"name"`
				} `json:"accelerators"`

				// AgentType The agent type of the machine.
				AgentType string `json:"agentType"`

				// AutoShutdownEnabled Whether auto shutdown is enabled.
				AutoShutdownEnabled bool `json:"autoShutdownEnabled"`

				// AutoShutdownForce Whether to force shutdown the machine.
				AutoShutdownForce *bool `json:"autoShutdownForce"`

				// AutoShutdownTimeout The shutdown timeout of the machine in hours.
				AutoShutdownTimeout *float32 `json:"autoShutdownTimeout"`

				// AutoSnapshotEnabled Whether auto snapshots are enabled.
				AutoSnapshotEnabled bool `json:"autoSnapshotEnabled"`

				// AutoSnapshotFrequency The frequency of auto snapshots.
				AutoSnapshotFrequency *MachinesStart200DataAutoSnapshotFrequency `json:"autoSnapshotFrequency"`

				// AutoSnapshotSaveCount The number of auto snapshots to save.
				AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount"`

				// Cpus The number of CPUs.
				Cpus float32 `json:"cpus"`

				// DtCreated The date the machine was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtDeleted The date the machine was deleted.
				DtDeleted *time.Time `json:"dtDeleted"`

				// DtModified The date the machine was last modified.
				DtModified time.Time `json:"dtModified"`

				// Id The ID of the machine.
				Id string `json:"id"`

				// MachineType The type of the machine.
				MachineType string `json:"machineType"`

				// Name The name of the machine.
				Name string `json:"name"`

				// NetworkId The ID of the network the machine is on.
				NetworkId *string `json:"networkId"`

				// Os The operating system of the machine.
				Os string `json:"os"`

				// PrivateIp The private IP address of the machine.
				PrivateIp *string `json:"privateIp"`

				// PublicIp The public IP address of the machine.
				PublicIp *string `json:"publicIp"`

				// PublicIpType The public IP type.
				PublicIpType MachinesStart200DataPublicIpType `json:"publicIpType"`

				// Ram The amount of RAM in bytes.
				Ram int64 `json:"ram"`

				// Region The region of the machine.
				Region      MachinesStart_200_Data_Region `json:"region"`
				Reservation *struct {
					DtFinished time.Time          `json:"dtFinished"`
					DtStarted  time.Time          `json:"dtStarted"`
					Id         openapi_types.UUID `json:"id"`
					IsActive   bool               `json:"isActive"`
					Name       string             `json:"name"`
				} `json:"reservation"`

				// RestorePointEnabled Whether a restore point is enabled.
				RestorePointEnabled bool `json:"restorePointEnabled"`

				// RestorePointFrequency The frequency of restore points.
				RestorePointFrequency *MachinesStart200DataRestorePointFrequency `json:"restorePointFrequency"`

				// RestorePointSnapshotId The ID of the snapshot to use as a restore point.
				RestorePointSnapshotId *string `json:"restorePointSnapshotId"`

				// State The state of the machine.
				State MachinesStart200DataState `json:"state"`

				// StorageRate The storage rate of the machine.
				StorageRate float32 `json:"storageRate"`

				// StorageTotal The total amount of storage.
				StorageTotal int64 `json:"storageTotal"`

				// StorageUsed The amount of storage used.
				StorageUsed int64 `json:"storageUsed"`

				// UpdatesPending Whether updates are pending.
				UpdatesPending bool `json:"updatesPending"`

				// UsageRate The usage rate of the machine.
				UsageRate float32 `json:"usageRate"`
			} `json:"data"`

			// Event The machine event to poll for the async operation.
			Event struct {
				// DtCreated The date the event was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtFinished The date the event was finished.
				DtFinished *time.Time `json:"dtFinished"`

				// DtStarted The date the event was started.
				DtStarted *time.Time `json:"dtStarted"`

				// Error The error message of the event, if any.
				Error *string `json:"error"`

				// Id The ID of the event.
				Id string `json:"id"`

				// MachineId The ID of the machine the event is for.
				MachineId *string `json:"machineId"`

				// Name The name of the event, e.g. "create".
				Name MachinesStart200EventName `json:"name"`

				// State The state of the event, e.g. "done".
				State MachinesStart200EventState `json:"state"`
			} `json:"event"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMachinesStopResponse parses an HTTP response from a MachinesStopWithResponse call
func ParseMachinesStopResponse(rsp *http.Response) (*MachinesStopResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesStopResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The machine.
			Data struct {
				// Accelerators The accelerators of the machine.
				Accelerators *[]struct {
					// Count The number of accelerators of this type.
					Count float32 `json:"count"`

					// Memory The amount of memory the accelerator has, if applicable.
					Memory *int `json:"memory"`

					// Name The name of the accelerator.
					Name string `json:"name"`
				} `json:"accelerators"`

				// AgentType The agent type of the machine.
				AgentType string `json:"agentType"`

				// AutoShutdownEnabled Whether auto shutdown is enabled.
				AutoShutdownEnabled bool `json:"autoShutdownEnabled"`

				// AutoShutdownForce Whether to force shutdown the machine.
				AutoShutdownForce *bool `json:"autoShutdownForce"`

				// AutoShutdownTimeout The shutdown timeout of the machine in hours.
				AutoShutdownTimeout *float32 `json:"autoShutdownTimeout"`

				// AutoSnapshotEnabled Whether auto snapshots are enabled.
				AutoSnapshotEnabled bool `json:"autoSnapshotEnabled"`

				// AutoSnapshotFrequency The frequency of auto snapshots.
				AutoSnapshotFrequency *MachinesStop200DataAutoSnapshotFrequency `json:"autoSnapshotFrequency"`

				// AutoSnapshotSaveCount The number of auto snapshots to save.
				AutoSnapshotSaveCount *float32 `json:"autoSnapshotSaveCount"`

				// Cpus The number of CPUs.
				Cpus float32 `json:"cpus"`

				// DtCreated The date the machine was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtDeleted The date the machine was deleted.
				DtDeleted *time.Time `json:"dtDeleted"`

				// DtModified The date the machine was last modified.
				DtModified time.Time `json:"dtModified"`

				// Id The ID of the machine.
				Id string `json:"id"`

				// MachineType The type of the machine.
				MachineType string `json:"machineType"`

				// Name The name of the machine.
				Name string `json:"name"`

				// NetworkId The ID of the network the machine is on.
				NetworkId *string `json:"networkId"`

				// Os The operating system of the machine.
				Os string `json:"os"`

				// PrivateIp The private IP address of the machine.
				PrivateIp *string `json:"privateIp"`

				// PublicIp The public IP address of the machine.
				PublicIp *string `json:"publicIp"`

				// PublicIpType The public IP type.
				PublicIpType MachinesStop200DataPublicIpType `json:"publicIpType"`

				// Ram The amount of RAM in bytes.
				Ram int64 `json:"ram"`

				// Region The region of the machine.
				Region      MachinesStop_200_Data_Region `json:"region"`
				Reservation *struct {
					DtFinished time.Time          `json:"dtFinished"`
					DtStarted  time.Time          `json:"dtStarted"`
					Id         openapi_types.UUID `json:"id"`
					IsActive   bool               `json:"isActive"`
					Name       string             `json:"name"`
				} `json:"reservation"`

				// RestorePointEnabled Whether a restore point is enabled.
				RestorePointEnabled bool `json:"restorePointEnabled"`

				// RestorePointFrequency The frequency of restore points.
				RestorePointFrequency *MachinesStop200DataRestorePointFrequency `json:"restorePointFrequency"`

				// RestorePointSnapshotId The ID of the snapshot to use as a restore point.
				RestorePointSnapshotId *string `json:"restorePointSnapshotId"`

				// State The state of the machine.
				State MachinesStop200DataState `json:"state"`

				// StorageRate The storage rate of the machine.
				StorageRate float32 `json:"storageRate"`

				// StorageTotal The total amount of storage.
				StorageTotal int64 `json:"storageTotal"`

				// StorageUsed The amount of storage used.
				StorageUsed int64 `json:"storageUsed"`

				// UpdatesPending Whether updates are pending.
				UpdatesPending bool `json:"updatesPending"`

				// UsageRate The usage rate of the machine.
				UsageRate float32 `json:"usageRate"`
			} `json:"data"`

			// Event The machine event to poll for the async operation.
			Event struct {
				// DtCreated The date the event was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtFinished The date the event was finished.
				DtFinished *time.Time `json:"dtFinished"`

				// DtStarted The date the event was started.
				DtStarted *time.Time `json:"dtStarted"`

				// Error The error message of the event, if any.
				Error *string `json:"error"`

				// Id The ID of the event.
				Id string `json:"id"`

				// MachineId The ID of the machine the event is for.
				MachineId *string `json:"machineId"`

				// Name The name of the event, e.g. "create".
				Name MachinesStop200EventName `json:"name"`

				// State The state of the event, e.g. "done".
				State MachinesStop200EventState `json:"state"`
			} `json:"event"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseModelsListResponse parses an HTTP response from a ModelsListWithResponse call
func ParseModelsListResponse(rsp *http.Response) (*ModelsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// Description The description of the dataset
				Description *string `json:"description"`

				// DtCreated The date the dataset was created
				DtCreated time.Time `json:"dtCreated"`

				// DtModified The date the dataset was last modified
				DtModified time.Time `json:"dtModified"`

				// Id The ID of the dataset
				Id string `json:"id"`

				// IsPublic Whether the dataset is public
				IsPublic bool `json:"isPublic"`

				// Name The name of the dataset
				Name string `json:"name"`

				// ProjectId The ID of the project
				ProjectId *string `json:"projectId"`

				// StorageProviderId The ID of the storage provider
				StorageProviderId *string `json:"storageProviderId"`

				// TeamId The ID of the team that owns the dataset
				TeamId string `json:"teamId"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseModelsCreateResponse parses an HTTP response from a ModelsCreateWithResponse call
func ParseModelsCreateResponse(rsp *http.Response) (*ModelsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Description The description of the dataset
			Description *string `json:"description"`

			// DtCreated The date the dataset was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the dataset was last modified
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the dataset
			Id string `json:"id"`

			// IsPublic Whether the dataset is public
			IsPublic bool `json:"isPublic"`

			// Name The name of the dataset
			Name string `json:"name"`

			// ProjectId The ID of the project
			ProjectId *string `json:"projectId"`

			// StorageProviderId The ID of the storage provider
			StorageProviderId *string `json:"storageProviderId"`

			// TeamId The ID of the team that owns the dataset
			TeamId string `json:"teamId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseModelsDeleteResponse parses an HTTP response from a ModelsDeleteWithResponse call
func ParseModelsDeleteResponse(rsp *http.Response) (*ModelsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The ID of the model
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseModelsGetResponse parses an HTTP response from a ModelsGetWithResponse call
func ParseModelsGetResponse(rsp *http.Response) (*ModelsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Description The description of the dataset
			Description *string `json:"description"`

			// DtCreated The date the dataset was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the dataset was last modified
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the dataset
			Id string `json:"id"`

			// IsPublic Whether the dataset is public
			IsPublic bool `json:"isPublic"`

			// Name The name of the dataset
			Name string `json:"name"`

			// ProjectId The ID of the project
			ProjectId *string `json:"projectId"`

			// StorageProviderId The ID of the storage provider
			StorageProviderId *string `json:"storageProviderId"`

			// TeamId The ID of the team that owns the dataset
			TeamId string `json:"teamId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOsTemplatesListResponse parses an HTTP response from a OsTemplatesListWithResponse call
func ParseOsTemplatesListResponse(rsp *http.Response) (*OsTemplatesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OsTemplatesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// AgentType The type of agent installed on the template.
				AgentType string `json:"agentType"`

				// AvailableMachineTypes The machine types the template is available on.
				AvailableMachineTypes []struct {
					// IsAvailable Whether the template is available on this machine type.
					IsAvailable bool `json:"isAvailable"`

					// MachineTypeLabel The label of the machine type.
					MachineTypeLabel string `json:"machineTypeLabel"`
				} `json:"availableMachineTypes"`

				// DefaultSizeGb The default size of the template in gigabytes.
				DefaultSizeGb *OsTemplatesList_200_Items_DefaultSizeGb `json:"defaultSizeGb"`

				// DtCreated The date the template was created.
				DtCreated time.Time `json:"dtCreated"`

				// Id The ID of the template.
				Id string `json:"id"`

				// Name The name of the template.
				Name string `json:"name"`

				// OperatingSystemLabel The operating system installed on the template.
				OperatingSystemLabel string `json:"operatingSystemLabel"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrivateNetworksListResponse parses an HTTP response from a PrivateNetworksListWithResponse call
func ParsePrivateNetworksListResponse(rsp *http.Response) (*PrivateNetworksListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrivateNetworksListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// DtCreated The date the private network was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtDeleted The date the private network was deleted.
				DtDeleted *PrivateNetworksList_200_Items_DtDeleted `json:"dtDeleted"`

				// Id The ID of the private network.
				Id string `json:"id"`

				// Name The name of the private network.
				Name string `json:"name"`

				// Netmask The subnet mask of the private network.
				Netmask string `json:"netmask"`

				// Network The network prefix of the private network.
				Network string `json:"network"`

				// Region The region the private network is in.
				Region PrivateNetworksList_200_Items_Region `json:"region"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrivateNetworksCreateResponse parses an HTTP response from a PrivateNetworksCreateWithResponse call
func ParsePrivateNetworksCreateResponse(rsp *http.Response) (*PrivateNetworksCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrivateNetworksCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the private network was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the private network was deleted.
			DtDeleted *PrivateNetworksCreate_200_DtDeleted `json:"dtDeleted"`

			// Id The ID of the private network.
			Id string `json:"id"`

			// Name The name of the private network.
			Name string `json:"name"`

			// Netmask The subnet mask of the private network.
			Netmask string `json:"netmask"`

			// Network The network prefix of the private network.
			Network string `json:"network"`

			// Region The region the private network is in.
			Region PrivateNetworksCreate_200_Region `json:"region"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrivateNetworksDeleteResponse parses an HTTP response from a PrivateNetworksDeleteWithResponse call
func ParsePrivateNetworksDeleteResponse(rsp *http.Response) (*PrivateNetworksDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrivateNetworksDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The ID of the private network to delete.
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrivateNetworksGetResponse parses an HTTP response from a PrivateNetworksGetWithResponse call
func ParsePrivateNetworksGetResponse(rsp *http.Response) (*PrivateNetworksGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrivateNetworksGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the private network was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the private network was deleted.
			DtDeleted *PrivateNetworksGet_200_DtDeleted `json:"dtDeleted"`

			// Id The ID of the private network.
			Id string `json:"id"`

			// Name The name of the private network.
			Name string `json:"name"`

			// Netmask The subnet mask of the private network.
			Netmask string `json:"netmask"`

			// Network The network prefix of the private network.
			Network string `json:"network"`

			// Region The region the private network is in.
			Region PrivateNetworksGet_200_Region `json:"region"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrivateNetworksUpdateResponse parses an HTTP response from a PrivateNetworksUpdateWithResponse call
func ParsePrivateNetworksUpdateResponse(rsp *http.Response) (*PrivateNetworksUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrivateNetworksUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the private network was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the private network was deleted.
			DtDeleted *PrivateNetworksUpdate_200_DtDeleted `json:"dtDeleted"`

			// Id The ID of the private network.
			Id string `json:"id"`

			// Name The name of the private network.
			Name string `json:"name"`

			// Netmask The subnet mask of the private network.
			Netmask string `json:"netmask"`

			// Network The network prefix of the private network.
			Network string `json:"network"`

			// Region The region the private network is in.
			Region PrivateNetworksUpdate_200_Region `json:"region"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectsListResponse parses an HTTP response from a ProjectsListWithResponse call
func ParseProjectsListResponse(rsp *http.Response) (*ProjectsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// DtCreated The date the project was created
				DtCreated time.Time `json:"dtCreated"`

				// DtDeleted The date the project was deleted
				DtDeleted *time.Time `json:"dtDeleted"`

				// Id The ID of the project
				Id string `json:"id"`

				// Name The name of the project
				Name string `json:"name"`

				// RepoName The name of the GitHub repository if this is is a GitHub-connected project.
				RepoName *string `json:"repoName"`

				// RepoNodeId The node ID of the GitHub repository if this is is a GitHub-connected project.
				RepoNodeId *string `json:"repoNodeId"`

				// RepoUrl The URL of the GitHub repository if this is is a GitHub-connected project.
				RepoUrl *string `json:"repoUrl"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectsCreateResponse parses an HTTP response from a ProjectsCreateWithResponse call
func ParseProjectsCreateResponse(rsp *http.Response) (*ProjectsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the project was created
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the project was deleted
			DtDeleted *time.Time `json:"dtDeleted"`

			// Id The ID of the project
			Id string `json:"id"`

			// Name The name of the project
			Name string `json:"name"`

			// RepoName The name of the GitHub repository if this is is a GitHub-connected project.
			RepoName *string `json:"repoName"`

			// RepoNodeId The node ID of the GitHub repository if this is is a GitHub-connected project.
			RepoNodeId *string `json:"repoNodeId"`

			// RepoUrl The URL of the GitHub repository if this is is a GitHub-connected project.
			RepoUrl *string `json:"repoUrl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectsDeleteResponse parses an HTTP response from a ProjectsDeleteWithResponse call
func ParseProjectsDeleteResponse(rsp *http.Response) (*ProjectsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the project was created
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the project was deleted
			DtDeleted *time.Time `json:"dtDeleted"`

			// Id The ID of the project
			Id string `json:"id"`

			// Name The name of the project
			Name string `json:"name"`

			// RepoName The name of the GitHub repository if this is is a GitHub-connected project.
			RepoName *string `json:"repoName"`

			// RepoNodeId The node ID of the GitHub repository if this is is a GitHub-connected project.
			RepoNodeId *string `json:"repoNodeId"`

			// RepoUrl The URL of the GitHub repository if this is is a GitHub-connected project.
			RepoUrl *string `json:"repoUrl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectsGetResponse parses an HTTP response from a ProjectsGetWithResponse call
func ParseProjectsGetResponse(rsp *http.Response) (*ProjectsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the project was created
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the project was deleted
			DtDeleted *time.Time `json:"dtDeleted"`

			// Id The ID of the project
			Id string `json:"id"`

			// Name The name of the project
			Name string `json:"name"`

			// RepoName The name of the GitHub repository if this is is a GitHub-connected project.
			RepoName *string `json:"repoName"`

			// RepoNodeId The node ID of the GitHub repository if this is is a GitHub-connected project.
			RepoNodeId *string `json:"repoNodeId"`

			// RepoUrl The URL of the GitHub repository if this is is a GitHub-connected project.
			RepoUrl *string `json:"repoUrl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectsUpdateResponse parses an HTTP response from a ProjectsUpdateWithResponse call
func ParseProjectsUpdateResponse(rsp *http.Response) (*ProjectsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the project was created
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the project was deleted
			DtDeleted *time.Time `json:"dtDeleted"`

			// Id The ID of the project
			Id string `json:"id"`

			// Name The name of the project
			Name string `json:"name"`

			// RepoName The name of the GitHub repository if this is is a GitHub-connected project.
			RepoName *string `json:"repoName"`

			// RepoNodeId The node ID of the GitHub repository if this is is a GitHub-connected project.
			RepoNodeId *string `json:"repoNodeId"`

			// RepoUrl The URL of the GitHub repository if this is is a GitHub-connected project.
			RepoUrl *string `json:"repoUrl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectActivityListResponse parses an HTTP response from a ProjectActivityListWithResponse call
func ParseProjectActivityListResponse(rsp *http.Response) (*ProjectActivityListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectActivityListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// Action The action that was performed
				Action ProjectActivityList_200_Items_Action `json:"action"`

				// Actor The actor that performed the action. Either a use or system.
				Actor *struct {
					// AvatarUrl The avatar URL of the actor
					AvatarUrl *string `json:"avatarUrl"`

					// Email The email of the actor
					Email *string `json:"email"`

					// FullName The full name of the actor (e.g. "John Doe")
					FullName *string `json:"fullName"`
				} `json:"actor"`

				// Data The data associated with the activity item
				Data *struct {
					From float32 `json:"from"`
					To   float32 `json:"to"`
				} `json:"data"`

				// Deployment The deployment associated with the activity item
				Deployment *struct {
					// DtDeleted The date the deployment was deleted
					DtDeleted *time.Time `json:"dtDeleted"`

					// Id The ID of the deployment
					Id string `json:"id"`

					// Name The name of the deployment
					Name string `json:"name"`
				} `json:"deployment"`

				// DtCreated The date the activity item was created
				DtCreated time.Time `json:"dtCreated"`

				// Id ID of the activity item
				Id openapi_types.UUID `json:"id"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectCollaboratorsListResponse parses an HTTP response from a ProjectCollaboratorsListWithResponse call
func ParseProjectCollaboratorsListResponse(rsp *http.Response) (*ProjectCollaboratorsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectCollaboratorsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// DtCreated The date the collaborate was added to the project
				DtCreated time.Time `json:"dtCreated"`

				// DtDeleted The date the collaborator was removed from the project
				DtDeleted *time.Time `json:"dtDeleted"`

				// User The user that can access the project
				User struct {
					// Email The email address of the user
					Email openapi_types.Email `json:"email"`

					// FirstName The first name of the user
					FirstName *string `json:"firstName"`

					// Id The ID of the user
					Id string `json:"id"`

					// LastName The last name of the user
					LastName *string `json:"lastName"`

					// PublicProfileImageUrl The URL of the team's profile image.
					PublicProfileImageUrl *string `json:"publicProfileImageUrl"`
				} `json:"user"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectCollaboratorsCreateResponse parses an HTTP response from a ProjectCollaboratorsCreateWithResponse call
func ParseProjectCollaboratorsCreateResponse(rsp *http.Response) (*ProjectCollaboratorsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectCollaboratorsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the collaborate was added to the project
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the collaborator was removed from the project
			DtDeleted *time.Time `json:"dtDeleted"`

			// User The user that can access the project
			User struct {
				// Email The email address of the user
				Email openapi_types.Email `json:"email"`

				// FirstName The first name of the user
				FirstName *string `json:"firstName"`

				// Id The ID of the user
				Id string `json:"id"`

				// LastName The last name of the user
				LastName *string `json:"lastName"`

				// PublicProfileImageUrl The URL of the team's profile image.
				PublicProfileImageUrl *string `json:"publicProfileImageUrl"`
			} `json:"user"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectCollaboratorsDeleteResponse parses an HTTP response from a ProjectCollaboratorsDeleteWithResponse call
func ParseProjectCollaboratorsDeleteResponse(rsp *http.Response) (*ProjectCollaboratorsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectCollaboratorsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// UserId The ID of the user removed from the project.
			UserId string `json:"userId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectDeploymentsListResponse parses an HTTP response from a ProjectDeploymentsListWithResponse call
func ParseProjectDeploymentsListResponse(rsp *http.Response) (*ProjectDeploymentsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectDeploymentsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// BasicAuthKey The endpoint security key for the deployment
				BasicAuthKey *string `json:"basicAuthKey"`

				// DtCreated The date the deployment was created
				DtCreated time.Time `json:"dtCreated"`

				// Endpoint The unique endpoint for the deployment
				Endpoint string `json:"endpoint"`

				// Id The ID of the deployment
				Id string `json:"id"`

				// LatestSpec The latest deployment configuration. If invalid, null is returned.
				LatestSpec *struct {
					// Data The data for the deployment spec
					Data *ProjectDeploymentsList_200_Items_LatestSpec_Data `json:"data"`

					// DeploymentId The ID of the deployment the spec belongs to
					DeploymentId string `json:"deploymentId"`

					// DtHealthy The date the deployment was marked "healthy"
					DtHealthy *time.Time `json:"dtHealthy"`

					// Error The fatal configuration error. Only present if the cluster was unable to apply the entire deployment configuration. This is not the same as an instance error.
					Error *string `json:"error"`

					// ExternalApplied The date the deployment configuration was applied to the cluster
					ExternalApplied *time.Time `json:"externalApplied"`

					// Id The ID of the deployment spec
					Id string `json:"id"`

					// Metadata Metadata about the source of the configuration
					Metadata *struct {
						GitHeaders *struct {
							XGitActor string                                                                   `json:"x-git-actor"`
							XGitHost  ProjectDeploymentsList_200_Items_LatestSpec_Metadata_GitHeaders_XGitHost `json:"x-git-host"`
							XGitOwner string                                                                   `json:"x-git-owner"`
							XGitRef   string                                                                   `json:"x-git-ref"`
							XGitRepo  string                                                                   `json:"x-git-repo"`
							XGitSha   string                                                                   `json:"x-git-sha"`
						} `json:"gitHeaders,omitempty"`
					} `json:"metadata"`

					// UserId The ID of the user the deployment belongs to
					UserId string `json:"userId"`
				} `json:"latestSpec"`

				// LatestSpecHash The last version hash for the deployment
				LatestSpecHash *string `json:"latestSpecHash"`

				// Name The name of the deployment
				Name string `json:"name"`

				// ProjectId The ID of the project the deployment belongs to
				ProjectId string `json:"projectId"`

				// TeamId The ID of the team the deployment belongs to
				TeamId string `json:"teamId"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectModelsListResponse parses an HTTP response from a ProjectModelsListWithResponse call
func ParseProjectModelsListResponse(rsp *http.Response) (*ProjectModelsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectModelsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// Description The description of the dataset
				Description *string `json:"description"`

				// DtCreated The date the dataset was created
				DtCreated time.Time `json:"dtCreated"`

				// DtModified The date the dataset was last modified
				DtModified time.Time `json:"dtModified"`

				// Id The ID of the dataset
				Id string `json:"id"`

				// IsPublic Whether the dataset is public
				IsPublic bool `json:"isPublic"`

				// Name The name of the dataset
				Name string `json:"name"`

				// ProjectId The ID of the project
				ProjectId *string `json:"projectId"`

				// StorageProviderId The ID of the storage provider
				StorageProviderId *string `json:"storageProviderId"`

				// TeamId The ID of the team that owns the dataset
				TeamId string `json:"teamId"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectModelsRemoveResponse parses an HTTP response from a ProjectModelsRemoveWithResponse call
func ParseProjectModelsRemoveResponse(rsp *http.Response) (*ProjectModelsRemoveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectModelsRemoveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Description The description of the dataset
			Description *string `json:"description"`

			// DtCreated The date the dataset was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the dataset was last modified
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the dataset
			Id string `json:"id"`

			// IsPublic Whether the dataset is public
			IsPublic bool `json:"isPublic"`

			// Name The name of the dataset
			Name string `json:"name"`

			// ProjectId The ID of the project
			ProjectId *string `json:"projectId"`

			// StorageProviderId The ID of the storage provider
			StorageProviderId *string `json:"storageProviderId"`

			// TeamId The ID of the team that owns the dataset
			TeamId string `json:"teamId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectModelsAddResponse parses an HTTP response from a ProjectModelsAddWithResponse call
func ParseProjectModelsAddResponse(rsp *http.Response) (*ProjectModelsAddResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectModelsAddResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Description The description of the dataset
			Description *string `json:"description"`

			// DtCreated The date the dataset was created
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the dataset was last modified
			DtModified time.Time `json:"dtModified"`

			// Id The ID of the dataset
			Id string `json:"id"`

			// IsPublic Whether the dataset is public
			IsPublic bool `json:"isPublic"`

			// Name The name of the dataset
			Name string `json:"name"`

			// ProjectId The ID of the project
			ProjectId *string `json:"projectId"`

			// StorageProviderId The ID of the storage provider
			StorageProviderId *string `json:"storageProviderId"`

			// TeamId The ID of the team that owns the dataset
			TeamId string `json:"teamId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectSecretsListResponse parses an HTTP response from a ProjectSecretsListWithResponse call
func ParseProjectSecretsListResponse(rsp *http.Response) (*ProjectSecretsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectSecretsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// DtCreated The date the secret was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtModified The date the secret was last modified.
				DtModified            time.Time `json:"dtModified"`
				HasDeploymentAttached bool      `json:"hasDeploymentAttached"`

				// Name The name of the secret, e.g. "DB_PASSWORD".
				Name string `json:"name"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectSecretsCreateResponse parses an HTTP response from a ProjectSecretsCreateWithResponse call
func ParseProjectSecretsCreateResponse(rsp *http.Response) (*ProjectSecretsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectSecretsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the secret was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the secret was last modified.
			DtModified time.Time `json:"dtModified"`

			// Name The name of the secret, e.g. "DB_PASSWORD".
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectSecretsDeleteResponse parses an HTTP response from a ProjectSecretsDeleteWithResponse call
func ParseProjectSecretsDeleteResponse(rsp *http.Response) (*ProjectSecretsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectSecretsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Name The name of the secret, e.g. "DB_PASSWORD".
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectSecretsGetProjectSecretResponse parses an HTTP response from a ProjectSecretsGetProjectSecretWithResponse call
func ParseProjectSecretsGetProjectSecretResponse(rsp *http.Response) (*ProjectSecretsGetProjectSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectSecretsGetProjectSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the secret was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the secret was last modified.
			DtModified            time.Time `json:"dtModified"`
			HasDeploymentAttached bool      `json:"hasDeploymentAttached"`

			// Name The name of the secret, e.g. "DB_PASSWORD".
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectSecretsUpdateResponse parses an HTTP response from a ProjectSecretsUpdateWithResponse call
func ParseProjectSecretsUpdateResponse(rsp *http.Response) (*ProjectSecretsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectSecretsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the secret was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the secret was last modified.
			DtModified time.Time `json:"dtModified"`

			// Name The name of the secret, e.g. "DB_PASSWORD".
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectTagsRemoveResponse parses an HTTP response from a ProjectTagsRemoveWithResponse call
func ParseProjectTagsRemoveResponse(rsp *http.Response) (*ProjectTagsRemoveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectTagsRemoveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the notebook was created
			DtCreated time.Time `json:"dtCreated"`

			// Id The ID of the tag
			Id float32 `json:"id"`

			// Name The name of the tag
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectTagsListResponse parses an HTTP response from a ProjectTagsListWithResponse call
func ParseProjectTagsListResponse(rsp *http.Response) (*ProjectTagsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectTagsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// DtCreated The date the notebook was created
				DtCreated time.Time `json:"dtCreated"`

				// Id The ID of the tag
				Id float32 `json:"id"`

				// Name The name of the tag
				Name string `json:"name"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectTagsAddResponse parses an HTTP response from a ProjectTagsAddWithResponse call
func ParseProjectTagsAddResponse(rsp *http.Response) (*ProjectTagsAddResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectTagsAddResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the notebook was created
			DtCreated time.Time `json:"dtCreated"`

			// Id The ID of the tag
			Id float32 `json:"id"`

			// Name The name of the tag
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePublicIpsListResponse parses an HTTP response from a PublicIpsListWithResponse call
func ParsePublicIpsListResponse(rsp *http.Response) (*PublicIpsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublicIpsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// AssignedMachineId The ID of the machine the public IP is assigned to.
				AssignedMachineId *string `json:"assignedMachineId,omitempty"`

				// DtCreated The date the public IP was claimed.
				DtCreated time.Time `json:"dtCreated"`

				// Ip The IP address of the public IP.
				Ip string `json:"ip"`

				// Region The region of the public IP.
				Region PublicIpsList_200_Items_Region `json:"region"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePublicIpsClaimResponse parses an HTTP response from a PublicIpsClaimWithResponse call
func ParsePublicIpsClaimResponse(rsp *http.Response) (*PublicIpsClaimResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublicIpsClaimResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AssignedMachineId The ID of the machine the public IP is assigned to.
			AssignedMachineId *string `json:"assignedMachineId,omitempty"`

			// DtCreated The date the public IP was claimed.
			DtCreated time.Time `json:"dtCreated"`

			// Ip The IP address of the public IP.
			Ip string `json:"ip"`

			// Region The region of the public IP.
			Region PublicIpsClaim_200_Region `json:"region"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePublicIpsReleaseResponse parses an HTTP response from a PublicIpsReleaseWithResponse call
func ParsePublicIpsReleaseResponse(rsp *http.Response) (*PublicIpsReleaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublicIpsReleaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ip string `json:"ip"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePublicIpsAssignResponse parses an HTTP response from a PublicIpsAssignWithResponse call
func ParsePublicIpsAssignResponse(rsp *http.Response) (*PublicIpsAssignResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublicIpsAssignResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AssignedMachineId The ID of the machine the public IP is assigned to.
			AssignedMachineId *string `json:"assignedMachineId,omitempty"`

			// DtCreated The date the public IP was claimed.
			DtCreated time.Time `json:"dtCreated"`

			// Ip The IP address of the public IP.
			Ip string `json:"ip"`

			// Region The region of the public IP.
			Region PublicIpsAssign_200_Region `json:"region"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSharedDrivesListResponse parses an HTTP response from a SharedDrivesListWithResponse call
func ParseSharedDrivesListResponse(rsp *http.Response) (*SharedDrivesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SharedDrivesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// DtCreated The date the shared drive was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtDeleted The date the shared drive was deleted.
				DtDeleted *SharedDrivesList_200_Items_DtDeleted `json:"dtDeleted"`

				// Id The ID of the shared drive.
				Id string `json:"id"`

				// MountPoint The mount point of the shared drive.
				MountPoint string `json:"mountPoint"`

				// Name The name of the shared drive.
				Name string `json:"name"`

				// NetworkId The ID of the network the shared drive is in.
				NetworkId string `json:"networkId"`

				// Password The password of the shared drive.
				Password string `json:"password"`

				// Region The region the shared drive is in.
				Region SharedDrivesList_200_Items_Region `json:"region"`

				// Size The size of the shared drive.
				Size int64 `json:"size"`

				// Username The username of the shared drive.
				Username string `json:"username"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSharedDrivesCreateResponse parses an HTTP response from a SharedDrivesCreateWithResponse call
func ParseSharedDrivesCreateResponse(rsp *http.Response) (*SharedDrivesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SharedDrivesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the shared drive was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the shared drive was deleted.
			DtDeleted *SharedDrivesCreate_200_DtDeleted `json:"dtDeleted"`

			// Id The ID of the shared drive.
			Id string `json:"id"`

			// MountPoint The mount point of the shared drive.
			MountPoint string `json:"mountPoint"`

			// Name The name of the shared drive.
			Name string `json:"name"`

			// NetworkId The ID of the network the shared drive is in.
			NetworkId string `json:"networkId"`

			// Password The password of the shared drive.
			Password string `json:"password"`

			// Region The region the shared drive is in.
			Region SharedDrivesCreate_200_Region `json:"region"`

			// Size The size of the shared drive.
			Size int64 `json:"size"`

			// Username The username of the shared drive.
			Username string `json:"username"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSharedDrivesDeleteResponse parses an HTTP response from a SharedDrivesDeleteWithResponse call
func ParseSharedDrivesDeleteResponse(rsp *http.Response) (*SharedDrivesDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SharedDrivesDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The ID of the deleted shared drive.
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSharedDrivesGetResponse parses an HTTP response from a SharedDrivesGetWithResponse call
func ParseSharedDrivesGetResponse(rsp *http.Response) (*SharedDrivesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SharedDrivesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the shared drive was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the shared drive was deleted.
			DtDeleted *SharedDrivesGet_200_DtDeleted `json:"dtDeleted"`

			// Id The ID of the shared drive.
			Id string `json:"id"`

			// MountPoint The mount point of the shared drive.
			MountPoint string `json:"mountPoint"`

			// Name The name of the shared drive.
			Name string `json:"name"`

			// NetworkId The ID of the network the shared drive is in.
			NetworkId string `json:"networkId"`

			// Password The password of the shared drive.
			Password string `json:"password"`

			// Region The region the shared drive is in.
			Region SharedDrivesGet_200_Region `json:"region"`

			// Size The size of the shared drive.
			Size int64 `json:"size"`

			// Username The username of the shared drive.
			Username string `json:"username"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSharedDrivesUpdateResponse parses an HTTP response from a SharedDrivesUpdateWithResponse call
func ParseSharedDrivesUpdateResponse(rsp *http.Response) (*SharedDrivesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SharedDrivesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the shared drive was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the shared drive was deleted.
			DtDeleted *SharedDrivesUpdate_200_DtDeleted `json:"dtDeleted"`

			// Id The ID of the shared drive.
			Id string `json:"id"`

			// MountPoint The mount point of the shared drive.
			MountPoint string `json:"mountPoint"`

			// Name The name of the shared drive.
			Name string `json:"name"`

			// NetworkId The ID of the network the shared drive is in.
			NetworkId string `json:"networkId"`

			// Password The password of the shared drive.
			Password string `json:"password"`

			// Region The region the shared drive is in.
			Region SharedDrivesUpdate_200_Region `json:"region"`

			// Size The size of the shared drive.
			Size int64 `json:"size"`

			// Username The username of the shared drive.
			Username string `json:"username"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSnapshotsListResponse parses an HTTP response from a SnapshotsListWithResponse call
func ParseSnapshotsListResponse(rsp *http.Response) (*SnapshotsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnapshotsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// Id The ID of the snapshot.
				Id string `json:"id"`

				// IsAutoSnapshot Whether the snapshot was made automatically.
				IsAutoSnapshot bool `json:"isAutoSnapshot"`

				// MachineId The ID of the machine the snapshot is for.
				MachineId string `json:"machineId"`

				// Name The name of the snapshot.
				Name string `json:"name"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSnapshotsCreateResponse parses an HTTP response from a SnapshotsCreateWithResponse call
func ParseSnapshotsCreateResponse(rsp *http.Response) (*SnapshotsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnapshotsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The snapshot.
			Data struct {
				// Id The ID of the snapshot.
				Id string `json:"id"`

				// IsAutoSnapshot Whether the snapshot was made automatically.
				IsAutoSnapshot bool `json:"isAutoSnapshot"`

				// MachineId The ID of the machine the snapshot is for.
				MachineId string `json:"machineId"`

				// Name The name of the snapshot.
				Name string `json:"name"`
			} `json:"data"`

			// Event The machine event to poll for the async operation.
			Event struct {
				// DtCreated The date the event was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtFinished The date the event was finished.
				DtFinished *time.Time `json:"dtFinished"`

				// DtStarted The date the event was started.
				DtStarted *time.Time `json:"dtStarted"`

				// Error The error message of the event, if any.
				Error *string `json:"error"`

				// Id The ID of the event.
				Id string `json:"id"`

				// MachineId The ID of the machine the event is for.
				MachineId *string `json:"machineId"`

				// Name The name of the event, e.g. "create".
				Name SnapshotsCreate200EventName `json:"name"`

				// State The state of the event, e.g. "done".
				State SnapshotsCreate200EventState `json:"state"`
			} `json:"event"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSnapshotsDeleteResponse parses an HTTP response from a SnapshotsDeleteWithResponse call
func ParseSnapshotsDeleteResponse(rsp *http.Response) (*SnapshotsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnapshotsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The snapshot.
			Data struct {
				// Id The ID of the snapshot.
				Id string `json:"id"`

				// IsAutoSnapshot Whether the snapshot was made automatically.
				IsAutoSnapshot bool `json:"isAutoSnapshot"`

				// MachineId The ID of the machine the snapshot is for.
				MachineId string `json:"machineId"`

				// Name The name of the snapshot.
				Name string `json:"name"`
			} `json:"data"`

			// Event The machine event to poll for the async operation.
			Event struct {
				// DtCreated The date the event was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtFinished The date the event was finished.
				DtFinished *time.Time `json:"dtFinished"`

				// DtStarted The date the event was started.
				DtStarted *time.Time `json:"dtStarted"`

				// Error The error message of the event, if any.
				Error *string `json:"error"`

				// Id The ID of the event.
				Id string `json:"id"`

				// MachineId The ID of the machine the event is for.
				MachineId *string `json:"machineId"`

				// Name The name of the event, e.g. "create".
				Name SnapshotsDelete200EventName `json:"name"`

				// State The state of the event, e.g. "done".
				State SnapshotsDelete200EventState `json:"state"`
			} `json:"event"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSnapshotsGetResponse parses an HTTP response from a SnapshotsGetWithResponse call
func ParseSnapshotsGetResponse(rsp *http.Response) (*SnapshotsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnapshotsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The ID of the snapshot.
			Id string `json:"id"`

			// IsAutoSnapshot Whether the snapshot was made automatically.
			IsAutoSnapshot bool `json:"isAutoSnapshot"`

			// MachineId The ID of the machine the snapshot is for.
			MachineId string `json:"machineId"`

			// Name The name of the snapshot.
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSnapshotsUpdateResponse parses an HTTP response from a SnapshotsUpdateWithResponse call
func ParseSnapshotsUpdateResponse(rsp *http.Response) (*SnapshotsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnapshotsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The ID of the snapshot.
			Id string `json:"id"`

			// IsAutoSnapshot Whether the snapshot was made automatically.
			IsAutoSnapshot bool `json:"isAutoSnapshot"`

			// MachineId The ID of the machine the snapshot is for.
			MachineId string `json:"machineId"`

			// Name The name of the snapshot.
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSnapshotsRestoreResponse parses an HTTP response from a SnapshotsRestoreWithResponse call
func ParseSnapshotsRestoreResponse(rsp *http.Response) (*SnapshotsRestoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnapshotsRestoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The snapshot.
			Data struct {
				// Id The ID of the snapshot.
				Id string `json:"id"`

				// IsAutoSnapshot Whether the snapshot was made automatically.
				IsAutoSnapshot bool `json:"isAutoSnapshot"`

				// MachineId The ID of the machine the snapshot is for.
				MachineId string `json:"machineId"`

				// Name The name of the snapshot.
				Name string `json:"name"`
			} `json:"data"`

			// Event The machine event to poll for the async operation.
			Event struct {
				// DtCreated The date the event was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtFinished The date the event was finished.
				DtFinished *time.Time `json:"dtFinished"`

				// DtStarted The date the event was started.
				DtStarted *time.Time `json:"dtStarted"`

				// Error The error message of the event, if any.
				Error *string `json:"error"`

				// Id The ID of the event.
				Id string `json:"id"`

				// MachineId The ID of the machine the event is for.
				MachineId *string `json:"machineId"`

				// Name The name of the event, e.g. "create".
				Name SnapshotsRestore200EventName `json:"name"`

				// State The state of the event, e.g. "done".
				State SnapshotsRestore200EventState `json:"state"`
			} `json:"event"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStartupScriptsListResponse parses an HTTP response from a StartupScriptsListWithResponse call
func ParseStartupScriptsListResponse(rsp *http.Response) (*StartupScriptsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartupScriptsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// AssignedMachineIds The IDs of the machines the startup script is assigned to.
				AssignedMachineIds []string `json:"assignedMachineIds"`

				// Description The description of the startup script.
				Description *string `json:"description"`

				// DtCreated The date the startup script was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtDeleted The date the startup script was deleted.
				DtDeleted *time.Time `json:"dtDeleted"`

				// Id The ID of the startup script.
				Id string `json:"id"`

				// IsEnabled Whether the startup script is enabled.
				IsEnabled bool `json:"isEnabled"`

				// IsRunOnce Whether the startup script is run once on first boot or on every boot.
				IsRunOnce bool `json:"isRunOnce"`

				// Name The name of the startup script.
				Name string `json:"name"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStartupScriptsCreateResponse parses an HTTP response from a StartupScriptsCreateWithResponse call
func ParseStartupScriptsCreateResponse(rsp *http.Response) (*StartupScriptsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartupScriptsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AssignedMachineIds The IDs of the machines the startup script is assigned to.
			AssignedMachineIds []string `json:"assignedMachineIds"`

			// Description The description of the startup script.
			Description *string `json:"description"`

			// DtCreated The date the startup script was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the startup script was deleted.
			DtDeleted *time.Time `json:"dtDeleted"`

			// Id The ID of the startup script.
			Id string `json:"id"`

			// IsEnabled Whether the startup script is enabled.
			IsEnabled bool `json:"isEnabled"`

			// IsRunOnce Whether the startup script is run once on first boot or on every boot.
			IsRunOnce bool `json:"isRunOnce"`

			// Name The name of the startup script.
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStartupScriptsDeleteResponse parses an HTTP response from a StartupScriptsDeleteWithResponse call
func ParseStartupScriptsDeleteResponse(rsp *http.Response) (*StartupScriptsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartupScriptsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AssignedMachineIds The IDs of the machines the startup script is assigned to.
			AssignedMachineIds []string `json:"assignedMachineIds"`

			// Description The description of the startup script.
			Description *string `json:"description"`

			// DtCreated The date the startup script was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the startup script was deleted.
			DtDeleted *time.Time `json:"dtDeleted"`

			// Id The ID of the startup script.
			Id string `json:"id"`

			// IsEnabled Whether the startup script is enabled.
			IsEnabled bool `json:"isEnabled"`

			// IsRunOnce Whether the startup script is run once on first boot or on every boot.
			IsRunOnce bool `json:"isRunOnce"`

			// Name The name of the startup script.
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStartupScriptsGetResponse parses an HTTP response from a StartupScriptsGetWithResponse call
func ParseStartupScriptsGetResponse(rsp *http.Response) (*StartupScriptsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartupScriptsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AssignedMachineIds The IDs of the machines the startup script is assigned to.
			AssignedMachineIds []string `json:"assignedMachineIds"`

			// Description The description of the startup script.
			Description *string `json:"description"`

			// DtCreated The date the startup script was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the startup script was deleted.
			DtDeleted *time.Time `json:"dtDeleted"`

			// Id The ID of the startup script.
			Id string `json:"id"`

			// IsEnabled Whether the startup script is enabled.
			IsEnabled bool `json:"isEnabled"`

			// IsRunOnce Whether the startup script is run once on first boot or on every boot.
			IsRunOnce bool `json:"isRunOnce"`

			// Name The name of the startup script.
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStartupScriptsUpdateResponse parses an HTTP response from a StartupScriptsUpdateWithResponse call
func ParseStartupScriptsUpdateResponse(rsp *http.Response) (*StartupScriptsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartupScriptsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AssignedMachineIds The IDs of the machines the startup script is assigned to.
			AssignedMachineIds []string `json:"assignedMachineIds"`

			// Description The description of the startup script.
			Description *string `json:"description"`

			// DtCreated The date the startup script was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the startup script was deleted.
			DtDeleted *time.Time `json:"dtDeleted"`

			// Id The ID of the startup script.
			Id string `json:"id"`

			// IsEnabled Whether the startup script is enabled.
			IsEnabled bool `json:"isEnabled"`

			// IsRunOnce Whether the startup script is run once on first boot or on every boot.
			IsRunOnce bool `json:"isRunOnce"`

			// Name The name of the startup script.
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStartupScriptsAssignResponse parses an HTTP response from a StartupScriptsAssignWithResponse call
func ParseStartupScriptsAssignResponse(rsp *http.Response) (*StartupScriptsAssignResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartupScriptsAssignResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AssignedMachineIds The IDs of the machines the startup script is assigned to.
			AssignedMachineIds []string `json:"assignedMachineIds"`

			// Description The description of the startup script.
			Description *string `json:"description"`

			// DtCreated The date the startup script was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the startup script was deleted.
			DtDeleted *time.Time `json:"dtDeleted"`

			// Id The ID of the startup script.
			Id string `json:"id"`

			// IsEnabled Whether the startup script is enabled.
			IsEnabled bool `json:"isEnabled"`

			// IsRunOnce Whether the startup script is run once on first boot or on every boot.
			IsRunOnce bool `json:"isRunOnce"`

			// Name The name of the startup script.
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStartupScriptsUnassignResponse parses an HTTP response from a StartupScriptsUnassignWithResponse call
func ParseStartupScriptsUnassignResponse(rsp *http.Response) (*StartupScriptsUnassignResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartupScriptsUnassignResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AssignedMachineIds The IDs of the machines the startup script is assigned to.
			AssignedMachineIds []string `json:"assignedMachineIds"`

			// Description The description of the startup script.
			Description *string `json:"description"`

			// DtCreated The date the startup script was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtDeleted The date the startup script was deleted.
			DtDeleted *time.Time `json:"dtDeleted"`

			// Id The ID of the startup script.
			Id string `json:"id"`

			// IsEnabled Whether the startup script is enabled.
			IsEnabled bool `json:"isEnabled"`

			// IsRunOnce Whether the startup script is run once on first boot or on every boot.
			IsRunOnce bool `json:"isRunOnce"`

			// Name The name of the startup script.
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStorageProvidersListResponse parses an HTTP response from a StorageProvidersListWithResponse call
func ParseStorageProvidersListResponse(rsp *http.Response) (*StorageProvidersListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StorageProvidersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// Id The ID of the storage provider
				Id string `json:"id"`

				// IsManaged Whether the storage provider is managed by Paperspace
				IsManaged bool `json:"isManaged"`

				// IsTeamDefault Whether the storage provider is the team's default provider
				IsTeamDefault *bool `json:"isTeamDefault"`

				// Name The name of the storage provider
				Name string `json:"name"`

				// S3Config The storage provider configuration
				S3Config struct {
					AccessKey        string                                          `json:"accessKey"`
					Bucket           string                                          `json:"bucket"`
					Endpoint         *string                                         `json:"endpoint"`
					Region           *StorageProvidersList_200_Items_S3Config_Region `json:"region"`
					RetainData       *bool                                           `json:"retainData"`
					SecretAccessKey  string                                          `json:"secretAccessKey"`
					SignatureVersion *string                                         `json:"signatureVersion"`
				} `json:"s3Config"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStorageProvidersCreateResponse parses an HTTP response from a StorageProvidersCreateWithResponse call
func ParseStorageProvidersCreateResponse(rsp *http.Response) (*StorageProvidersCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StorageProvidersCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The ID of the storage provider
			Id string `json:"id"`

			// IsManaged Whether the storage provider is managed by Paperspace
			IsManaged bool `json:"isManaged"`

			// IsTeamDefault Whether the storage provider is the team's default provider
			IsTeamDefault *bool `json:"isTeamDefault"`

			// Name The name of the storage provider
			Name string `json:"name"`

			// S3Config The storage provider configuration
			S3Config struct {
				AccessKey        string                                      `json:"accessKey"`
				Bucket           string                                      `json:"bucket"`
				Endpoint         *string                                     `json:"endpoint"`
				Region           *StorageProvidersCreate_200_S3Config_Region `json:"region"`
				RetainData       *bool                                       `json:"retainData"`
				SecretAccessKey  string                                      `json:"secretAccessKey"`
				SignatureVersion *string                                     `json:"signatureVersion"`
			} `json:"s3Config"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStorageUtilizationGetPublicResponse parses an HTTP response from a StorageUtilizationGetPublicWithResponse call
func ParseStorageUtilizationGetPublicResponse(rsp *http.Response) (*StorageUtilizationGetPublicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StorageUtilizationGetPublicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DatasetUsage Storage used by datasets in bytes
			DatasetUsage string `json:"datasetUsage"`

			// ModelUsage Storage used by models in bytes
			ModelUsage string `json:"modelUsage"`

			// NotebookWorkspaceUsage Storage used by notebooks files in bytes
			NotebookWorkspaceUsage string `json:"notebookWorkspaceUsage"`

			// RemainingFreeStorage The amount of free storage left before you reach your plan's limit in bytes
			RemainingFreeStorage string `json:"remainingFreeStorage"`

			// SharedStorageUsage Persistent storage used by the notebook shared storage directory in bytes
			SharedStorageUsage string `json:"sharedStorageUsage"`

			// TotalFreeStorage The amount of free storage that comes with your current plan in bytes
			TotalFreeStorage string `json:"totalFreeStorage"`

			// TotalUsage Total storage used by your team in bytes
			TotalUsage string `json:"totalUsage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStorageProvidersDeleteResponse parses an HTTP response from a StorageProvidersDeleteWithResponse call
func ParseStorageProvidersDeleteResponse(rsp *http.Response) (*StorageProvidersDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StorageProvidersDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The ID of the storage provider
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStorageProvidersGetResponse parses an HTTP response from a StorageProvidersGetWithResponse call
func ParseStorageProvidersGetResponse(rsp *http.Response) (*StorageProvidersGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StorageProvidersGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The ID of the storage provider
			Id string `json:"id"`

			// IsManaged Whether the storage provider is managed by Paperspace
			IsManaged bool `json:"isManaged"`

			// IsTeamDefault Whether the storage provider is the team's default provider
			IsTeamDefault *bool `json:"isTeamDefault"`

			// Name The name of the storage provider
			Name string `json:"name"`

			// S3Config The storage provider configuration
			S3Config struct {
				AccessKey        string                                   `json:"accessKey"`
				Bucket           string                                   `json:"bucket"`
				Endpoint         *string                                  `json:"endpoint"`
				Region           *StorageProvidersGet_200_S3Config_Region `json:"region"`
				RetainData       *bool                                    `json:"retainData"`
				SecretAccessKey  string                                   `json:"secretAccessKey"`
				SignatureVersion *string                                  `json:"signatureVersion"`
			} `json:"s3Config"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStorageProvidersUpdateResponse parses an HTTP response from a StorageProvidersUpdateWithResponse call
func ParseStorageProvidersUpdateResponse(rsp *http.Response) (*StorageProvidersUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StorageProvidersUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The ID of the storage provider
			Id string `json:"id"`

			// IsManaged Whether the storage provider is managed by Paperspace
			IsManaged bool `json:"isManaged"`

			// IsTeamDefault Whether the storage provider is the team's default provider
			IsTeamDefault *bool `json:"isTeamDefault"`

			// Name The name of the storage provider
			Name string `json:"name"`

			// S3Config The storage provider configuration
			S3Config struct {
				AccessKey        string                                      `json:"accessKey"`
				Bucket           string                                      `json:"bucket"`
				Endpoint         *string                                     `json:"endpoint"`
				Region           *StorageProvidersUpdate_200_S3Config_Region `json:"region"`
				RetainData       *bool                                       `json:"retainData"`
				SecretAccessKey  string                                      `json:"secretAccessKey"`
				SignatureVersion *string                                     `json:"signatureVersion"`
			} `json:"s3Config"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTeamSecretsListResponse parses an HTTP response from a TeamSecretsListWithResponse call
func ParseTeamSecretsListResponse(rsp *http.Response) (*TeamSecretsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamSecretsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// DtCreated The date the secret was created.
				DtCreated time.Time `json:"dtCreated"`

				// DtModified The date the secret was last modified.
				DtModified            time.Time `json:"dtModified"`
				HasDeploymentAttached bool      `json:"hasDeploymentAttached"`

				// Name The name of the secret, e.g. "DB_PASSWORD".
				Name string `json:"name"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTeamSecretsCreateResponse parses an HTTP response from a TeamSecretsCreateWithResponse call
func ParseTeamSecretsCreateResponse(rsp *http.Response) (*TeamSecretsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamSecretsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the secret was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the secret was last modified.
			DtModified time.Time `json:"dtModified"`

			// Name The name of the secret, e.g. "DB_PASSWORD".
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTeamSecretsDeleteResponse parses an HTTP response from a TeamSecretsDeleteWithResponse call
func ParseTeamSecretsDeleteResponse(rsp *http.Response) (*TeamSecretsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamSecretsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Name The name of the secret, e.g. "DB_PASSWORD".
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTeamSecretsGetResponse parses an HTTP response from a TeamSecretsGetWithResponse call
func ParseTeamSecretsGetResponse(rsp *http.Response) (*TeamSecretsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamSecretsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the secret was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the secret was last modified.
			DtModified            time.Time `json:"dtModified"`
			HasDeploymentAttached bool      `json:"hasDeploymentAttached"`

			// Name The name of the secret, e.g. "DB_PASSWORD".
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTeamSecretsUpdateResponse parses an HTTP response from a TeamSecretsUpdateWithResponse call
func ParseTeamSecretsUpdateResponse(rsp *http.Response) (*TeamSecretsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamSecretsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtCreated The date the secret was created.
			DtCreated time.Time `json:"dtCreated"`

			// DtModified The date the secret was last modified.
			DtModified time.Time `json:"dtModified"`

			// Name The name of the secret, e.g. "DB_PASSWORD".
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTeamMembershipsListByTeamIdResponse parses an HTTP response from a TeamMembershipsListByTeamIdWithResponse call
func ParseTeamMembershipsListByTeamIdResponse(rsp *http.Response) (*TeamMembershipsListByTeamIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamMembershipsListByTeamIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasMore Whether there are more pages of results available.
			HasMore bool `json:"hasMore"`

			// Items The items on this page.
			Items []struct {
				// DtConfirmed The date the user confirmed their membership
				DtConfirmed *time.Time `json:"dtConfirmed"`

				// IsAdmin Whether the user is an admin of the team
				IsAdmin bool `json:"isAdmin"`

				// IsOwner Whether the user is the owner of the team
				IsOwner bool `json:"isOwner"`
				User    struct {
					// Email The email address of the user
					Email string `json:"email"`

					// FirstName The first name of the user
					FirstName *string `json:"firstName"`

					// Id The ID of the user
					Id string `json:"id"`

					// LastActive The date the user was last active.
					LastActive *time.Time `json:"lastActive"`

					// LastName The last name of the user
					LastName *string `json:"lastName"`

					// PublicProfileImageUrl The URL of the team's profile image.
					PublicProfileImageUrl *string `json:"publicProfileImageUrl"`
				} `json:"user"`
			} `json:"items"`

			// NextPage The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
			NextPage *string `json:"nextPage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTeamMembershipsRemoveUserResponse parses an HTTP response from a TeamMembershipsRemoveUserWithResponse call
func ParseTeamMembershipsRemoveUserResponse(rsp *http.Response) (*TeamMembershipsRemoveUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamMembershipsRemoveUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtConfirmed The date the user confirmed their membership
			DtConfirmed *time.Time `json:"dtConfirmed"`

			// DtDeleted The date the user was removed from the team
			DtDeleted *time.Time `json:"dtDeleted"`

			// IsAdmin Whether the user is an admin of the team
			IsAdmin bool `json:"isAdmin"`

			// IsOwner Whether the user is the owner of the team
			IsOwner bool `json:"isOwner"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTeamMembershipsUpdateResponse parses an HTTP response from a TeamMembershipsUpdateWithResponse call
func ParseTeamMembershipsUpdateResponse(rsp *http.Response) (*TeamMembershipsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamMembershipsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DtConfirmed The date the user confirmed their membership
			DtConfirmed *time.Time `json:"dtConfirmed"`

			// DtDeleted The date the user was removed from the team
			DtDeleted *time.Time `json:"dtDeleted"`

			// IsAdmin Whether the user is an admin of the team
			IsAdmin bool `json:"isAdmin"`

			// IsOwner Whether the user is the owner of the team
			IsOwner bool `json:"isOwner"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
